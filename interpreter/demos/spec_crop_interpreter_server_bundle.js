/*! For license information please see spec_crop_interpreter_server_bundle.js.LICENSE.txt */
!function(){var e={701:function(e,t){var n,r,s;r=[],void 0===(s="function"==typeof(n=function(){"use strict";var e="14.6.0";function t(e){return"object"==typeof e&&"function"==typeof e.to&&"function"==typeof e.from}function n(e){e.parentElement.removeChild(e)}function r(e){return null!=e}function s(e){e.preventDefault()}function a(e){return e.filter((function(e){return!this[e]&&(this[e]=!0)}),{})}function i(e,t){return Math.round(e/t)*t}function o(e,t){var n=e.getBoundingClientRect(),r=e.ownerDocument,s=r.documentElement,a=g(r);return/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)&&(a.x=0),t?n.top+a.y-s.clientTop:n.left+a.x-s.clientLeft}function u(e){return"number"==typeof e&&!isNaN(e)&&isFinite(e)}function l(e,t,n){n>0&&(d(e,t),setTimeout((function(){f(e,t)}),n))}function c(e){return Math.max(Math.min(e,100),0)}function h(e){return Array.isArray(e)?e:[e]}function p(e){var t=(e=String(e)).split(".");return t.length>1?t[1].length:0}function d(e,t){e.classList&&!/\s/.test(t)?e.classList.add(t):e.className+=" "+t}function f(e,t){e.classList&&!/\s/.test(t)?e.classList.remove(t):e.className=e.className.replace(new RegExp("(^|\\b)"+t.split(" ").join("|")+"(\\b|$)","gi")," ")}function m(e,t){return e.classList?e.classList.contains(t):new RegExp("\\b"+t+"\\b").test(e.className)}function g(e){var t=void 0!==window.pageXOffset,n="CSS1Compat"===(e.compatMode||"");return{x:t?window.pageXOffset:n?e.documentElement.scrollLeft:e.body.scrollLeft,y:t?window.pageYOffset:n?e.documentElement.scrollTop:e.body.scrollTop}}function y(){return window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",end:"mouseup touchend"}}function b(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("test",null,t)}catch(e){}return e}function x(){return window.CSS&&CSS.supports&&CSS.supports("touch-action","none")}function w(e,t){return 100/(t-e)}function v(e,t,n){return 100*t/(e[n+1]-e[n])}function k(e,t){return v(e,e[0]<0?t+Math.abs(e[0]):t-e[0],0)}function I(e,t){return t*(e[1]-e[0])/100+e[0]}function N(e,t){for(var n=1;e>=t[n];)n+=1;return n}function S(e,t,n){if(n>=e.slice(-1)[0])return 100;var r=N(n,e),s=e[r-1],a=e[r],i=t[r-1],o=t[r];return i+k([s,a],n)/w(i,o)}function C(e,t,n){if(n>=100)return e.slice(-1)[0];var r=N(n,t),s=e[r-1],a=e[r],i=t[r-1];return I([s,a],(n-i)*w(i,t[r]))}function E(e,t,n,r){if(100===r)return r;var s=N(r,e),a=e[s-1],o=e[s];return n?r-a>(o-a)/2?o:a:t[s-1]?e[s-1]+i(r-e[s-1],t[s-1]):r}function T(t,n,r){var s;if("number"==typeof n&&(n=[n]),!Array.isArray(n))throw new Error("noUiSlider ("+e+"): 'range' contains invalid value.");if(!u(s="min"===t?0:"max"===t?100:parseFloat(t))||!u(n[0]))throw new Error("noUiSlider ("+e+"): 'range' value isn't numeric.");r.xPct.push(s),r.xVal.push(n[0]),s?r.xSteps.push(!isNaN(n[1])&&n[1]):isNaN(n[1])||(r.xSteps[0]=n[1]),r.xHighestCompleteStep.push(0)}function $(e,t,n){if(t)if(n.xVal[e]!==n.xVal[e+1]){n.xSteps[e]=v([n.xVal[e],n.xVal[e+1]],t,0)/w(n.xPct[e],n.xPct[e+1]);var r=(n.xVal[e+1]-n.xVal[e])/n.xNumSteps[e],s=Math.ceil(Number(r.toFixed(3))-1),a=n.xVal[e]+n.xNumSteps[e]*s;n.xHighestCompleteStep[e]=a}else n.xSteps[e]=n.xHighestCompleteStep[e]=n.xVal[e]}function A(e,t,n){var r;this.xPct=[],this.xVal=[],this.xSteps=[n||!1],this.xNumSteps=[!1],this.xHighestCompleteStep=[],this.snap=t;var s=[];for(r in e)e.hasOwnProperty(r)&&s.push([e[r],r]);for(s.length&&"object"==typeof s[0][0]?s.sort((function(e,t){return e[0][0]-t[0][0]})):s.sort((function(e,t){return e[0]-t[0]})),r=0;r<s.length;r++)T(s[r][1],s[r][0],this);for(this.xNumSteps=this.xSteps.slice(0),r=0;r<this.xNumSteps.length;r++)$(r,this.xNumSteps[r],this)}A.prototype.getDistance=function(t){var n,r=[];for(n=0;n<this.xNumSteps.length-1;n++){var s=this.xNumSteps[n];if(s&&t/s%1!=0)throw new Error("noUiSlider ("+e+"): 'limit', 'margin' and 'padding' of "+this.xPct[n]+"% range must be divisible by step.");r[n]=v(this.xVal,t,n)}return r},A.prototype.getAbsoluteDistance=function(e,t,n){var r,s=0;if(e<this.xPct[this.xPct.length-1])for(;e>this.xPct[s+1];)s++;else e===this.xPct[this.xPct.length-1]&&(s=this.xPct.length-2);n||e!==this.xPct[s+1]||s++;var a=1,i=t[s],o=0,u=0,l=0,c=0;for(r=n?(e-this.xPct[s])/(this.xPct[s+1]-this.xPct[s]):(this.xPct[s+1]-e)/(this.xPct[s+1]-this.xPct[s]);i>0;)o=this.xPct[s+1+c]-this.xPct[s+c],t[s+c]*a+100-100*r>100?(u=o*r,a=(i-100*r)/t[s+c],r=1):(u=t[s+c]*o/100*a,a=0),n?(l-=u,this.xPct.length+c>=1&&c--):(l+=u,this.xPct.length-c>=1&&c++),i=t[s+c]*a;return e+l},A.prototype.toStepping=function(e){return e=S(this.xVal,this.xPct,e)},A.prototype.fromStepping=function(e){return C(this.xVal,this.xPct,e)},A.prototype.getStep=function(e){return e=E(this.xPct,this.xSteps,this.snap,e)},A.prototype.getDefaultStep=function(e,t,n){var r=N(e,this.xPct);return(100===e||t&&e===this.xPct[r-1])&&(r=Math.max(r-1,1)),(this.xVal[r]-this.xVal[r-1])/n},A.prototype.getNearbySteps=function(e){var t=N(e,this.xPct);return{stepBefore:{startValue:this.xVal[t-2],step:this.xNumSteps[t-2],highestStep:this.xHighestCompleteStep[t-2]},thisStep:{startValue:this.xVal[t-1],step:this.xNumSteps[t-1],highestStep:this.xHighestCompleteStep[t-1]},stepAfter:{startValue:this.xVal[t],step:this.xNumSteps[t],highestStep:this.xHighestCompleteStep[t]}}},A.prototype.countStepDecimals=function(){var e=this.xNumSteps.map(p);return Math.max.apply(null,e)},A.prototype.convert=function(e){return this.getStep(this.toStepping(e))};var R={to:function(e){return void 0!==e&&e.toFixed(2)},from:Number},_={target:"target",base:"base",origin:"origin",handle:"handle",handleLower:"handle-lower",handleUpper:"handle-upper",touchArea:"touch-area",horizontal:"horizontal",vertical:"vertical",background:"background",connect:"connect",connects:"connects",ltr:"ltr",rtl:"rtl",textDirectionLtr:"txt-dir-ltr",textDirectionRtl:"txt-dir-rtl",draggable:"draggable",drag:"state-drag",tap:"state-tap",active:"active",tooltip:"tooltip",pips:"pips",pipsHorizontal:"pips-horizontal",pipsVertical:"pips-vertical",marker:"marker",markerHorizontal:"marker-horizontal",markerVertical:"marker-vertical",markerNormal:"marker-normal",markerLarge:"marker-large",markerSub:"marker-sub",value:"value",valueHorizontal:"value-horizontal",valueVertical:"value-vertical",valueNormal:"value-normal",valueLarge:"value-large",valueSub:"value-sub"};function F(n){if(t(n))return!0;throw new Error("noUiSlider ("+e+"): 'format' requires 'to' and 'from' methods.")}function D(t,n){if(!u(n))throw new Error("noUiSlider ("+e+"): 'step' is not numeric.");t.singleStep=n}function O(t,n){if(!u(n))throw new Error("noUiSlider ("+e+"): 'keyboardPageMultiplier' is not numeric.");t.keyboardPageMultiplier=n}function M(t,n){if(!u(n))throw new Error("noUiSlider ("+e+"): 'keyboardDefaultStep' is not numeric.");t.keyboardDefaultStep=n}function L(t,n){if("object"!=typeof n||Array.isArray(n))throw new Error("noUiSlider ("+e+"): 'range' is not an object.");if(void 0===n.min||void 0===n.max)throw new Error("noUiSlider ("+e+"): Missing 'min' or 'max' in 'range'.");if(n.min===n.max)throw new Error("noUiSlider ("+e+"): 'range' 'min' and 'max' cannot be equal.");t.spectrum=new A(n,t.snap,t.singleStep)}function z(t,n){if(n=h(n),!Array.isArray(n)||!n.length)throw new Error("noUiSlider ("+e+"): 'start' option is incorrect.");t.handles=n.length,t.start=n}function B(t,n){if(t.snap=n,"boolean"!=typeof n)throw new Error("noUiSlider ("+e+"): 'snap' option must be a boolean.")}function P(t,n){if(t.animate=n,"boolean"!=typeof n)throw new Error("noUiSlider ("+e+"): 'animate' option must be a boolean.")}function V(t,n){if(t.animationDuration=n,"number"!=typeof n)throw new Error("noUiSlider ("+e+"): 'animationDuration' option must be a number.")}function W(t,n){var r,s=[!1];if("lower"===n?n=[!0,!1]:"upper"===n&&(n=[!1,!0]),!0===n||!1===n){for(r=1;r<t.handles;r++)s.push(n);s.push(!1)}else{if(!Array.isArray(n)||!n.length||n.length!==t.handles+1)throw new Error("noUiSlider ("+e+"): 'connect' option doesn't match handle count.");s=n}t.connect=s}function U(t,n){switch(n){case"horizontal":t.ort=0;break;case"vertical":t.ort=1;break;default:throw new Error("noUiSlider ("+e+"): 'orientation' option is invalid.")}}function G(t,n){if(!u(n))throw new Error("noUiSlider ("+e+"): 'margin' option must be numeric.");0!==n&&(t.margin=t.spectrum.getDistance(n))}function j(t,n){if(!u(n))throw new Error("noUiSlider ("+e+"): 'limit' option must be numeric.");if(t.limit=t.spectrum.getDistance(n),!t.limit||t.handles<2)throw new Error("noUiSlider ("+e+"): 'limit' option is only supported on linear sliders with 2 or more handles.")}function H(t,n){var r;if(!u(n)&&!Array.isArray(n))throw new Error("noUiSlider ("+e+"): 'padding' option must be numeric or array of exactly 2 numbers.");if(Array.isArray(n)&&2!==n.length&&!u(n[0])&&!u(n[1]))throw new Error("noUiSlider ("+e+"): 'padding' option must be numeric or array of exactly 2 numbers.");if(0!==n){for(Array.isArray(n)||(n=[n,n]),t.padding=[t.spectrum.getDistance(n[0]),t.spectrum.getDistance(n[1])],r=0;r<t.spectrum.xNumSteps.length-1;r++)if(t.padding[0][r]<0||t.padding[1][r]<0)throw new Error("noUiSlider ("+e+"): 'padding' option must be a positive number(s).");var s=n[0]+n[1],a=t.spectrum.xVal[0];if(s/(t.spectrum.xVal[t.spectrum.xVal.length-1]-a)>1)throw new Error("noUiSlider ("+e+"): 'padding' option must not exceed 100% of the range.")}}function q(t,n){switch(n){case"ltr":t.dir=0;break;case"rtl":t.dir=1;break;default:throw new Error("noUiSlider ("+e+"): 'direction' option was not recognized.")}}function K(t,n){if("string"!=typeof n)throw new Error("noUiSlider ("+e+"): 'behaviour' must be a string containing options.");var r=n.indexOf("tap")>=0,s=n.indexOf("drag")>=0,a=n.indexOf("fixed")>=0,i=n.indexOf("snap")>=0,o=n.indexOf("hover")>=0,u=n.indexOf("unconstrained")>=0;if(a){if(2!==t.handles)throw new Error("noUiSlider ("+e+"): 'fixed' behaviour must be used with 2 handles");G(t,t.start[1]-t.start[0])}if(u&&(t.margin||t.limit))throw new Error("noUiSlider ("+e+"): 'unconstrained' behaviour cannot be used with margin or limit");t.events={tap:r||i,drag:s,fixed:a,snap:i,hover:o,unconstrained:u}}function X(t,n){if(!1!==n)if(!0===n){t.tooltips=[];for(var r=0;r<t.handles;r++)t.tooltips.push(!0)}else{if(t.tooltips=h(n),t.tooltips.length!==t.handles)throw new Error("noUiSlider ("+e+"): must pass a formatter for all handles.");t.tooltips.forEach((function(t){if("boolean"!=typeof t&&("object"!=typeof t||"function"!=typeof t.to))throw new Error("noUiSlider ("+e+"): 'tooltips' must be passed a formatter or 'false'.")}))}}function Y(e,t){e.ariaFormat=t,F(t)}function J(e,t){e.format=t,F(t)}function Z(t,n){if(t.keyboardSupport=n,"boolean"!=typeof n)throw new Error("noUiSlider ("+e+"): 'keyboardSupport' option must be a boolean.")}function Q(e,t){e.documentElement=t}function ee(t,n){if("string"!=typeof n&&!1!==n)throw new Error("noUiSlider ("+e+"): 'cssPrefix' must be a string or `false`.");t.cssPrefix=n}function te(t,n){if("object"!=typeof n)throw new Error("noUiSlider ("+e+"): 'cssClasses' must be an object.");if("string"==typeof t.cssPrefix)for(var r in t.cssClasses={},n)n.hasOwnProperty(r)&&(t.cssClasses[r]=t.cssPrefix+n[r]);else t.cssClasses=n}function ne(t){var n={margin:0,limit:0,padding:0,animate:!0,animationDuration:300,ariaFormat:R,format:R},s={step:{r:!1,t:D},keyboardPageMultiplier:{r:!1,t:O},keyboardDefaultStep:{r:!1,t:M},start:{r:!0,t:z},connect:{r:!0,t:W},direction:{r:!0,t:q},snap:{r:!1,t:B},animate:{r:!1,t:P},animationDuration:{r:!1,t:V},range:{r:!0,t:L},orientation:{r:!1,t:U},margin:{r:!1,t:G},limit:{r:!1,t:j},padding:{r:!1,t:H},behaviour:{r:!0,t:K},ariaFormat:{r:!1,t:Y},format:{r:!1,t:J},tooltips:{r:!1,t:X},keyboardSupport:{r:!0,t:Z},documentElement:{r:!1,t:Q},cssPrefix:{r:!0,t:ee},cssClasses:{r:!0,t:te}},a={connect:!1,direction:"ltr",behaviour:"tap",orientation:"horizontal",keyboardSupport:!0,cssPrefix:"noUi-",cssClasses:_,keyboardPageMultiplier:5,keyboardDefaultStep:10};t.format&&!t.ariaFormat&&(t.ariaFormat=t.format),Object.keys(s).forEach((function(i){if(!r(t[i])&&void 0===a[i]){if(s[i].r)throw new Error("noUiSlider ("+e+"): '"+i+"' is required.");return!0}s[i].t(n,r(t[i])?t[i]:a[i])})),n.pips=t.pips;var i=document.createElement("div"),o=void 0!==i.style.msTransform,u=void 0!==i.style.transform;n.transformRule=u?"transform":o?"msTransform":"webkitTransform";var l=[["left","top"],["right","bottom"]];return n.style=l[n.dir][n.ort],n}function re(t,r,i){var u,p,w,v,k,I,N=y(),S=x()&&b(),C=t,E=r.spectrum,T=[],$=[],A=[],R=0,_={},F=t.ownerDocument,D=r.documentElement||F.documentElement,O=F.body,M=-1,L=0,z=1,B=2,P="rtl"===F.dir||1===r.ort?0:100;function V(e,t){var n=F.createElement("div");return t&&d(n,t),e.appendChild(n),n}function W(e,t){var n=V(e,r.cssClasses.origin),s=V(n,r.cssClasses.handle);return V(s,r.cssClasses.touchArea),s.setAttribute("data-handle",t),r.keyboardSupport&&(s.setAttribute("tabindex","0"),s.addEventListener("keydown",(function(e){return me(e,t)}))),s.setAttribute("role","slider"),s.setAttribute("aria-orientation",r.ort?"vertical":"horizontal"),0===t?d(s,r.cssClasses.handleLower):t===r.handles-1&&d(s,r.cssClasses.handleUpper),n}function U(e,t){return!!t&&V(e,r.cssClasses.connect)}function G(e,t){var n=V(t,r.cssClasses.connects);p=[],(w=[]).push(U(n,e[0]));for(var s=0;s<r.handles;s++)p.push(W(t,s)),A[s]=s,w.push(U(n,e[s+1]))}function j(e){return d(e,r.cssClasses.target),0===r.dir?d(e,r.cssClasses.ltr):d(e,r.cssClasses.rtl),0===r.ort?d(e,r.cssClasses.horizontal):d(e,r.cssClasses.vertical),d(e,"rtl"===getComputedStyle(e).direction?r.cssClasses.textDirectionRtl:r.cssClasses.textDirectionLtr),V(e,r.cssClasses.base)}function H(e,t){return!!r.tooltips[t]&&V(e.firstChild,r.cssClasses.tooltip)}function q(){return C.hasAttribute("disabled")}function K(e){return p[e].hasAttribute("disabled")}function X(){k&&(be("update.tooltips"),k.forEach((function(e){e&&n(e)})),k=null)}function Y(){X(),k=p.map(H),ye("update.tooltips",(function(e,t,n){if(k[t]){var s=e[t];!0!==r.tooltips[t]&&(s=r.tooltips[t].to(n[t])),k[t].innerHTML=s}}))}function J(){ye("update",(function(e,t,n,s,a){A.forEach((function(e){var t=p[e],s=we($,e,0,!0,!0,!0),i=we($,e,100,!0,!0,!0),o=a[e],u=r.ariaFormat.to(n[e]);s=E.fromStepping(s).toFixed(1),i=E.fromStepping(i).toFixed(1),o=E.fromStepping(o).toFixed(1),t.children[0].setAttribute("aria-valuemin",s),t.children[0].setAttribute("aria-valuemax",i),t.children[0].setAttribute("aria-valuenow",o),t.children[0].setAttribute("aria-valuetext",u)}))}))}function Z(t,n,r){if("range"===t||"steps"===t)return E.xVal;if("count"===t){if(n<2)throw new Error("noUiSlider ("+e+"): 'values' (>= 2) required for mode 'count'.");var s=n-1,a=100/s;for(n=[];s--;)n[s]=s*a;n.push(100),t="positions"}return"positions"===t?n.map((function(e){return E.fromStepping(r?E.getStep(e):e)})):"values"===t?r?n.map((function(e){return E.fromStepping(E.getStep(E.toStepping(e)))})):n:void 0}function Q(e,t,n){function r(e,t){return(e+t).toFixed(7)/1}var s={},i=E.xVal[0],o=E.xVal[E.xVal.length-1],u=!1,l=!1,c=0;return(n=a(n.slice().sort((function(e,t){return e-t}))))[0]!==i&&(n.unshift(i),u=!0),n[n.length-1]!==o&&(n.push(o),l=!0),n.forEach((function(a,i){var o,h,p,d,f,m,g,y,b,x,w=a,v=n[i+1],k="steps"===t;if(k&&(o=E.xNumSteps[i]),o||(o=v-w),!1!==w&&void 0!==v)for(o=Math.max(o,1e-7),h=w;h<=v;h=r(h,o)){for(y=(f=(d=E.toStepping(h))-c)/e,x=f/(b=Math.round(y)),p=1;p<=b;p+=1)s[(m=c+p*x).toFixed(5)]=[E.fromStepping(m),0];g=n.indexOf(h)>-1?z:k?B:L,!i&&u&&h!==v&&(g=0),h===v&&l||(s[d.toFixed(5)]=[h,g]),c=d}})),s}function ee(e,t,n){var s=F.createElement("div"),a=[];a[L]=r.cssClasses.valueNormal,a[z]=r.cssClasses.valueLarge,a[B]=r.cssClasses.valueSub;var i=[];i[L]=r.cssClasses.markerNormal,i[z]=r.cssClasses.markerLarge,i[B]=r.cssClasses.markerSub;var o=[r.cssClasses.valueHorizontal,r.cssClasses.valueVertical],u=[r.cssClasses.markerHorizontal,r.cssClasses.markerVertical];function l(e,t){var n=t===r.cssClasses.value,s=n?a:i;return t+" "+(n?o:u)[r.ort]+" "+s[e]}function c(e,a,i){if((i=t?t(a,i):i)!==M){var o=V(s,!1);o.className=l(i,r.cssClasses.marker),o.style[r.style]=e+"%",i>L&&((o=V(s,!1)).className=l(i,r.cssClasses.value),o.setAttribute("data-value",a),o.style[r.style]=e+"%",o.innerHTML=n.to(a))}}return d(s,r.cssClasses.pips),d(s,0===r.ort?r.cssClasses.pipsHorizontal:r.cssClasses.pipsVertical),Object.keys(e).forEach((function(t){c(t,e[t][0],e[t][1])})),s}function te(){v&&(n(v),v=null)}function re(e){te();var t=e.mode,n=e.density||1,r=e.filter||!1,s=Q(n,t,Z(t,e.values||!1,e.stepped||!1)),a=e.format||{to:Math.round};return v=C.appendChild(ee(s,r,a))}function se(){var e=u.getBoundingClientRect(),t="offset"+["Width","Height"][r.ort];return 0===r.ort?e.width||u[t]:e.height||u[t]}function ae(e,t,n,s){var a=function(a){return!!(a=ie(a,s.pageOffset,s.target||t))&&!(q()&&!s.doNotReject)&&!(m(C,r.cssClasses.tap)&&!s.doNotReject)&&!(e===N.start&&void 0!==a.buttons&&a.buttons>1)&&(!s.hover||!a.buttons)&&(S||a.preventDefault(),a.calcPoint=a.points[r.ort],void n(a,s))},i=[];return e.split(" ").forEach((function(e){t.addEventListener(e,a,!!S&&{passive:!0}),i.push([e,a])})),i}function ie(e,t,n){var r,s,a=0===e.type.indexOf("touch"),i=0===e.type.indexOf("mouse"),o=0===e.type.indexOf("pointer");if(0===e.type.indexOf("MSPointer")&&(o=!0),a){var u=function(e){return e.target===n||n.contains(e.target)||e.target.shadowRoot&&e.target.shadowRoot.contains(n)};if("touchstart"===e.type){var l=Array.prototype.filter.call(e.touches,u);if(l.length>1)return!1;r=l[0].pageX,s=l[0].pageY}else{var c=Array.prototype.find.call(e.changedTouches,u);if(!c)return!1;r=c.pageX,s=c.pageY}}return t=t||g(F),(i||o)&&(r=e.clientX+t.x,s=e.clientY+t.y),e.pageOffset=t,e.points=[r,s],e.cursor=i||o,e}function oe(e){var t=100*(e-o(u,r.ort))/se();return t=c(t),r.dir?100-t:t}function ue(e){var t=100,n=!1;return p.forEach((function(r,s){if(!K(s)){var a=$[s],i=Math.abs(a-e);(i<t||i<=t&&e>a||100===i&&100===t)&&(n=s,t=i)}})),n}function le(e,t){"mouseout"===e.type&&"HTML"===e.target.nodeName&&null===e.relatedTarget&&he(e,t)}function ce(e,t){if(-1===navigator.appVersion.indexOf("MSIE 9")&&0===e.buttons&&0!==t.buttonsProperty)return he(e,t);var n=(r.dir?-1:1)*(e.calcPoint-t.startCalcPoint);ke(n>0,100*n/t.baseSize,t.locations,t.handleNumbers)}function he(e,t){t.handle&&(f(t.handle,r.cssClasses.active),R-=1),t.listeners.forEach((function(e){D.removeEventListener(e[0],e[1])})),0===R&&(f(C,r.cssClasses.drag),Se(),e.cursor&&(O.style.cursor="",O.removeEventListener("selectstart",s))),t.handleNumbers.forEach((function(e){xe("change",e),xe("set",e),xe("end",e)}))}function pe(e,t){if(t.handleNumbers.some(K))return!1;var n;1===t.handleNumbers.length&&(n=p[t.handleNumbers[0]].children[0],R+=1,d(n,r.cssClasses.active)),e.stopPropagation();var a=[],i=ae(N.move,D,ce,{target:e.target,handle:n,listeners:a,startCalcPoint:e.calcPoint,baseSize:se(),pageOffset:e.pageOffset,handleNumbers:t.handleNumbers,buttonsProperty:e.buttons,locations:$.slice()}),o=ae(N.end,D,he,{target:e.target,handle:n,listeners:a,doNotReject:!0,handleNumbers:t.handleNumbers}),u=ae("mouseout",D,le,{target:e.target,handle:n,listeners:a,doNotReject:!0,handleNumbers:t.handleNumbers});a.push.apply(a,i.concat(o,u)),e.cursor&&(O.style.cursor=getComputedStyle(e.target).cursor,p.length>1&&d(C,r.cssClasses.drag),O.addEventListener("selectstart",s,!1)),t.handleNumbers.forEach((function(e){xe("start",e)}))}function de(e){if(!e.buttons&&!e.touches)return!1;e.stopPropagation();var t=oe(e.calcPoint),n=ue(t);if(!1===n)return!1;r.events.snap||l(C,r.cssClasses.tap,r.animationDuration),Ce(n,t,!0,!0),Se(),xe("slide",n,!0),xe("update",n,!0),xe("change",n,!0),xe("set",n,!0),r.events.snap&&pe(e,{handleNumbers:[n]})}function fe(e){var t=oe(e.calcPoint),n=E.getStep(t),r=E.fromStepping(n);Object.keys(_).forEach((function(e){"hover"===e.split(".")[0]&&_[e].forEach((function(e){e.call(I,r)}))}))}function me(e,t){if(q()||K(t))return!1;var n=["Left","Right"],s=["Down","Up"],a=["PageDown","PageUp"],i=["Home","End"];r.dir&&!r.ort?n.reverse():r.ort&&!r.dir&&(s.reverse(),a.reverse());var o,u=e.key.replace("Arrow",""),l=u===a[0],c=u===a[1],h=u===s[0]||u===n[0]||l,p=u===s[1]||u===n[1]||c,d=u===i[0],f=u===i[1];if(!(h||p||d||f))return!0;if(e.preventDefault(),p||h){var m=r.keyboardPageMultiplier,g=h?0:1,y=De(t)[g];if(null===y)return!1;!1===y&&(y=E.getDefaultStep($[t],h,r.keyboardDefaultStep)),(c||l)&&(y*=m),y=Math.max(y,1e-7),y*=h?-1:1,o=T[t]+y}else o=f?r.spectrum.xVal[r.spectrum.xVal.length-1]:r.spectrum.xVal[0];return Ce(t,E.toStepping(o),!0,!0),xe("slide",t),xe("update",t),xe("change",t),xe("set",t),!1}function ge(e){e.fixed||p.forEach((function(e,t){ae(N.start,e.children[0],pe,{handleNumbers:[t]})})),e.tap&&ae(N.start,u,de,{}),e.hover&&ae(N.move,u,fe,{hover:!0}),e.drag&&w.forEach((function(t,n){if(!1!==t&&0!==n&&n!==w.length-1){var s=p[n-1],a=p[n],i=[t];d(t,r.cssClasses.draggable),e.fixed&&(i.push(s.children[0]),i.push(a.children[0])),i.forEach((function(e){ae(N.start,e,pe,{handles:[s,a],handleNumbers:[n-1,n]})}))}}))}function ye(e,t){_[e]=_[e]||[],_[e].push(t),"update"===e.split(".")[0]&&p.forEach((function(e,t){xe("update",t)}))}function be(e){var t=e&&e.split(".")[0],n=t&&e.substring(t.length);Object.keys(_).forEach((function(e){var r=e.split(".")[0],s=e.substring(r.length);t&&t!==r||n&&n!==s||delete _[e]}))}function xe(e,t,n){Object.keys(_).forEach((function(s){var a=s.split(".")[0];e===a&&_[s].forEach((function(e){e.call(I,T.map(r.format.to),t,T.slice(),n||!1,$.slice(),I)}))}))}function we(e,t,n,s,a,i){var o;return p.length>1&&!r.events.unconstrained&&(s&&t>0&&(o=E.getAbsoluteDistance(e[t-1],r.margin,0),n=Math.max(n,o)),a&&t<p.length-1&&(o=E.getAbsoluteDistance(e[t+1],r.margin,1),n=Math.min(n,o))),p.length>1&&r.limit&&(s&&t>0&&(o=E.getAbsoluteDistance(e[t-1],r.limit,0),n=Math.min(n,o)),a&&t<p.length-1&&(o=E.getAbsoluteDistance(e[t+1],r.limit,1),n=Math.max(n,o))),r.padding&&(0===t&&(o=E.getAbsoluteDistance(0,r.padding[0],0),n=Math.max(n,o)),t===p.length-1&&(o=E.getAbsoluteDistance(100,r.padding[1],1),n=Math.min(n,o))),!((n=c(n=E.getStep(n)))===e[t]&&!i)&&n}function ve(e,t){var n=r.ort;return(n?t:e)+", "+(n?e:t)}function ke(e,t,n,r){var s=n.slice(),a=[!e,e],i=[e,!e];r=r.slice(),e&&r.reverse(),r.length>1?r.forEach((function(e,n){var r=we(s,e,s[e]+t,a[n],i[n],!1);!1===r?t=0:(t=r-s[e],s[e]=r)})):a=i=[!0];var o=!1;r.forEach((function(e,r){o=Ce(e,n[e]+t,a[r],i[r])||o})),o&&r.forEach((function(e){xe("update",e),xe("slide",e)}))}function Ie(e,t){return r.dir?100-e-t:e}function Ne(e,t){$[e]=t,T[e]=E.fromStepping(t);var n="translate("+ve(10*(Ie(t,0)-P)+"%","0")+")";p[e].style[r.transformRule]=n,Ee(e),Ee(e+1)}function Se(){A.forEach((function(e){var t=$[e]>50?-1:1,n=3+(p.length+t*e);p[e].style.zIndex=n}))}function Ce(e,t,n,r){return!1!==(t=we($,e,t,n,r,!1))&&(Ne(e,t),!0)}function Ee(e){if(w[e]){var t=0,n=100;0!==e&&(t=$[e-1]),e!==w.length-1&&(n=$[e]);var s=n-t,a="translate("+ve(Ie(t,s)+"%","0")+")",i="scale("+ve(s/100,"1")+")";w[e].style[r.transformRule]=a+" "+i}}function Te(e,t){return null===e||!1===e||void 0===e?$[t]:("number"==typeof e&&(e=String(e)),e=r.format.from(e),!1===(e=E.toStepping(e))||isNaN(e)?$[t]:e)}function $e(e,t){var n=h(e),s=void 0===$[0];t=void 0===t||!!t,r.animate&&!s&&l(C,r.cssClasses.tap,r.animationDuration),A.forEach((function(e){Ce(e,Te(n[e],e),!0,!1)}));for(var a=1===A.length?0:1;a<A.length;++a)A.forEach((function(e){Ce(e,$[e],!0,!0)}));Se(),A.forEach((function(e){xe("update",e),null!==n[e]&&t&&xe("set",e)}))}function Ae(e){$e(r.start,e)}function Re(t,n,r){if(!((t=Number(t))>=0&&t<A.length))throw new Error("noUiSlider ("+e+"): invalid handle number, got: "+t);Ce(t,Te(n,t),!0,!0),xe("update",t),r&&xe("set",t)}function _e(){var e=T.map(r.format.to);return 1===e.length?e[0]:e}function Fe(){for(var e in r.cssClasses)r.cssClasses.hasOwnProperty(e)&&f(C,r.cssClasses[e]);for(;C.firstChild;)C.removeChild(C.firstChild);delete C.noUiSlider}function De(e){var t=$[e],n=E.getNearbySteps(t),s=T[e],a=n.thisStep.step,i=null;if(r.snap)return[s-n.stepBefore.startValue||null,n.stepAfter.startValue-s||null];!1!==a&&s+a>n.stepAfter.startValue&&(a=n.stepAfter.startValue-s),i=s>n.thisStep.startValue?n.thisStep.step:!1!==n.stepBefore.step&&s-n.stepBefore.highestStep,100===t?a=null:0===t&&(i=null);var o=E.countStepDecimals();return null!==a&&!1!==a&&(a=Number(a.toFixed(o))),null!==i&&!1!==i&&(i=Number(i.toFixed(o))),[i,a]}function Oe(){return A.map(De)}function Me(e,t){var n=_e(),s=["margin","limit","padding","range","animate","snap","step","format","pips","tooltips"];s.forEach((function(t){void 0!==e[t]&&(i[t]=e[t])}));var a=ne(i);s.forEach((function(t){void 0!==e[t]&&(r[t]=a[t])})),E=a.spectrum,r.margin=a.margin,r.limit=a.limit,r.padding=a.padding,r.pips?re(r.pips):te(),r.tooltips?Y():X(),$=[],$e(e.start||n,t)}function Le(){u=j(C),G(r.connect,u),ge(r.events),$e(r.start),r.pips&&re(r.pips),r.tooltips&&Y(),J()}return Le(),I={destroy:Fe,steps:Oe,on:ye,off:be,get:_e,set:$e,setHandle:Re,reset:Ae,__moveHandles:function(e,t,n){ke(e,t,$,n)},options:i,updateOptions:Me,target:C,removePips:te,removeTooltips:X,getTooltips:function(){return k},getOrigins:function(){return p},pips:re}}function se(t,n){if(!t||!t.nodeName)throw new Error("noUiSlider ("+e+"): create requires a single element, got: "+t);if(t.noUiSlider)throw new Error("noUiSlider ("+e+"): Slider was already initialized.");var r=re(t,ne(n,t),n);return t.noUiSlider=r,r}return{__spectrum:A,version:e,cssClasses:_,create:se}})?n.apply(t,r):n)||(e.exports=s)},654:function(e,t,n){"use strict";n.r(t),n.d(t,{Abs:function(){return He},Acos:function(){return qe},Acosh:function(){return Ke},AdadeltaOptimizer:function(){return Bo},AdagradOptimizer:function(){return Vo},AdamOptimizer:function(){return Go},AdamaxOptimizer:function(){return Yo},Add:function(){return Xe},AddN:function(){return Ye},All:function(){return Je},Any:function(){return Ze},ArgMax:function(){return Qe},ArgMin:function(){return et},Asin:function(){return tt},Asinh:function(){return nt},Atan:function(){return rt},Atan2:function(){return at},Atanh:function(){return st},AvgPool:function(){return it},AvgPool3D:function(){return ut},AvgPool3DGrad:function(){return lt},AvgPoolGrad:function(){return ot},BatchMatMul:function(){return ct},BatchToSpaceND:function(){return ht},Bincount:function(){return pt},BroadcastTo:function(){return dt},Callback:function(){return bk},CallbackList:function(){return uy},Cast:function(){return ft},Ceil:function(){return mt},ClipByValue:function(){return gt},Complex:function(){return yt},ComplexAbs:function(){return bt},Concat:function(){return xt},Conv2D:function(){return wt},Conv2DBackpropFilter:function(){return vt},Conv2DBackpropInput:function(){return kt},Conv3D:function(){return It},Conv3DBackpropFilterV2:function(){return Nt},Conv3DBackpropInputV2:function(){return St},Cos:function(){return Ct},Cosh:function(){return Et},CropAndResize:function(){return $t},Cumsum:function(){return Tt},CustomCallback:function(){return hy},DataStorage:function(){return U},DenseBincount:function(){return At},DepthToSpace:function(){return Rt},DepthwiseConv2dNative:function(){return _t},DepthwiseConv2dNativeBackpropFilter:function(){return Ft},DepthwiseConv2dNativeBackpropInput:function(){return Dt},Diag:function(){return Ot},Dilation2D:function(){return Mt},Dilation2DBackpropFilter:function(){return zt},Dilation2DBackpropInput:function(){return Lt},ENV:function(){return Ue},EarlyStopping:function(){return vk},Elu:function(){return Pt},EluGrad:function(){return Vt},Environment:function(){return Pe},Equal:function(){return Ut},Erf:function(){return Wt},Exp:function(){return Gt},ExpandDims:function(){return jt},Expm1:function(){return Ht},FFT:function(){return qt},Fill:function(){return Kt},FlipLeftRight:function(){return Xt},Floor:function(){return Yt},FloorDiv:function(){return Jt},FromPixels:function(){return Lr},FusedBatchNorm:function(){return Zt},FusedConv2D:function(){return Pr},FusedDepthwiseConv2D:function(){return Vr},GatherNd:function(){return en},GatherV2:function(){return Qt},GraphModel:function(){return FI},Greater:function(){return tn},GreaterEqual:function(){return nn},History:function(){return cy},IFFT:function(){return sn},Identity:function(){return rn},Imag:function(){return an},InputSpec:function(){return Xg},IsFinite:function(){return on},IsInf:function(){return un},IsNan:function(){return ln},KernelBackend:function(){return G},LRN:function(){return wn},LRNGrad:function(){return vn},LayerVariable:function(){return Hg},LayersModel:function(){return Nb},LeakyRelu:function(){return cn},Less:function(){return hn},LessEqual:function(){return pn},LinSpace:function(){return dn},Log:function(){return fn},Log1p:function(){return mn},LogSoftmax:function(){return xn},LogicalAnd:function(){return gn},LogicalNot:function(){return yn},LogicalOr:function(){return bn},Max:function(){return kn},MaxPool:function(){return Nn},MaxPool3D:function(){return Cn},MaxPool3DGrad:function(){return En},MaxPoolGrad:function(){return Sn},MaxPoolWithArgmax:function(){return Tn},Maximum:function(){return In},Mean:function(){return $n},Min:function(){return An},Minimum:function(){return Rn},MirrorPad:function(){return _n},Mod:function(){return Fn},MomentumOptimizer:function(){return Zo},Multinomial:function(){return Dn},Multiply:function(){return On},Neg:function(){return Mn},NonMaxSuppressionV3:function(){return zn},NonMaxSuppressionV4:function(){return Bn},NonMaxSuppressionV5:function(){return Pn},NotEqual:function(){return Ln},OP_SCOPE_SUFFIX:function(){return qs},OneHot:function(){return Wn},OnesLike:function(){return Vn},Optimizer:function(){return zo},Pack:function(){return Un},PadV2:function(){return Gn},Pool:function(){return jn},Pow:function(){return Hn},Prelu:function(){return qn},Prod:function(){return Kn},RMSPropOptimizer:function(){return Qo},RNN:function(){return Rx},Range:function(){return Xn},Rank:function(){return ws},Real:function(){return Yn},RealDiv:function(){return Bt},Reciprocal:function(){return Jn},Reduction:function(){return wp},Relu:function(){return Zn},Relu6:function(){return sr},Reshape:function(){return Qn},ResizeBilinear:function(){return nr},ResizeBilinearGrad:function(){return rr},ResizeNearestNeighbor:function(){return er},ResizeNearestNeighborGrad:function(){return tr},Reverse:function(){return ar},RotateWithOffset:function(){return zr},Round:function(){return ir},Rsqrt:function(){return or},SGDOptimizer:function(){return Jo},ScatterNd:function(){return ur},Select:function(){return lr},Selu:function(){return cr},Sequential:function(){return Tb},Sigmoid:function(){return mr},Sign:function(){return fr},Sin:function(){return pr},Sinh:function(){return dr},Slice:function(){return hr},Softmax:function(){return vr},Softplus:function(){return gr},SpaceToBatchND:function(){return xr},SparseToDense:function(){return Sr},SplitV:function(){return wr},Sqrt:function(){return yr},Square:function(){return Ir},SquaredDifference:function(){return kr},Step:function(){return Mr},StridedSlice:function(){return Cr},Sub:function(){return Nr},Sum:function(){return br},SymbolicTensor:function(){return Yg},Tan:function(){return Er},Tanh:function(){return Tr},Tensor:function(){return ys},TensorBuffer:function(){return ds},Tile:function(){return $r},TopK:function(){return Ar},Transpose:function(){return Rr},Unique:function(){return _r},Unpack:function(){return Fr},UnsortedSegmentSum:function(){return Dr},Variable:function(){return xs},ZerosLike:function(){return Or},_FusedMatMul:function(){return Br},abs:function(){return jo},acos:function(){return eu},acosh:function(){return tu},add:function(){return Io},addN:function(){return nu},all:function(){return ru},any:function(){return su},argMax:function(){return au},argMin:function(){return iu},asin:function(){return ou},asinh:function(){return uu},atan:function(){return lu},atan2:function(){return cu},atanh:function(){return hu},avgPool:function(){return Cu},avgPool3d:function(){return Eu},backend:function(){return vo},backend_util:function(){return g},basicLSTMCell:function(){return _u},batchNorm:function(){return Du},batchNorm2d:function(){return Ou},batchNorm3d:function(){return Mu},batchNorm4d:function(){return Lu},batchToSpaceND:function(){return Fu},bincount:function(){return zu},booleanMaskAsync:function(){return Nh},broadcastTo:function(){return Bu},browser:function(){return u},buffer:function(){return ja},callbacks:function(){return kk},cast:function(){return Ha},ceil:function(){return Pu},clipByValue:function(){return Vu},clone:function(){return qa},complex:function(){return Xs},concat:function(){return Tu},concat1d:function(){return Wu},concat2d:function(){return Uu},concat3d:function(){return Gu},concat4d:function(){return ju},constraints:function(){return b},conv1d:function(){return qu},conv2d:function(){return Hu},conv2dTranspose:function(){return Xu},conv3d:function(){return Yu},conv3dTranspose:function(){return Zu},copyRegisteredKernels:function(){return Jr},cos:function(){return Qu},cosh:function(){return el},cosineWindow:function(){return Fh},cumsum:function(){return tl},customGrad:function(){return Oo},data:function(){return V},denseBincount:function(){return nl},deprecationWarn:function(){return so},depthToSpace:function(){return rl},depthwiseConv2d:function(){return sl},deregisterOp:function(){return Tk},device_util:function(){return a},diag:function(){return al},dilation2d:function(){return il},disableDeprecationWarnings:function(){return ro},dispose:function(){return co},disposeVariables:function(){return ao},div:function(){return So},divNoNan:function(){return ll},dot:function(){return cl},dropout:function(){return Rh},elu:function(){return hl},enableDebugMode:function(){return no},enableProdMode:function(){return to},enclosingPowerOfTwo:function(){return _h},engine:function(){return io},env:function(){return Ve},equal:function(){return ol},erf:function(){return pl},exp:function(){return dl},expandDims:function(){return fl},expm1:function(){return ml},eye:function(){return yl},fft:function(){return eh},fill:function(){return Po},findBackend:function(){return bo},findBackendFactory:function(){return xo},floor:function(){return bl},floorDiv:function(){return No},fused:function(){return f},gather:function(){return xl},gatherND:function(){return Ah},gather_util:function(){return l},getBackend:function(){return go},getGradient:function(){return jr},getKernel:function(){return Gr},getKernelsForBackend:function(){return Hr},grad:function(){return Ao},grads:function(){return Ro},greater:function(){return wl},greaterEqual:function(){return vl},ifft:function(){return th},imag:function(){return kl},image:function(){return _p},inTopKAsync:function(){return Dh},initializers:function(){return x},input:function(){return _b},io:function(){return i},irfft:function(){return nh},isFinite:function(){return Il},isInf:function(){return Nl},isNaN:function(){return Sl},keep:function(){return ho},kernel_impls:function(){return y},layers:function(){return w},leakyRelu:function(){return Cl},less:function(){return El},lessEqual:function(){return Tl},linalg:function(){return Fp},linspace:function(){return $l},loadGraphModel:function(){return DI},loadLayersModel:function(){return Rb},localResponseNormalization:function(){return Al},log:function(){return Rl},log1p:function(){return _l},logSigmoid:function(){return Ol},logSoftmax:function(){return zl},logSumExp:function(){return ql},logicalAnd:function(){return Kl},logicalNot:function(){return Xl},logicalOr:function(){return Yl},logicalXor:function(){return Jl},losses:function(){return Dp},matMul:function(){return pi},math:function(){return o},max:function(){return Ml},maxPool:function(){return Zl},maxPool3d:function(){return Ql},maxPoolWithArgmax:function(){return ec},maximum:function(){return Xo},mean:function(){return tc},memory:function(){return oo},metrics:function(){return v},min:function(){return nc},minimum:function(){return rc},mirrorPad:function(){return sc},mod:function(){return ac},model:function(){return $b},models:function(){return k},moments:function(){return ic},movingAverage:function(){return Eh},mul:function(){return Co},multiRNNCell:function(){return oc},multinomial:function(){return uc},neg:function(){return Fl},nextFrame:function(){return zp},norm:function(){return Ch},notEqual:function(){return lc},oneHot:function(){return di},ones:function(){return hc},onesLike:function(){return pc},op:function(){return Ks},outerProduct:function(){return dc},pad:function(){return fc},pad1d:function(){return mc},pad2d:function(){return gc},pad3d:function(){return yc},pad4d:function(){return bc},pool:function(){return wc},pow:function(){return Wo},prelu:function(){return vc},print:function(){return Ka},prod:function(){return kc},profile:function(){return uo},rand:function(){return Ic},randomGamma:function(){return Tc},randomNormal:function(){return $c},randomUniform:function(){return Ac},range:function(){return Rc},ready:function(){return mo},real:function(){return _c},reciprocal:function(){return Fc},registerBackend:function(){return wo},registerCallbackConstructor:function(){return Fb},registerGradient:function(){return Kr},registerKernel:function(){return qr},registerOp:function(){return Ck},regularizers:function(){return I},relu:function(){return Dc},relu6:function(){return Oc},removeBackend:function(){return yo},reshape:function(){return Su},reverse:function(){return Mc},reverse1d:function(){return Lc},reverse2d:function(){return zc},reverse3d:function(){return Bc},reverse4d:function(){return Pc},rfft:function(){return sh},round:function(){return Vc},rsqrt:function(){return Wc},scalar:function(){return Lo},scatterND:function(){return Th},scatter_util:function(){return c},selu:function(){return Uc},separableConv2d:function(){return Gc},sequential:function(){return Ab},serialization:function(){return p},setBackend:function(){return fo},setPlatform:function(){return ko},setdiff1dAsync:function(){return jc},sigmoid:function(){return $u},sign:function(){return Hc},signal:function(){return Rp},sin:function(){return qc},sinh:function(){return Kc},slice:function(){return Au},slice1d:function(){return Xc},slice2d:function(){return Yc},slice3d:function(){return Jc},slice4d:function(){return Zc},slice_util:function(){return h},softmax:function(){return Qc},softplus:function(){return Dl},spaceToBatchND:function(){return xc},sparseToDense:function(){return $h},spectral:function(){return Ap},split:function(){return rh},sqrt:function(){return Eo},square:function(){return To},squaredDifference:function(){return ah},squeeze:function(){return ih},stack:function(){return oh},step:function(){return uh},stridedSlice:function(){return lh},sub:function(){return Uo},sum:function(){return Ll},sumOutType:function(){return Es},tan:function(){return ch},tanh:function(){return Ru},tensor:function(){return Js},tensor1d:function(){return hh},tensor2d:function(){return ph},tensor3d:function(){return gi},tensor4d:function(){return dh},tensor5d:function(){return fh},tensor6d:function(){return mh},tensor_util:function(){return s},test_util:function(){return d},tidy:function(){return lo},tile:function(){return gl},time:function(){return po},topk:function(){return gh},train:function(){return Mp},transpose:function(){return fi},truncatedNormal:function(){return yh},unique:function(){return bh},unregisterGradient:function(){return Yr},unregisterKernel:function(){return Xr},unsortedSegmentSum:function(){return xh},unstack:function(){return wh},upcastType:function(){return Cs},util:function(){return r},valueAndGrad:function(){return _o},valueAndGrads:function(){return Fo},variable:function(){return vh},variableGrads:function(){return Do},version:function(){return Pz},version_converter:function(){return OI},version_core:function(){return eo},version_layers:function(){return Yy},where:function(){return ul},whereAsync:function(){return Ih},zeros:function(){return cc},zerosLike:function(){return $o}});var r={};n.r(r),n.d(r,{arraysEqual:function(){return ae},assert:function(){return Q},assertNonNegativeIntegerDimensions:function(){return Oe},assertNonNull:function(){return te},assertShapesMatch:function(){return ee},bytesFromStringArray:function(){return ke},bytesPerElement:function(){return ve},checkConversionForErrors:function(){return ye},clamp:function(){return K},computeStrides:function(){return $e},createScalarValue:function(){return os},createShuffledIndices:function(){return le},decodeString:function(){return ps},distSquared:function(){return Z},encodeString:function(){return hs},fetch:function(){return cs},flatten:function(){return ne},getArrayFromDType:function(){return ge},getTypedArrayFromDType:function(){return me},hasEncodingLoss:function(){return xe},indexToLoc:function(){return Le},inferDtype:function(){return Ce},inferFromImplicitShape:function(){return pe},isBoolean:function(){return Ne},isFunction:function(){return Ee},isInt:function(){return ie},isNumber:function(){return Se},isPromise:function(){return ze},isScalarShape:function(){return se},isString:function(){return Ie},isTypedArray:function(){return we},isValidDtype:function(){return be},locToIndex:function(){return Me},makeOnesTypedArray:function(){return _e},makeZerosNestedTypedArray:function(){return De},makeZerosTypedArray:function(){return Fe},nearestDivisor:function(){return Te},nearestLargerEven:function(){return X},now:function(){return ls},parseAxisParam:function(){return de},randUniform:function(){return J},repeatedTry:function(){return he},rightPad:function(){return ce},shuffle:function(){return H},shuffleCombo:function(){return q},sizeFromShape:function(){return re},sizeToSquarishShape:function(){return ue},squeezeShape:function(){return fe},sum:function(){return Y},tanh:function(){return oe},toNestedArray:function(){return Re},toTypedArray:function(){return us}});var s={};n.r(s),n.d(s,{assertTypesMatch:function(){return $s},getTensorsInContainer:function(){return Rs},isTensorInList:function(){return As},makeTypesMatch:function(){return Ts}});var a={};n.r(a),n.d(a,{isBrowser:function(){return Ps},isMobile:function(){return Bs}});var i={};n.r(i),n.d(i,{browserFiles:function(){return Za},browserHTTPRequest:function(){return oi},concatenateArrayBuffers:function(){return sa},copyModel:function(){return Ba},decodeWeights:function(){return ea},encodeWeights:function(){return Qs},fromMemory:function(){return ci},getLoadHandlers:function(){return pa},getModelArtifactsInfoForJSON:function(){return ia},getSaveHandlers:function(){return ha},http:function(){return ii},isHTTPScheme:function(){return si},listModels:function(){return La},loadWeights:function(){return ti},moveModel:function(){return Pa},registerLoadRouter:function(){return ca},registerSaveRouter:function(){return la},removeModel:function(){return za},weightsLoaderFactory:function(){return ni},withSaveHandler:function(){return hi}});var o={};n.r(o),n.d(o,{confusionMatrix:function(){return mi}});var u={};n.r(u),n.d(u,{fromPixels:function(){return xi},toPixels:function(){return bi}});var l={};n.r(l),n.d(l,{prepareAndValidate:function(){return wi}});var c={};n.r(c),n.d(c,{calculateShapes:function(){return Ii},validateInput:function(){return ki},validateUpdateShape:function(){return vi}});var h={};n.r(h),n.d(h,{assertParamsValid:function(){return Ni},computeFlatOffset:function(){return Li},computeOutShape:function(){return Ci},getNormalizedAxes:function(){return Ai},isSliceContinous:function(){return Mi},maskToAxes:function(){return Si},parseSliceParams:function(){return zi},sliceInfo:function(){return Bi},startForAxis:function(){return Di},startIndicesWithElidedDims:function(){return Ri},stopForAxis:function(){return Oi},stopIndicesWithElidedDims:function(){return _i},stridesForAxis:function(){return Fi},stridesWithElidedDims:function(){return Ei}});var p={};n.r(p),n.d(p,{Serializable:function(){return Pi},SerializationMap:function(){return Vi},registerClass:function(){return Wi}});var d={};n.r(d),n.d(d,{TEST_EPSILON_FLOAT16:function(){return Ui},encodeStrings:function(){return Qi},expectArrayBuffersEqual:function(){return Zi},expectArraysClose:function(){return Gi},expectArraysEqual:function(){return Ki},expectNumbersClose:function(){return Xi},expectPromiseToFail:function(){return qi},expectValuesInRange:function(){return Ji},testEpsilon:function(){return ji}});var f={};n.r(f),n.d(f,{conv2d:function(){return Ph},depthwiseConv2d:function(){return Uh},matMul:function(){return Gh}});var m={};n.r(m),n.d(m,{collectGatherOpShapeInfo:function(){return gd},computeOutShape:function(){return md},segOpComputeOptimalWindowSize:function(){return fd}});var g={};n.r(g),n.d(g,{ERF_A1:function(){return Zp},ERF_A2:function(){return Qp},ERF_A3:function(){return ed},ERF_A4:function(){return td},ERF_A5:function(){return nd},ERF_P:function(){return Jp},PARALLELIZE_THRESHOLD:function(){return Vp},SELU_SCALE:function(){return Yp},SELU_SCALEALPHA:function(){return Xp},applyActivation:function(){return zh},assertAndGetBroadcastShape:function(){return Ko},assertAxesAreInnerMostDims:function(){return Ul},assertParamsConsistent:function(){return Bp},assignToTypedArray:function(){return cd},axesAreInnerMostDims:function(){return Bl},calculateShapes:function(){return Ii},combineLocations:function(){return Pl},complexWithEvenIndex:function(){return od},complexWithOddIndex:function(){return ud},computeConv2DInfo:function(){return mu},computeConv3DInfo:function(){return gu},computeDefaultPad:function(){return yu},computeDilation2DInfo:function(){return pu},computeOptimalWindowSize:function(){return Wp},computeOutAndReduceShapes:function(){return Vl},computeOutShape:function(){return Pp},computePool2DInfo:function(){return du},computePool3DInfo:function(){return fu},convertConv2DDataFormat:function(){return Nu},eitherStridesOrDilationsAreOne:function(){return Iu},expandShapeToKeepDim:function(){return Wl},exponent:function(){return pd},exponents:function(){return hd},fromStringArrayToUint8:function(){return bd},fromUint8ToStringArray:function(){return yd},getAxesPermutation:function(){return Gl},getBroadcastDims:function(){return Ho},getComplexWithIndex:function(){return ld},getFusedBiasGradient:function(){return Lh},getFusedDyActivation:function(){return Mh},getImageCenter:function(){return Up},getInnerMostAxes:function(){return Hl},getPermuted:function(){return jp},getReductionAxes:function(){return qo},getReshaped:function(){return Gp},getReshapedPermuted:function(){return Hp},getSliceBeginCoords:function(){return qp},getSliceSize:function(){return Kp},getUndoAxesPermutation:function(){return jl},log:function(){return sd},mergeRealAndImagArrays:function(){return ad},prepareAndValidate:function(){return wi},prepareSplitSize:function(){return dd},segment_util:function(){return m},shouldFuse:function(){return Bh},slice_util:function(){return h},splitRealAndImagArrays:function(){return id},tupleValuesAreOne:function(){return ku},upcastType:function(){return Cs},validateInput:function(){return ki},validateUpdateShape:function(){return vi},warn:function(){return rd}});var y={};n.r(y),n.d(y,{nonMaxSuppressionV3Impl:function(){return np},nonMaxSuppressionV4Impl:function(){return rp},nonMaxSuppressionV5Impl:function(){return sp},whereImpl:function(){return kh}});var b={};n.r(b),n.d(b,{maxNorm:function(){return dm},minMaxNorm:function(){return gm},nonNeg:function(){return mm},unitNorm:function(){return fm}});var x={};n.r(x),n.d(x,{constant:function(){return Ig},glorotNormal:function(){return Ag},glorotUniform:function(){return $g},heNormal:function(){return Rg},heUniform:function(){return _g},identity:function(){return Eg},leCunNormal:function(){return Fg},leCunUniform:function(){return Dg},ones:function(){return kg},orthogonal:function(){return Og},randomNormal:function(){return Sg},randomUniform:function(){return Ng},truncatedNormal:function(){return Cg},varianceScaling:function(){return Tg},zeros:function(){return vg}});var w={};n.r(w),n.d(w,{Layer:function(){return ey},RNN:function(){return Rx},RNNCell:function(){return _x},activation:function(){return Qw},add:function(){return uv},alphaDropout:function(){return Zv},average:function(){return lv},averagePooling1d:function(){return bv},averagePooling2d:function(){return vv},averagePooling3d:function(){return Nv},avgPool1d:function(){return xv},avgPool2d:function(){return kv},avgPool3d:function(){return Sv},avgPooling1d:function(){return wv},avgPooling2d:function(){return Iv},avgPooling3d:function(){return Cv},batchNormalization:function(){return mv},bidirectional:function(){return Gv},concatenate:function(){return cv},conv1d:function(){return jw},conv2d:function(){return Hw},conv2dTranspose:function(){return qw},conv3d:function(){return Kw},convLstm2d:function(){return Pv},convLstm2dCell:function(){return Vv},cropping2D:function(){return Yw},dense:function(){return ev},depthwiseConv2d:function(){return Zw},dot:function(){return fv},dropout:function(){return tv},elu:function(){return Bw},embedding:function(){return ov},flatten:function(){return rv},gaussianDropout:function(){return Jv},gaussianNoise:function(){return Yv},globalAveragePooling1d:function(){return Ev},globalAveragePooling2d:function(){return Tv},globalMaxPool1d:function(){return Hv},globalMaxPool2d:function(){return qv},globalMaxPooling1d:function(){return $v},globalMaxPooling2d:function(){return Av},gru:function(){return Dv},gruCell:function(){return Ov},input:function(){return _b},inputLayer:function(){return zw},layerNormalization:function(){return gv},leakyReLU:function(){return Vw},lstm:function(){return Mv},lstmCell:function(){return Lv},masking:function(){return Qv},maxPool1d:function(){return Kv},maxPool2d:function(){return Xv},maxPooling1d:function(){return Rv},maxPooling2d:function(){return _v},maxPooling3d:function(){return Fv},maximum:function(){return hv},minimum:function(){return pv},multiply:function(){return dv},permute:function(){return iv},prelu:function(){return Ww},reLU:function(){return Pw},repeatVector:function(){return sv},reshape:function(){return av},rnn:function(){return Wv},separableConv2d:function(){return Xw},simpleRNN:function(){return zv},simpleRNNCell:function(){return Bv},softmax:function(){return Uw},spatialDropout1d:function(){return nv},stackedRNNCells:function(){return Uv},thresholdedReLU:function(){return Gw},timeDistributed:function(){return jv},upSampling2d:function(){return Jw},zeroPadding2d:function(){return yv}});var v={};n.r(v),n.d(v,{MAPE:function(){return ck},MSE:function(){return dk},binaryAccuracy:function(){return ek},binaryCrossentropy:function(){return tk},categoricalAccuracy:function(){return rk},categoricalCrossentropy:function(){return sk},cosineProximity:function(){return ok},mape:function(){return hk},meanAbsoluteError:function(){return uk},meanAbsolutePercentageError:function(){return lk},meanSquaredError:function(){return pk},mse:function(){return fk},precision:function(){return ak},recall:function(){return ik},sparseCategoricalAccuracy:function(){return nk}});var k={};n.r(k),n.d(k,{modelFromJSON:function(){return Cb}});var I={};n.r(I),n.d(I,{l1:function(){return gk},l1l2:function(){return mk},l2:function(){return yk}});var N={};n.r(N),n.d(N,{json:function(){return Mk}});var S={};n.r(S),n.d(S,{json:function(){return Lk}});var C={};n.r(C),n.d(C,{json:function(){return zk}});var E={};n.r(E),n.d(E,{json:function(){return Bk}});var T={};n.r(T),n.d(T,{json:function(){return Pk}});var $={};n.r($),n.d($,{json:function(){return Vk}});var A={};n.r(A),n.d(A,{json:function(){return Wk}});var R={};n.r(R),n.d(R,{json:function(){return Uk}});var _={};n.r(_),n.d(_,{json:function(){return Gk}});var F={};n.r(F),n.d(F,{json:function(){return jk}});var D={};n.r(D),n.d(D,{json:function(){return Hk}});var O={};n.r(O),n.d(O,{json:function(){return qk}});var M={};n.r(M),n.d(M,{json:function(){return Kk}});var L={};n.r(L),n.d(L,{json:function(){return Xk}});var z={};n.r(z),n.d(z,{json:function(){return Yk}});var B={};n.r(B),n.d(B,{json:function(){return Jk}});var P={};n.r(P),n.d(P,{json:function(){return Zk}});var V={};n.r(V),n.d(V,{CSVDataset:function(){return SN},Dataset:function(){return dN},FileDataSource:function(){return zN},TextLineDataset:function(){return bN},URLDataSource:function(){return BN},array:function(){return mN},csv:function(){return PN},func:function(){return VN},generator:function(){return WN},microphone:function(){return GN},version_data:function(){return jN},webcam:function(){return UN},zip:function(){return gN}});var W={};n.r(W),n.d(W,{addImpl:function(){return vS},bincountImpl:function(){return dC},bincountReduceImpl:function(){return fC},ceilImpl:function(){return yC},concatImpl:function(){return IC},expImpl:function(){return lE},expm1Impl:function(){return fE},floorImpl:function(){return OE},gatherV2Impl:function(){return GE},greaterImpl:function(){return HE},lessImpl:function(){return aT},linSpaceImpl:function(){return hT},logImpl:function(){return dT},maxImpl:function(){return TT},maximumImpl:function(){return RT},minimumImpl:function(){return UT},multiplyImpl:function(){return yE},negImpl:function(){return QT},notEqualImpl:function(){return o$},prodImpl:function(){return w$},rangeImpl:function(){return k$},rsqrtImpl:function(){return D$},simpleAbsImpl:function(){return AS},sliceImpl:function(){return lC},squaredDifferenceImpl:function(){return oA},stridedSliceImpl:function(){return pA},subImpl:function(){return NE},tileImpl:function(){return yA},topKImpl:function(){return bA},transposeImpl:function(){return LS},uniqueImpl:function(){return xA}});class U{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class G{decComplexRef(e){}time(e){return j("time")}read(e){return j("read")}readSync(e){return j("readSync")}numDataIds(){return j("numDataIds")}disposeData(e){return j("disposeData")}write(e,t,n){return j("write")}move(e,t,n,r){return j("move")}memory(){return j("memory")}floatPrecision(){return j("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return j("dispose")}}function j(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function H(e){let t=e.length,n=0,r=0;for(;t>0;)r=Math.random()*t|0,t--,n=e[t],e[t]=e[r],e[r]=n}function q(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n,r,s=e.length,a=0;for(;s>0;)a=Math.random()*s|0,s--,n=e[s],r=t[s],e[s]=e[a],t[s]=t[a],e[a]=n,t[a]=r}function K(e,t,n){return Math.max(e,Math.min(t,n))}function X(e){return e%2==0?e:e+1}function Y(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function J(e,t){const n=Math.random();return t*n+(1-n)*e}function Z(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Q(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function ee(e,t,n=""){Q(ae(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function te(e){Q(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ne(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||we(e)&&!n)for(let r=0;r<e.length;++r)ne(e[r],t,n);else t.push(e);return t}function re(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function se(e){return 0===e.length}function ae(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ie(e){return e%1==0}function oe(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function ue(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function le(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return H(t),t}function ce(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function he(e,t=(e=>0),n){return new Promise(((r,s)=>{let a=0;const i=()=>{if(e())return void r();a++;const o=t(a);null!=n&&a>=n?s():setTimeout(i,o)};i()}))}function pe(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function de(e,t){const n=t.length;return Q((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Q(e.every((e=>ie(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function fe(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:de(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function me(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function ge(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function ye(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function be(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function xe(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function we(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function ve(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function ke(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ie(e){return"string"==typeof e||e instanceof String}function Ne(e){return"boolean"==typeof e}function Se(e){return"number"==typeof e}function Ce(e){return Array.isArray(e)?Ce(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":Se(e)?"float32":Ie(e)?"string":Ne(e)?"bool":"float32"}function Ee(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Te(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function $e(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Ae(e,t,n){const r=new Array;if(1===t.length){const s=t[0];for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],a=t.slice(1),i=a.reduce(((e,t)=>e*t));for(let t=0;t<s;t++)r[t]=Ae(e+t*i,a,n)}return r}function Re(e,t){if(0===e.length)return t[0];const n=e.reduce(((e,t)=>e*t));if(0===n)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}.`);return Ae(0,e,t)}function _e(e,t){const n=Fe(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function Fe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function De(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Re(e,new Float32Array(n));if("int32"===t)return Re(e,new Int32Array(n));if("bool"===t)return Re(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Oe(e){e.forEach((t=>{Q(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Me(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function Le(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function ze(e){return e&&e.then&&"function"==typeof e.then}const Be="tfjsflags";class Pe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ze(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=function(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}(this.global.location.search);if(Be in e){e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}}function Ve(){return Ue}let We,Ue=null;function Ge(){if(null==We){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}We=e}return We}function je(e,t){const n=function(){const e=Ge();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const He="Abs",qe="Acos",Ke="Acosh",Xe="Add",Ye="AddN",Je="All",Ze="Any",Qe="ArgMax",et="ArgMin",tt="Asin",nt="Asinh",rt="Atan",st="Atanh",at="Atan2",it="AvgPool",ot="AvgPoolGrad",ut="AvgPool3D",lt="AvgPool3DGrad",ct="BatchMatMul",ht="BatchToSpaceND",pt="Bincount",dt="BroadcastTo",ft="Cast",mt="Ceil",gt="ClipByValue",yt="Complex",bt="ComplexAbs",xt="Concat",wt="Conv2D",vt="Conv2DBackpropFilter",kt="Conv2DBackpropInput",It="Conv3D",Nt="Conv3DBackpropFilterV2",St="Conv3DBackpropInputV2",Ct="Cos",Et="Cosh",Tt="Cumsum",$t="CropAndResize",At="DenseBincount",Rt="DepthToSpace",_t="DepthwiseConv2dNative",Ft="DepthwiseConv2dNativeBackpropFilter",Dt="DepthwiseConv2dNativeBackpropInput",Ot="Diag",Mt="Dilation2D",Lt="Dilation2DBackpropInput",zt="Dilation2DBackpropFilter",Bt="RealDiv",Pt="Elu",Vt="EluGrad",Wt="Erf",Ut="Equal",Gt="Exp",jt="ExpandDims",Ht="Expm1",qt="FFT",Kt="Fill",Xt="FlipLeftRight",Yt="Floor",Jt="FloorDiv",Zt="FusedBatchNorm",Qt="GatherV2",en="GatherNd",tn="Greater",nn="GreaterEqual",rn="Identity",sn="IFFT",an="Imag",on="IsFinite",un="IsInf",ln="IsNan",cn="LeakyRelu",hn="Less",pn="LessEqual",dn="LinSpace",fn="Log",mn="Log1p",gn="LogicalAnd",yn="LogicalNot",bn="LogicalOr",xn="LogSoftmax",wn="LRN",vn="LRNGrad",kn="Max",In="Maximum",Nn="MaxPool",Sn="MaxPoolGrad",Cn="MaxPool3D",En="MaxPool3DGrad",Tn="MaxPoolWithArgmax",$n="Mean",An="Min",Rn="Minimum",_n="MirrorPad",Fn="Mod",Dn="Multinomial",On="Multiply",Mn="Neg",Ln="NotEqual",zn="NonMaxSuppressionV3",Bn="NonMaxSuppressionV4",Pn="NonMaxSuppressionV5",Vn="OnesLike",Wn="OneHot",Un="Pack",Gn="PadV2",jn="Pool",Hn="Pow",qn="Prelu",Kn="Prod",Xn="Range",Yn="Real",Jn="Reciprocal",Zn="Relu",Qn="Reshape",er="ResizeNearestNeighbor",tr="ResizeNearestNeighborGrad",nr="ResizeBilinear",rr="ResizeBilinearGrad",sr="Relu6",ar="Reverse",ir="Round",or="Rsqrt",ur="ScatterNd",lr="Select",cr="Selu",hr="Slice",pr="Sin",dr="Sinh",fr="Sign",mr="Sigmoid",gr="Softplus",yr="Sqrt",br="Sum",xr="SpaceToBatchND",wr="SplitV",vr="Softmax",kr="SquaredDifference",Ir="Square",Nr="Sub",Sr="SparseToDense",Cr="StridedSlice",Er="Tan",Tr="Tanh",$r="Tile",Ar="TopK",Rr="Transpose",_r="Unique",Fr="Unpack",Dr="UnsortedSegmentSum",Or="ZerosLike",Mr="Step",Lr="FromPixels",zr="RotateWithOffset",Br="_FusedMatMul",Pr="FusedConv2D",Vr="FusedDepthwiseConv2D",Wr=je("kernelRegistry",(()=>new Map)),Ur=je("gradRegistry",(()=>new Map));function Gr(e,t){const n=Zr(e,t);return Wr.get(n)}function jr(e){return Ur.get(e)}function Hr(e){const t=Wr.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function qr(e){const{kernelName:t,backendName:n}=e,r=Zr(t,n);Wr.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),Wr.set(r,e)}function Kr(e){const{kernelName:t}=e;Ur.has(t)&&Ve().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),Ur.set(t,e)}function Xr(e,t){const n=Zr(e,t);if(!Wr.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Wr.delete(n)}function Yr(e){if(!Ur.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Ur.delete(e)}function Jr(e,t){Hr(e).forEach((e=>{qr(Object.assign({},e,{backendName:t}))}))}function Zr(e,t){return`${t}_${e}`}class Qr{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ts)}profileKernel(e,t,n){let r;const s=this.backendTimer.time((()=>{r=n()}));if(Ve().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{es(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function es(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class ts{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?ce(`${r}ms`,9):r.error,o=ce(e,25),u=t.rank,l=t.size,c=ce(t.shape.toString(),14);let h="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;h+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${o}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ns(e,t,n,r){const s=$e(t),a=function(e,t,n,r){const s=re(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u="complex64"===n?is(e):e;if(o>1)for(let e=0;e<s/a;e++){const t=e*a;for(let e=0;e<a;e++)i[e]=Math.max(i[e],rs(u[t+e],0,n).length)}return i}(e,t,n,s),i=t.length,o=as(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map((e=>"    "+e)).join("\n")),u.join("\n")}function rs(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Ie(e)?`'${e}'`:"bool"===n?ss(e):parseFloat(e.toFixed(7)).toString(),ce(r,t)}function ss(e){return 0===e?"false":"true"}function as(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],u=t.length;if(0===u){if("complex64"===n){return[rs(is(e)[0],0,n)]}return"bool"===n?[ss(e[0])]:[e[0].toString()]}if(1===u){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=is(r),a=is(a)),["["+r.map(((e,t)=>rs(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>rs(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?is(e):Array.from(e)).map(((e,t)=>rs(e,s[t],n))).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*i,p=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;p.push(...as(e.slice(r,a),l,n,c,s,!1))}p.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;p.push(...as(e.slice(r,a),l,n,c,s,t===o-1))}}else for(let t=0;t<o;t++){const r=t*h,a=r+h;p.push(...as(e.slice(r,a),l,n,c,s,t===o-1))}const d=2===u?",":"";p[0]="["+p[0]+d;for(let e=1;e<p.length-1;e++)p[e]=" "+p[e]+d;let f=",\n";for(let e=2;e<u;e++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function is(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}function os(e,t){return"string"===t?hs(e):us([e],t)}function us(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ne(e)),Ve().getBool("DEBUG")&&ye(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function ls(){return Ve().platform.now()}function cs(e,t){return Ve().platform.fetch(e,t)}function hs(e,t="utf-8"){return t=t||"utf-8",Ve().platform.encode(e,t)}function ps(e,t="utf-8"){return t=t||"utf-8",Ve().platform.decode(e,t)}class ds{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=re(e),null!=n){const e=n.length;Q(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ge(t,this.size),this.strides=$e(e)}set(e,...t){0===t.length&&(t=[0]),Q(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return fs().makeTensor(this.values,this.shape,this.dtype)}}let fs=null,ms=null,gs=null;class ys{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=re(e),this.strides=$e(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ms.buffer(this.shape,this.dtype,e)}bufferSync(){return ms.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Re(this.shape,e)}arraySync(){return Re(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const e=fs().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>ps(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=fs().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>ps(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await fs().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(fs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ms.print(this,e)}clone(){return this.throwIfDisposed(),ms.clone(this)}toString(e=!1){return ns(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ms.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),fs().makeVariable(this,e,t,n)}}function bs(){return je("Tensor",(()=>ys))}Object.defineProperty(ys,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),bs();class xs extends ys{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ae(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);fs().disposeTensor(this),this.dataId=e.dataId,fs().incRef(this,null)}dispose(){fs().disposeVariable(this),this.isDisposedInternal=!0}}var ws,vs,ks,Is,Ns;Object.defineProperty(xs,Symbol.hasInstance,{value:e=>e instanceof ys&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(ws||(ws={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(vs||(vs={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ks||(ks={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Is||(Is={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ns||(Ns={}));const Ss={float32:Is,int32:vs,bool:ks,complex64:Ns};function Cs(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Ss[e][t]}function Es(e){return Cs(e,"int32")}function Ts(e,t){if(e.dtype===t.dtype)return[e,t];const n=Cs(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function $s(e,t){Q(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function As(e,t){return t.some((t=>t.id===e.id))}function Rs(e){const t=[];return _s(e,t,new Set),t}function _s(e,t,n){if(null==e)return;if(e instanceof ys)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),_s(r,t,n))}}function Fs(e){return null!=e.kernelName}class Ds{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Os{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ds}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Qr(this.backendInstance),!0}setupRegisteredKernels(){Hr(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Hr(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof G||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return console.warn(`Initialization of backend ${e} failed`),console.warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t);r.disposeData(t),n.backend=e,e.move(t,s,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return Os.nextTensorId++}nextVariableId(){return Os.nextVariableId++}clone(e){const t=this.makeTensorFromDataId(e.dataId,e.shape,e.dtype),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Ls.runKernel(ft,t,n)}})),[],{}),t}runKernel(e,t,n){if(!(null!=Gr(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Fs(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Fs(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const u=Gr(t,this.backendName);Q(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map((e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)}));if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=Fs(e)?null:e.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs):t=i()})),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=jr(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Q(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Ie(e[0])&&(s=e.map((e=>hs(e))));const a=r.write(s,t,n),i=new ys(t,n,a,this.nextTensorId());if(this.incRef(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=ke(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s=new ys(t,n=n||"float32",e,this.nextTensorId());return this.incRef(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new xs(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}incRef(e,t){const n=this.state.tensorInfo.has(e.dataId)?this.state.tensorInfo.get(e.dataId).refCount:0;if(this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ve(e.dtype)),this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(e.dataId).refCount++,e instanceof xs||this.track(e)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;this.state.numTensors--,"string"===e.dtype&&this.state.numStringTensors--;const t=this.state.tensorInfo.get(e.dataId);t.refCount<=1?("complex64"!==e.dtype&&(this.state.numBytes-=t.bytes),this.state.numDataBuffers--,t.backend.disposeData(e.dataId),this.state.tensorInfo.delete(e.dataId)):(t.backend.decComplexRef(e.dataId),this.state.tensorInfo.get(e.dataId).refCount--)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=jr(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=Fe(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Rs(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(Q(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Q(s instanceof ys,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=_e(re(e),"float32");return Ls.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!ae(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),zs);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return Q(Ee(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;Q(t.every((e=>e instanceof ys)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((e,t)=>{r[t]=e}));return this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Q(n.value instanceof ys,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Q(Ee(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Q(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Q(a.every((e=>e instanceof ys)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=ls(),n=await this.backend.time(e);return n.wallMs=ls()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ds;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Ms(){const e=Ge();if(null==e._tfengine){const t=new Pe(e);e._tfengine=new Os(t)}var t;return t=e._tfengine.ENV,Ue=t,fs=()=>e._tfengine,e._tfengine}Os.nextTensorId=0,Os.nextVariableId=0;const Ls=Ms();function zs(e,t){const n={a:e,b:t};return Ls.runKernel(Xe,n)}function Bs(){if("undefined"!=typeof navigator&&null!=navigator){const e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Ps(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Vs=Ve();function Ws(e,t){let n=e;if(we(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||we(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Ve().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Us(e,r,[]),r}function Us(e,t,n){if(n=n||[],!Array.isArray(e)&&!we(e))return void Q(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Q(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Q(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)Us(e[t],r,n.concat(t))}function Gs(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function js(e,t,n,r="numeric"){if(e instanceof ys)return Gs(r,e.dtype,t,n),e;let s=Ce(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Gs(r,s,t,n),null==e||!we(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Ws(e,s);we(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?us(e,s):ne(e,[],!0);return Ls.makeTensor(i,a,s)}function Hs(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>js(e,`${t}[${s}]`,n,r)))}Vs.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Vs.registerFlag("IS_BROWSER",(()=>Ps())),Vs.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Vs.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Vs.registerFlag("PROD",(()=>!1)),Vs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Vs.getBool("DEBUG"))),Vs.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Vs.registerFlag("IS_TEST",(()=>!1)),Vs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0));const qs="__op";function Ks(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=qs;const s=(...e)=>{Ls.startScope(n);try{const t=r(...e);return ze(t)&&console.error("Cannot return a Promise inside of tidy."),Ls.endScope(t),t}catch(e){throw Ls.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Xs=Ks({complex_:function(e,t){const n=js(e,"real","complex"),r=js(t,"imag","complex");ee(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Ls.runKernel(yt,s)}});function Ys(e,t,n,r){if(null==r&&(r=Ce(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!we(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Oe(t);const e=re(t),r=re(n);Q(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==re(t.slice(e));Q(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return we(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?us(e,r):ne(e,[],!0),Ls.makeTensor(e,t,r)}function Js(e,t,n){return Ys(e,t,Ws(e,n),n)}const Zs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function Qs(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const u={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=4,r.set(n,s),s+=n.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(u.group=t),n.push(u)}return{data:ta(await Promise.all(r)),specs:n}}function ea(e,t){const n={};let r,s=0;for(const a of t){const t=a.name,i=a.dtype,o=a.shape,u=re(o);let l;if("quantization"in a){const n=a.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${a.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${a.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${a.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const o=Zs[n.dtype],c=e.slice(s,s+u*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=oa()),l=r(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=Math.round(t*n.scale+n.min)}}s+=u*o}else if("string"===i){const t=re(a.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+4))[0];s+=4;const n=new Uint8Array(e.slice(s,s+t));l.push(n),s+=t}}else{const r=Zs[i],a=e.slice(s,s+u*r);if("float32"===i)l=new Float32Array(a);else if("int32"===i)l=new Int32Array(a);else if("bool"===i)l=new Uint8Array(a);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);{l=new Float32Array(a);const e=new Float32Array(l.length/2),r=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],r[t]=l[2*t+1];const s=Js(e,o,"float32"),i=Js(r,o,"float32");n[t]=Xs(s,i),s.dispose(),i.dispose()}}s+=u*r}"complex64"!==i&&(n[t]=Js(l,o,i))}return n}function ta(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const na="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ra(e){return na?Buffer.byteLength(e):new Blob([e]).size}function sa(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function aa(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function ia(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ra(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ra(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function oa(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],o=e[n[i>>10]+(1023&i)]+t[i>>10];a[s]=o}return new Float32Array(s)}}class ua{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ua.instance&&(ua.instance=new ua),ua.instance}static registerSaveRouter(e){ua.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ua.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ua.getHandlers(e,"save")}static getLoadHandlers(e,t){return ua.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?ua.getInstance().loadRouters:ua.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const la=e=>ua.registerSaveRouter(e),ca=e=>ua.registerLoadRouter(e),ha=e=>ua.getSaveHandlers(e),pa=(e,t)=>ua.getLoadHandlers(e,t),da="tensorflowjs",fa="models_store",ma="model_info_store";function ga(){if(!Ve().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ya(e){const t=e.result;t.createObjectStore(fa,{keyPath:"modelPath"}),t.createObjectStore(ma,{keyPath:"modelPath"})}class ba{constructor(e){if(this.indexedDB=ga(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(da,1);r.onupgradeneeded=()=>ya(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(fa,"readonly"),r=t.objectStore(fa).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{const r=ia(t),a=s.transaction(ma,"readwrite");let i=a.objectStore(ma);const o=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;o.onsuccess=()=>{u=s.transaction(fa,"readwrite");const o=u.objectStore(fa).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});o.onsuccess=()=>e({modelArtifactsInfo:r}),o.onerror=e=>{i=a.objectStore(ma);const t=i.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(o.error)),t.onerror=e=>(s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}ba.URL_SCHEME="indexeddb://";const xa=e=>{return Ve().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ba.URL_SCHEME)?(t=e.slice(ba.URL_SCHEME.length),new ba(t)):null;var t};ua.registerSaveRouter(xa),ua.registerLoadRouter(xa);class wa{constructor(){this.indexedDB=ga()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(da,1);n.onupgradeneeded=()=>ya(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(ma,"readonly"),a=s.objectStore(ma).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ba.URL_SCHEME)?t.slice(ba.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(da,1);r.onupgradeneeded=()=>ya(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(ma,"readwrite"),i=a.objectStore(ma),o=i.get(e);let u;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{u=s.transaction(fa,"readwrite");const r=u.objectStore(fa).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const va="/",ka="tensorflowjs_models",Ia="info",Na="model_topology",Sa="weight_specs",Ca="weight_data",Ea="model_metadata";function Ta(e){return{info:[ka,e,Ia].join(va),topology:[ka,e,Na].join(va),weightSpecs:[ka,e,Sa].join(va),weightData:[ka,e,Ca].join(va),modelMetadata:[ka,e,Ea].join(va)}}function $a(e){const t=e.split(va);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(va)}class Aa{constructor(e){if(!Ve().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ta(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=ia(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(na)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(e){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(na){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}Aa.URL_SCHEME="localstorage://";const Ra=e=>{return Ve().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Aa.URL_SCHEME)?(t=e.slice(Aa.URL_SCHEME.length),new Aa(t)):null;var t};ua.registerSaveRouter(Ra),ua.registerLoadRouter(Ra);class _a{constructor(){Q(Ve().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Q("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=ka+va,n=va+Ia;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[$a(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=Ta(e=(t=e).startsWith(Aa.URL_SCHEME)?t.slice(Aa.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}const Fa="://";class Da{constructor(){this.managers={}}static getInstance(){return null==Da.instance&&(Da.instance=new Da),Da.instance}static registerManager(e,t){Q(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Fa)&&(e=e.slice(0,e.indexOf(Fa))),Q(e.length>0,(()=>"scheme must not be an empty string."));const n=Da.getInstance();Q(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function Oa(e){if(-1===e.indexOf(Fa))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Da.getSchemes().join(",")}`);return{scheme:e.split(Fa)[0],path:e.split(Fa)[1]}}async function Ma(e,t,n=!1){Q(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=ua.getLoadHandlers(e);Q(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Q(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=ua.getSaveHandlers(t);Q(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Q(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Oa(e).scheme,u=Oa(e).path,l=o===Oa(e).scheme,c=await s.load();n&&l&&await Da.getManager(o).removeModel(u);const h=await i.save(c);return n&&!l&&await Da.getManager(o).removeModel(u),h.modelArtifactsInfo}async function La(){const e=Da.getSchemes(),t={};for(const n of e){const e=await Da.getManager(n).listModels();for(const r in e){t[n+Fa+r]=e[r]}}return t}async function za(e){const t=Oa(e);return Da.getManager(t.scheme).removeModel(t.path)}async function Ba(e,t){return Ma(e,t,!1)}async function Pa(e,t){return Ma(e,t,!0)}class Va{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(Ve().get("IS_BROWSER")){Ve().setPlatform("browser",new Va);try{Da.registerManager(Aa.URL_SCHEME,new _a)}catch(e){}try{Da.registerManager(ba.URL_SCHEME,new wa)}catch(e){}}const Wa=()=>n(352);let Ua;class Ga{constructor(){this.util=n(758),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Ve().global.fetch?Ve().global.fetch(e,t):(null==Ua&&(Ua=Wa()),Ua(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}function ja(e,t="float32",n){return t=t||"float32",Oe(e),new ds(e,t,n)}Ve().get("IS_NODE")&&Ve().setPlatform("node",new Ga);const Ha=Ks({cast_:function(e,t){const n=js(e,"x","cast");if(!be(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return Ls.runKernel(ft,r,s)}});const qa=Ks({clone_:function(e){const t={x:js(e,"x","clone","string_or_numeric")};return Ls.runKernel(rn,t)}});function Ka(e,t=!1){console.log(e.toString(t))}Ms();ms={buffer:ja,cast:Ha,clone:qa,print:Ka};function Xa(e){return new Promise((e=>setTimeout(e))).then(e)}class Ya{constructor(e){if(!Ve().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ya.URL_SCHEME)&&(e=e.slice(Ya.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(a.download=this.modelTopologyFileName,a.href=s,await Xa((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Xa((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:ia(e)}}}}Ya.URL_SCHEME="downloads://";class Ja{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.files=e}async load(){const e=this.files[0],t=this.files.slice(1);return new Promise(((n,r)=>{const s=new FileReader;s.onload=s=>{const a=JSON.parse(s.target.result),i=a.modelTopology;if(null==i)return void r(new Error(`modelTopology field is missing from file ${e.name}`));0===t.length&&n({modelTopology:i});const o=a.weightsManifest;if(null==o)return void r(new Error(`weightManifest field is missing from file ${e.name}`));let u;try{u=this.checkManifestAndWeightFiles(o,t)}catch(e){return void r(e)}const l=[],c=[],h=[];o.forEach((e=>{e.paths.forEach((e=>{c.push(e),h.push(null)})),l.push(...e.weights)})),o.forEach((e=>{e.paths.forEach((e=>{const t=new FileReader;t.onload=t=>{const r=t.target.result,s=c.indexOf(e);if(h[s]=r,-1===h.indexOf(null)){const e={modelTopology:i,weightSpecs:l,weightData:sa(h),format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy};null!=a.signature&&(e.signature=a.signature),null!=a.userDefinedMetadata&&(e.userDefinedMetadata=a.userDefinedMetadata),null!=a.modelInitializer&&(e.modelInitializer=a.modelInitializer),n(e)}},t.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),t.readAsArrayBuffer(u[e])}))}))},s.onerror=t=>r(`Failed to read model topology and weights manifest JSON from file '${e.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(e)}))}checkManifestAndWeightFiles(e,t){const n=[],r=t.map((e=>aa(e.name))),s={};for(const a of e)a.paths.forEach((e=>{const a=aa(e);if(-1!==n.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[e]=t[r.indexOf(a)]}));if(n.length!==t.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${t.length}).`);return s}}function Za(e){return new Ja(e)}function Qa(e,t,n,r){!function(e){Q(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Q(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Q(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Q(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function ei(e,t){null==t&&(t={});const n=null==t.fetchFunc?Ve().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Qa(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Qa(s,t.onProgress,.5,1)}async function ti(e,t="",n,r){return ni((e=>ei(e,{requestInit:r})))(e,t,n)}function ni(e){return async(t,n="",r)=>{const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const u="quantization"in e?e.quantization.dtype:e.dtype,l=Zs[u]*re(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=l}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const u=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];u.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const c=await e(l),h={};let p=0;return u.forEach((e=>{const n=t[e].paths.length;let r=0;for(let e=0;e<n;e++)r+=c[p+e].byteLength;const s=new ArrayBuffer(r),i=new Uint8Array(s);let o=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[p+e]);i.set(t,o),o+=t.byteLength}a[e].forEach((e=>{const t=ea(s.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)h[e]=t[e]})),p+=n})),h}}ua.registerSaveRouter((e=>Ve().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ya.URL_SCHEME)?function(e="model"){return new Ya(e)}(e.slice(Ya.URL_SCHEME.length)):null));class ri{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Q("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Ve().platform.fetch,Q(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Q(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:ia(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest,s=t.generatedBy,a=t.convertedBy,i=t.format,o=t.signature,u=t.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let l,c;if(null!=r){const e=await this.loadWeights(r);[l,c]=e}const h={modelTopology:n,weightSpecs:l,weightData:c,generatedBy:s,convertedBy:a,format:i};null!=o&&(h.signature=o),null!=u&&(h.userDefinedMetadata=u);const p=t.modelInitializer;return p&&(h.modelInitializer=p),h}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[];for(const t of e)a.push(...t.weights);const i=[],o=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(s+e+r);this.weightUrlConverter&&i.push(...await Promise.all(o));return[a,sa(await ei(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function si(e){return null!=e.match(ri.URL_SCHEME_REGEX)}ri.URL_SCHEME_REGEX=/^https?:\/\//;const ai=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>si(e))):si(e),n)return ii(e,t)}return null};function ii(e,t){return new ri(e,t)}function oi(e,t){return ii(e,t)}ua.registerSaveRouter(ai),ua.registerLoadRouter(ai);class ui{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class li{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function ci(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new ui(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ui({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ui({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function hi(e){return new li(e)}const pi=Ks({matMul_:function(e,t,n=!1,r=!1){let s=js(e,"a","matMul"),a=js(t,"b","matMul");[s,a]=Ts(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return Ls.runKernel(ct,i,o)}});const di=Ks({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:js(e,"indices","oneHot","int32")},a={depth:t,onValue:n,offValue:r};return Ls.runKernel(Wn,s,a)}});const fi=Ks({transpose_:function(e,t){const n=js(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),Q(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{Q(e>=0&&e<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`))})),n.rank<=1)return n.clone();const r={x:n},s={perm:t};return Ls.runKernel(Rr,r,s)}});const mi=Ks({confusionMatrix_:function(e,t,n){const r=js(e,"labels","confusionMatrix"),s=js(t,"predictions","confusionMatrix");Q(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Q(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Q(1===s.rank,(()=>`Expected the rank of predictions to be 1, but got ${s.rank}`)),Q(r.shape[0]===s.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`)),Q(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const a=di(Ha(r,"int32"),n),i=di(Ha(s,"int32"),n),o=fi(a),u=pi(o,i);return Ha(u,"int32")}});function gi(e,t,n){if(te(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ws(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ys(e,t,r,n)}let yi;async function bi(e,t){let n=js(e,"img","toPixels");if(!(e instanceof ys)){const e=n;n=Ha(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2];if(a>4||2===a)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const i=await n.data(),o="float32"===n.dtype?255:1,u=new Uint8ClampedArray(s*r*4);for(let e=0;e<r*s;++e){const t=[0,0,0,255];for(let r=0;r<a;r++){const s=i[e*a+r];if("float32"===n.dtype){if(s<0||s>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${s}.`)}else if("int32"===n.dtype&&(s<0||s>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${s}.`);1===a?(t[0]=s*o,t[1]=s*o,t[2]=s*o):t[r]=s*o}const r=4*e;u[r+0]=Math.round(t[0]),u[r+1]=Math.round(t[1]),u[r+2]=Math.round(t[2]),u[r+3]=Math.round(t[3])}if(null!=t){t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(u,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),u}const xi=Ks({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(s){const t=2;if(s&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Gr(Lr,Ls.backendName)){const n={pixels:e},r={numChannels:t};return Ls.runKernel(Lr,n,r)}const[u,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,h;if(i?c=e.getContext("2d").getImageData(0,0,u,l).data:r||n?c=e.data:(a||s||o)&&(null==yi&&(yi=document.createElement("canvas").getContext("2d")),yi.canvas.width=u,yi.canvas.height=l,yi.drawImage(e,0,0,u,l),c=yi.getImageData(0,0,u,l).data),4===t)h=new Int32Array(c);else{const e=u*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=c[4*n+e]}return gi(h,[l,u,t],"int32")}});function wi(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===re(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const o=e.shape,u=s.slice();u.pop();let l=1;for(let e=a;e<n;++e)l*=o[e],u.push(o[e]);const c=[...$e(e.shape).map((e=>e/l)),1].slice(0,a);return[u,i,l,c]}function vi(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function ki(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}vi(n,t,e)}function Ii(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let e=s;e<a;++e)i*=n[e];const o=s<1?1:s;return{sliceRank:s,numUpdates:re(t.shape)/o,sliceSize:i,strides:[...$e(n.slice(0,s)),1],outputSize:re(n)}}function Ni(e,t,n){const r=e.shape.length;Q(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Q(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Q(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function Si(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Ci(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Ei(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Ti(e,t,n){return n<=e?n:n-(t-1)}function $i(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Ai(e,t,n,r,s,a,i,o,u){const l=e.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=Ri(i,u,l,r,e),h=_i(o,u,l,s,e),p=Ei(a,u,l,e)}else for(let t=0;t<l;t++)c[t]=Di(i,r,a,e,t,u),h[t]=Oi(o,s,a,e,t,u),p[t]=Fi(a,t,u);return{begin:c,end:h,strides:p}}function Ri(e,t,n,r,s){const a=[...s],i=$i(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=Ti(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function _i(e,t,n,r,s){const a=[...s],i=$i(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=Number.MAX_SAFE_INTEGER;else{const i=Ti(t,n,s);let o=r[i];e&1<<i&&(o=Number.MAX_SAFE_INTEGER),a[s]=o}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=K(0,a[e],s[e])}return a}function Fi(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Di(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=K(0,i,u-1),i}function Oi(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=o>0?K(0,i,u):K(-1,i,u-1),i}function Mi(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Li(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function zi(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Q(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Q(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Bi(e,t,n,r,s,a,i,o,u){let l=t.slice(),c=n.slice(),h=r;null==r&&(h=new Array(l.length));const p=Si(i);if(p.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const d=e.length-l.length,f=Si(o),m=e.slice();f.forEach((e=>{l[e]=0,c[e]=1,m.splice(e,0,1)}));const{begin:g,end:y,strides:b}=Ai(m,p,d,l,c,h,s,a,i);l=g,c=y,h=b;const x=Si(u);x.forEach((e=>{c[e]=l[e]+1,h[e]=1}));const w=Ci(l,c,h),v=w.filter(((e,t)=>-1===x.indexOf(t)));return{nonStrided:h.every((e=>1===e)),$begin:l,$end:c,$strides:h,size:w,newShape:m,outShape:v}}class Pi{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Vi{constructor(){this.classNameMap={}}static getMap(){return null==Vi.instance&&(Vi.instance=new Vi),Vi.instance}static register(e){Vi.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Wi(e){Q(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Q("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Q(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),Vi.register(e)}const Ui=.1;function Gi(e,t,n){return null==n&&(n=ji()),Hi(e,t,((e,t)=>Yi(e,t,n)))}function ji(){return 32===Ls.backend.floatPrecision()?.001:Ui}function Hi(e,t,n){let r=!0;if((we(e)||we(t))&&(r=!1),we(e)&&we(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=Ws(e),r=Ws(t);if(!ae(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=we(e)?e:ne(e),a=we(t)?t:ne(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let e=0;e<a.length;++e){const t=s[e],r=a[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${s}.\nExpected: ${a}.`)}}function qi(e,t){e().then((()=>t.fail()),(()=>t()))}function Ki(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Ie(e)||Ie(e[0])||Ie(t)||Ie(t[0])?Hi(e,n,((e,t)=>e==t)):Hi(e,t,((e,t)=>Yi(e,t,0)))}function Xi(e,t,n){if(null==n&&(n=ji()),!Yi(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function Yi(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Ji(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Zi(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}function Qi(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Qi(n):e[t]=hs(n)}return e}const eo="3.0.0";function to(){Ve().set("PROD",!0)}function no(){Ve().set("DEBUG",!0)}function ro(){Ve().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function so(e){Ve().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ao(){Ls.disposeVariables()}function io(){return Ls}function oo(){return Ls.memory()}function uo(e){return Ls.profile(e)}function lo(e,t){return Ls.tidy(e,t)}function co(e){Rs(e).forEach((e=>e.dispose()))}function ho(e){return Ls.keep(e)}function po(e){return Ls.time(e)}function fo(e){return Ls.setBackend(e)}function mo(){return Ls.ready()}function go(){return Ls.backendName}function yo(e){Ls.removeBackend(e)}function bo(e){return Ls.findBackend(e)}function xo(e){return Ls.findBackendFactory(e)}function wo(e,t,n=1){return Ls.registerBackend(e,t,n)}function vo(){return Ls.backend}function ko(e,t){Ve().setPlatform(e,t)}gs=so;const Io=Ks({add_:function(e,t){let n=js(e,"a","add"),r=js(t,"b","add");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(Xe,s)}});const No=Ks({floorDiv_:function(e,t){let n=js(e,"a","floorDiv"),r=js(t,"b","floorDiv");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(Jt,s)}});const So=Ks({div_:function(e,t){let n=js(e,"a","div"),r=js(t,"b","div");if([n,r]=Ts(n,r),"int32"===n.dtype&&"int32"===r.dtype)return No(n,r);const s={a:n,b:r};return Ls.runKernel(Bt,s,{})}});const Co=Ks({mul_:function(e,t){let n=js(e,"a","mul"),r=js(t,"b","mul");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(On,s)}});const Eo=Ks({sqrt_:function(e){const t={x:js(e,"x","sqrt")};return Ls.runKernel(yr,t)}});const To=Ks({square_:function(e){const t=js(e,"x","square");return Ls.runKernel("Square",{x:t},{})}});const $o=Ks({zerosLike_:function(e){const t={x:js(e,"x","zerosLike")};return Ls.runKernel(Or,t)}});function Ao(e){return Q(Ee(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const r=js(t,"x","tf.grad","string_or_numeric"),s=null!=n?js(n,"dy","tf.grad"):null;return Ls.tidy((()=>{const{value:t,grads:n}=Ls.gradients((()=>e(r)),[r],s);return null!=s&&ee(t.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Mo(n),n[0]}))}}function Ro(e){return Q(Ee(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Q(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const r=Hs(t,"args","tf.grads","string_or_numeric"),s=null!=n?js(n,"dy","tf.grads"):null;return Ls.tidy((()=>{const{value:t,grads:n}=Ls.gradients((()=>e(...r)),r,s);return null!=s&&ee(t.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Mo(n),n}))}}function _o(e){return Q(Ee(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Q(t instanceof ys,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Q(null==n||n instanceof ys,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:r,value:s}=Ls.gradients((()=>e(t)),[t],n);return Mo(r),{grad:r[0],value:s}}}function Fo(e){return Q(Ee(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Q(Array.isArray(t)&&t.every((e=>e instanceof ys)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Q(null==n||n instanceof ys,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const r=Ls.gradients((()=>e(...t)),t,n);return null!=n&&ee(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Mo(r.grads),r}}function Do(e,t){Q(Ee(e),(()=>"The f passed in variableGrads(f) must be a function")),Q(null==t||Array.isArray(t)&&t.every((e=>e instanceof xs)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Ls.registeredVariables)t.push(Ls.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;Q((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=Ls.gradients(e,t,null,!0);Q(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Q(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}function Oo(e){return Ls.customGrad(e)}function Mo(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Lo(e,t){if((we(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&we(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ys(e,[],[],t)}class zo extends Pi{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return co(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Do(e,t)}dispose(){null!=this.iterations_&&co(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Lo(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(zo,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Bo extends zo{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Ls.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Ls.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:lo((()=>$o(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:lo((()=>$o(r).variable(false)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;lo((()=>{const e=Io(Co(a,this.rho),Co(To(s),1-this.rho)),t=Co(So(Eo(Io(i,this.epsilon)),Eo(Io(a,this.epsilon))),s),n=Io(Co(i,this.rho),Co(To(t),1-this.rho));a.assign(e),i.assign(n);const o=Io(Co(t,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(co(this.accumulatedGrads.map((e=>e.variable))),co(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Po(e,t,n){const r={shape:e,value:t,dtype:n};return Ls.runKernel(Kt,{},r)}Bo.className="Adadelta",Wi(Bo);class Vo extends zo{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Ls.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:lo((()=>Po(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;lo((()=>{const e=Io(a,To(s));a.assign(e);const t=Io(Co(So(s,Eo(Io(e,Ls.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&co(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Vo.className="Adagrad",Wi(Vo);const Wo=Ks({pow_:function(e,t){let n=js(e,"base","pow"),r=js(t,"exp","pow");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(Hn,s)}});const Uo=Ks({sub_:function(e,t){let n=js(e,"a","sub"),r=js(t,"b","sub");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(Nr,s)}});class Go extends zo{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],lo((()=>{this.accBeta1=Lo(t).variable(),this.accBeta2=Lo(n).variable()})),null==r&&(this.epsilon=Ls.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);lo((()=>{const n=Uo(1,this.accBeta1),r=Uo(1,this.accBeta2);t.forEach(((t,s)=>{const a=Ls.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:lo((()=>$o(a).variable(false)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:lo((()=>$o(a).variable(false)))});const i=Array.isArray(e)?e[s].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,l=Io(Co(o,this.beta1),Co(i,1-this.beta1)),c=Io(Co(u,this.beta2),Co(To(i),1-this.beta2)),h=So(l,n),p=So(c,r);o.assign(l),u.assign(c);const d=Io(Co(So(h,Io(Eo(p),this.epsilon)),-this.learningRate),a);a.assign(d)})),this.accBeta1.assign(Co(this.accBeta1,this.beta1)),this.accBeta2.assign(Co(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&co(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&co(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),lo((()=>{this.accBeta1.assign(Wo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wo(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Go.className="Adam",Wi(Go);const jo=Ks({abs_:function(e){const t=js(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Ls.runKernel(bt,e)}{const e={x:t};return Ls.runKernel(He,e)}}});function Ho(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function qo(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Ko(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let a=t[t.length-s-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(r)}}return n}const Xo=Ks({maximum_:function(e,t){let n=js(e,"a","maximum"),r=js(t,"b","maximum");[n,r]=Ts(n,r),"bool"===n.dtype&&(n=Ha(n,"int32"),r=Ha(r,"int32")),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(In,s)}});class Yo extends zo{constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],lo((()=>{this.iteration=Lo(0).variable(),this.accBeta1=Lo(t).variable()})),null==r&&(this.epsilon=Ls.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);lo((()=>{const n=Uo(1,this.accBeta1),r=So(-this.learningRate,Io(Co(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=Ls.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:$o(a).variable(false)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:$o(a).variable(false)});const i=Array.isArray(e)?e[s].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,l=Io(Co(o,this.beta1),Co(i,1-this.beta1)),c=Co(u,this.beta2),h=jo(i),p=Xo(c,h);o.assign(l),u.assign(p);const d=Io(Co(So(r,n),So(l,Io(p,this.epsilon))),a);a.assign(d)})),this.iteration.assign(Io(this.iteration,1)),this.accBeta1.assign(Co(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&co(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&co(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Yo.className="Adamax",Wi(Yo);class Jo extends zo{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Ls.registeredVariables[t];lo((()=>{const e=Io(Co(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ho(Lo(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Jo.className="SGD",Wi(Jo);class Zo extends Jo{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Lo(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Ls.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:lo((()=>$o(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&lo((()=>{let e;const t=Io(Co(this.m,s),a);e=this.useNesterov?Io(Co(this.c,Io(a,Co(t,this.m))),r):Io(Co(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&co(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Zo.className="Momentum",Wi(Zo);class Qo extends zo{constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Ls.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Ls.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:lo((()=>$o(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:lo((()=>$o(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:lo((()=>$o(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;lo((()=>{const e=Io(Co(i,this.decay),Co(To(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=Io(Co(t,this.decay),Co(a,1-this.decay)),u=So(Co(a,this.learningRate),Eo(Uo(e,Io(To(s),this.epsilon)))),l=Io(Co(o,this.momentum),u);i.assign(e),t.assign(s),o.assign(l);const c=Uo(r,l);r.assign(c)}else{const e=Io(Co(i,this.decay),Co(To(a),1-this.decay)),t=Io(Co(o,this.momentum),So(Co(a,this.learningRate),Eo(Io(e,this.epsilon))));i.assign(e),o.assign(t);const n=Uo(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&co(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&co(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&co(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Qo.className="RMSProp",Wi(Qo);const eu=Ks({acos_:function(e){const t={x:js(e,"x","acos")};return Ls.runKernel(qe,t)}});const tu=Ks({acosh_:function(e){const t={x:js(e,"x","acosh")};return Ls.runKernel(Ke,t)}});const nu=Ks({addN_:function(e){Q(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Q(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>js(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ae(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return Ls.runKernel(Ye,r)}});const ru=Ks({all_:function(e,t=null,n=!1){const r={x:js(e,"x","all","bool")},s={axis:t,keepDims:n};return Ls.runKernel(Je,r,s)}});const su=Ks({any_:function(e,t=null,n=!1){const r={x:js(e,"x","any","bool")},s={axis:t,keepDims:n};return Ls.runKernel(Ze,r,s)}});const au=Ks({argMax_:function(e,t=0){const n={x:js(e,"x","argMax")},r={axis:t};return Ls.runKernel(Qe,n,r)}});const iu=Ks({argMin_:function(e,t=0){const n={x:js(e,"x","argMin")},r={axis:t};return Ls.runKernel(et,n,r)}});const ou=Ks({asin_:function(e){const t={x:js(e,"x","asin")};return Ls.runKernel(tt,t)}});const uu=Ks({asinh_:function(e){const t={x:js(e,"x","asinh")};return Ls.runKernel(nt,t)}});const lu=Ks({atan_:function(e){const t={x:js(e,"x","atan")};return Ls.runKernel(rt,t)}});const cu=Ks({atan2_:function(e,t){let n=js(e,"a","atan2"),r=js(t,"b","atan2");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(at,s)}});const hu=Ks({atanh_:function(e){const t={x:js(e,"x","atanh")};return Ls.runKernel(st,t)}});function pu(e,t,n,r,s="NHWC",a){return mu(e,[...t,e[3]],n,a,r,null,null,Nu(s))}function du(e,t,n,r,s,a,i="channelsLast"){const[o,u]=bu(t);let l;if("channelsLast"===i)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[o,u,e[1],e[1]]}return mu(e,l,n,r,s,a,!1,i)}function fu(e,t,n,r,s,a,i="NDHWC"){const[o,u,l]=xu(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,u,l,e[1],e[1]]}return gu(e,c,n,r,s,!1,h,a)}function mu(e,t,n,r,s,a,i=!1,o="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,h,l,c]=e}const[p,d,,f]=t,[m,g]=bu(n),[y,b]=bu(r),x=wu(p,y),w=wu(d,b),{padInfo:v,outHeight:k,outWidth:I}=function(e,t,n,r,s,a,i,o,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=yu(e,t,n));const a=e[0],i=e[1],o=vu((a-t+2*r)/n+1,s),u=vu((i-t+2*r)/n+1,s);return[o,u]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),u=Math.floor(e/2),p=e-u,d=Math.floor(o/2);l={top:u,bottom:p,left:d,right:o-d,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===u?e[1][0]:e[2][0],d="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:p,bottom:d,left:f,right:m,type:0===p&&0===d&&0===f&&0===m?"VALID":"EXPLICIT"},c=vu((t-a+p+d)/r+1,o),h=vu((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:c,outWidth:h}}(s,l,c,m,g,x,w,a,o),N=i?f*h:f;let S;return"channelsFirst"===o?S=[u,N,k,I]:"channelsLast"===o&&(S=[u,k,I,N]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:h,outHeight:k,outWidth:I,outChannels:N,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function gu(e,t,n,r,s,a=!1,i="channelsLast",o){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,p]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,p,l,c,h]=e}const[d,f,m,,g]=t,[y,b,x]=xu(n),[w,v,k]=xu(r),I=wu(d,w),N=wu(f,v),S=wu(m,k),{padInfo:C,outDepth:E,outHeight:T,outWidth:$}=function(e,t,n,r,s,a,i,o,u,l,c){let h,p,d,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,s,a){null==s&&(s=yu(e,t,r));const i=e[0],o=e[1],u=e[2],l=vu((i-t+2*s)/r+1,a),c=vu((o-t+2*s)/r+1,a),h=vu((u-t+2*s)/r+1,a);return[l,c,h,n]}([t,n,r,1],o,1,s,e,c);p=a[0],d=a[1],f=a[2]}else if("same"===e){p=Math.ceil(t/s),d=Math.ceil(n/a),f=Math.ceil(r/i);const e=(p-1)*s+o-t,c=(d-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),x=c-b,w=Math.floor(m/2);h={top:b,bottom:x,left:w,right:m-w,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-o+1)/s),d=Math.ceil((n-u+1)/a),f=Math.ceil((r-l+1)/i)}return{padInfo:h,outDepth:p,outHeight:d,outWidth:f}}(s,l,c,h,y,b,x,I,N,S,o),A=a?g*p:g;let R;return"channelsFirst"===i?R=[u,A,E,T,$]:"channelsLast"===i&&(R=[u,E,T,$,A]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:E,outHeight:T,outWidth:$,outChannels:A,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:d,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function yu(e,t,n,r=1){const s=wu(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function bu(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function xu(e){return"number"==typeof e?[e,e,e]:e}function wu(e,t){return t<=1?e:e+(e-1)*(t-1)}function vu(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ku(e){const[t,n,r]=bu(e);return 1===t&&1===n&&1===r}function Iu(e,t){return ku(e)||ku(t)}function Nu(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Su=Ks({reshape_:function(e,t){const n={x:js(e,"x","reshape","string_or_numeric")},r={shape:t};return Ls.runKernel(Qn,n,r)}});const Cu=Ks({avgPool_:function(e,t,n,r,s){const a=js(e,"x","avgPool","float32");Q(Iu(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Su(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),null!=s&&Q(ie(r),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=Ls.runKernel(it,u,l);return c=Ha(c,a.dtype),o?Su(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Eu=Ks({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=js(e,"x","avgPool3d","float32");let o=i,u=!1;4===i.rank&&(u=!0,o=Su(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Q("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),null!=s&&Q(ie(r),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=Ls.runKernel(ut,l,c);return h=Ha(h,o.dtype),u?Su(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Tu=Ks({concat_:function(e,t=0){Q(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Hs(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return qa(n[0]);const r=n,s={axis:t};return Ls.runKernel(xt,r,s)}});const $u=Ks({sigmoid_:function(e){const t={x:js(e,"x","sigmoid")};return Ls.runKernel(mr,t)}});const Au=Ks({slice_:function(e,t,n){const r=js(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return Ls.runKernel(hr,s,a)}});const Ru=Ks({tanh_:function(e){const t={x:js(e,"x","tanh")};return Ls.runKernel(Tr,t)}});const _u=Ks({basicLSTMCell_:function(e,t,n,r,s,a){const i=js(e,"forgetBias","basicLSTMCell"),o=js(t,"lstmKernel","basicLSTMCell"),u=js(n,"lstmBias","basicLSTMCell"),l=js(r,"data","basicLSTMCell"),c=js(s,"c","basicLSTMCell"),h=js(a,"h","basicLSTMCell"),p=Tu([l,h],1),d=pi(p,o),f=Io(d,u),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Au(f,[0,0],y),x=Au(f,[0,g],y),w=Au(f,[0,2*g],y),v=Au(f,[0,3*g],y),k=Io(Co($u(b),Ru(x)),Co(c,$u(Io(i,w))));return[k,Co(Ru(k),$u(v))]}});const Fu=Ks({batchToSpaceND_:function(e,t,n){const r=js(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));Q(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Q(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Q(r.shape[0]%s==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return Ls.runKernel(ht,a,i)}});const Du=Ks({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=js(e,"x","batchNorm"),o=js(t,"mean","batchNorm"),u=js(n,"variance","batchNorm");let l,c;null!=s&&(l=js(s,"scale","batchNorm")),null!=r&&(c=js(r,"offset","batchNorm")),Q(o.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Q(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Q(null==l||o.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Su(e,[1,1,1,e.size]):2===e.rank?Su(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Su(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:l,offset:c,mean:o,variance:u},p={varianceEpsilon:a},d=Ls.runKernel(Zt,h,p);return Su(d,i.shape)}});const Ou=Ks({batchNorm2d_:function(e,t,n,r,s,a){const i=js(e,"x","batchNorm"),o=js(t,"mean","batchNorm"),u=js(n,"variance","batchNorm");let l,c;return null!=s&&(l=js(s,"scale","batchNorm")),null!=r&&(c=js(r,"offset","batchNorm")),Q(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Q(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Q(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=l&&Q(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=c&&Q(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Du(i,o,u,c,l,a)}});const Mu=Ks({batchNorm3d_:function(e,t,n,r,s,a){const i=js(e,"x","batchNorm"),o=js(t,"mean","batchNorm"),u=js(n,"variance","batchNorm");let l,c;return null!=s&&(l=js(s,"scale","batchNorm")),null!=r&&(c=js(r,"offset","batchNorm")),Q(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Q(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Q(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=l&&Q(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=c&&Q(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Du(i,o,u,c,l,a)}});const Lu=Ks({batchNorm4d_:function(e,t,n,r,s,a){const i=js(e,"x","batchNorm"),o=js(t,"mean","batchNorm"),u=js(n,"variance","batchNorm");let l,c;return null!=s&&(l=js(s,"scale","batchNorm")),null!=r&&(c=js(r,"offset","batchNorm")),Q(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Q(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Q(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=l&&Q(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=c&&Q(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Du(i,o,u,c,l,a)}});const zu=Ks({bincount_:function(e,t,n){const r=js(e,"x","bincount"),s=js(t,"weights","bincount");Q("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Q(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Q(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return Ls.runKernel(pt,a,i)}});const Bu=Ks({broadcastTo_:function(e,t){let n=js(e,"broadcastTo","x");const r=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Su(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return qa(n);const i={x:n},o={reps:a};return Ls.runKernel($r,i,o)}});const Pu=Ks({ceil_:function(e){const t={x:js(e,"x","ceil")};return Ls.runKernel(mt,t)}});const Vu=Ks({clipByValue_:function(e,t,n){const r=js(e,"x","clipByValue");Q(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const s={x:r},a={clipValueMin:t,clipValueMax:n};return Ls.runKernel(gt,s,a)}});const Wu=Ks({concat1d_:function(e){return Tu(e,0)}});const Uu=Ks({concat2d_:function(e,t){return Tu(e,t)}});const Gu=Ks({concat3d_:function(e,t){return Tu(e,t)}});const ju=Ks({concat4d_:function(e,t){return Tu(e,t)}});const Hu=Ks({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=js(e,"x","conv2d"),u=js(t,"filter","conv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Su(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Q(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),Q(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),null!=i&&Q(ie(r),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`));const h="NHWC"===s?l.shape[3]:l.shape[1];Q(h===u.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`)),Q(Iu(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Ls.runKernel(wt,p,d);return c?Su(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const qu=Ks({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=js(e,"x","conv1d"),u=js(t,"filter","conv1d");let l=o,c=!1;2===o.rank&&(c=!0,l=Su(o,[1,o.shape[0],o.shape[1]])),Q(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),Q(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),null!=i&&Q(ie(r),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`)),Q(l.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),Q(Iu(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),Q("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=Su(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=Su(l,[l.shape[0],1,l.shape[1],l.shape[2]]),d=Hu(p,h,[1,n],r,"NHWC",[1,a],i);return Su(d,c?[d.shape[2],d.shape[3]]:[d.shape[0],d.shape[2],d.shape[3]])}});const Ku=Ks({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Q(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=Su(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Q(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Q(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),Q(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?u.shape[3]:u.shape[1];Q(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Q(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),null!=i&&Q(ie(s),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`));const p={dy:u,filter:n},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=Ls.runKernel(kt,p,d);return l?Su(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Xu=Ks({conv2dTranspose_:function(e,t,n,r,s,a){const i=js(e,"x","conv2dTranspose"),o=js(t,"filter","conv2dTranspose");return Ku(n,i,o,r,s,"NHWC",a)}});const Yu=Ks({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=js(e,"x","conv3d"),o=js(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Su(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),Q(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Q(u.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Q(Iu(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Q("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`));const c={x:u,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},p=Ls.runKernel(It,c,h);return l?Su(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});const Ju=Ks({conv3DBackpropInput_:function(e,t,n,r,s){Q(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Su(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=i.shape[4];Q(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),Q(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Q(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Q(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),Q(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},p=Ls.runKernel(St,c,h);return o?Su(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});const Zu=Ks({conv3dTranspose_:function(e,t,n,r,s){const a=js(e,"x","conv3dTranspose"),i=js(t,"filter","conv3dTranspose");return Ju(n,a,i,r,s)}});const Qu=Ks({cos_:function(e){const t={x:js(e,"x","cos")};return Ls.runKernel(Ct,t)}});const el=Ks({cosh_:function(e){const t={x:js(e,"x","cosh")};return Ls.runKernel(Et,t)}});const tl=Ks({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:js(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return Ls.runKernel(Tt,s,a)}});const nl=Ks({denseBincount_:function(e,t,n,r=!1){const s=js(e,"x","denseBincount"),a=js(t,"weights","denseBincount");Q("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),Q(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),Q(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Q(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return Ls.runKernel(At,i,o)}});const rl=Ks({depthToSpace_:function(e,t,n="NHWC"){const r=js(e,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Q(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Q(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Q(i%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},u={blockSize:t,dataFormat:n};return Ls.runKernel(Rt,o,u)}});const sl=Ks({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=js(e,"x","depthwiseConv2d"),u=js(t,"filter","depthwiseConv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Su(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Q(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),Q(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`)),Q(l.shape[3]===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),null!=i&&Q(ie(r),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`));const h={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},d=Ls.runKernel(_t,h,p);return c?Su(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const al=Ks({diag_:function(e){const t={x:js(e,"x","diag")};return Ls.runKernel(Ot,t)}});const il=Ks({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=js(e,"x","dilation2d"),o=js(t,"filter","dilation2d");Q(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Q(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Q("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let u=i,l=!1;3===i.rank&&(u=Su(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);const c={x:u,filter:o},h={strides:n,pad:r,dilations:s},p=Ls.runKernel(Mt,c,h);return l?Su(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});const ol=Ks({equal_:function(e,t){let n=js(e,"a","equal"),r=js(t,"b","equal");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(Ut,s)}});const ul=Ks({where_:function(e,t,n){const r=js(t,"a","where"),s=js(n,"b","where"),a=js(e,"condition","where","bool"),i=Ko(r.shape,s.shape),o=Bu(r,i),u=Bu(s,i);1===a.rank&&Q(a.shape[0]===r.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==a.rank&&ee(a.shape,u.shape,"Error in where: ");const l={condition:a,t:o,e:u};return Ls.runKernel(lr,l)}});const ll=Ks({divNoNan_:function(e,t){let n=js(e,"a","div"),r=js(t,"b","div");[n,r]=Ts(n,r);const s=So(n,r),a=$o(s),i=ol(r,a);return ul(i,a,s)}});const cl=Ks({dot_:function(e,t){const n=js(e,"t1","dot"),r=js(t,"t2","dot");Q(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Q(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Su(n,[1,-1]),t=Su(r,[-1,1]),s=pi(e,t);return Su(s,[])}if(1===n.rank&&2===r.rank){const e=Su(n,[1,-1]),t=Su(r,[r.shape[0],r.shape[1]]),s=pi(e,t);return Su(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Su(r,[-1,1]),t=pi(n,e);return Su(t,[t.size])}{const e=Su(r,[r.shape[0],r.shape[1]]);return pi(n,e)}}});const hl=Ks({elu_:function(e){const t={x:js(e,"x","elu")};return Ls.runKernel(Pt,t)}});const pl=Ks({erf_:function(e){let t=js(e,"x","erf");Q("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Ha(t,"float32"));const n={x:t};return Ls.runKernel(Wt,n)}});const dl=Ks({exp_:function(e){const t={x:js(e,"x","exp")};return Ls.runKernel(Gt,t)}});const fl=Ks({expandDims_:function(e,t=0){const n=js(e,"x","expandDims","string_or_numeric");Q(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return Ls.runKernel(jt,r,s)}});const ml=Ks({expm1_:function(e){const t={x:js(e,"x","expm1")};return Ls.runKernel(Ht,t)}});const gl=Ks({tile_:function(e,t){const n=js(e,"x","tile","string_or_numeric");Q(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return Ls.runKernel($r,r,s)}});const yl=Ks({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=ja([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=Su(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return gl(fl(i,0),[n[0],1,1]);if(2===n.length)return gl(fl(fl(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return gl(fl(fl(fl(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const bl=Ks({floor_:function(e){const t={x:js(e,"x","floor")};return Ls.runKernel(Yt,t)}});const xl=Ks({gather_:function(e,t,n=0,r=0){const s={x:js(e,"x","gather"),indices:js(t,"indices","gather","int32")},a={axis:n,batchDims:r};return Ls.runKernel(Qt,s,a)}});const wl=Ks({greater_:function(e,t){let n=js(e,"a","greater"),r=js(t,"b","greater");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(tn,s)}});const vl=Ks({greaterEqual_:function(e,t){let n=js(e,"a","greaterEqual"),r=js(t,"b","greaterEqual");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(nn,s)}});const kl=Ks({imag_:function(e){const t={input:js(e,"input","imag")};return Ls.runKernel(an,t)}});const Il=Ks({isFinite_:function(e){const t={x:js(e,"x","isFinite")};return Ls.runKernel(on,t)}});const Nl=Ks({isInf_:function(e){const t={x:js(e,"x","isInf")};return Ls.runKernel(un,t)}});const Sl=Ks({isNaN_:function(e){const t={x:js(e,"x","isNaN")};return Ls.runKernel(ln,t)}});const Cl=Ks({leakyRelu_:function(e,t=.2){const n={x:js(e,"x","leakyRelu")},r={alpha:t};return Ls.runKernel(cn,n,r)}});const El=Ks({less_:function(e,t){let n=js(e,"a","less"),r=js(t,"b","less");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(hn,s)}});const Tl=Ks({lessEqual_:function(e,t){let n=js(e,"a","lessEqual"),r=js(t,"b","lessEqual");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(pn,s)}});function $l(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return Ls.runKernel(dn,{},r)}const Al=Ks({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=js(e,"x","localResponseNormalization");Q(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),Q(ie(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Su(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},l={depthRadius:t,bias:n,alpha:r,beta:s},c=Ls.runKernel(wn,u,l);return o?Su(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Rl=Ks({log_:function(e){const t={x:js(e,"x","log")};return Ls.runKernel(fn,t)}});const _l=Ks({log1p_:function(e){const t={x:js(e,"x","log1p")};return Ls.runKernel(mn,t)}});const Fl=Ks({neg_:function(e){const t={x:js(e,"x","neg")};return Ls.runKernel(Mn,t)}});const Dl=Ks({softplus_:function(e){const t={x:js(e,"x","softplus")};return Ls.runKernel(gr,t)}});const Ol=Ks({logSigmoid_:function(e){const t=js(e,"x","logSigmoid");return Oo((e=>({value:Fl(Dl(Fl(e))),gradFunc:t=>Co(t,$u(Fl(e)))})))(t)}});const Ml=Ks({max_:function(e,t=null,n=!1){const r={x:js(e,"x","max")},s={reductionIndices:t,keepDims:n};return Ls.runKernel(kn,r,s)}});const Ll=Ks({sum_:function(e,t=null,n=!1){let r=js(e,"x","sum");"bool"===r.dtype&&(r=Ha(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Ls.runKernel(br,s,a)}});const zl=Ks({logSoftmax_:function(e,t=-1){const n=js(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Oo(((e,n)=>{const r=Ml(e,t,!0),s=Uo(e,r),a=Uo(Ha(s,"float32"),Rl(Ll(dl(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=dl(r);return Uo(e,Co(Ll(e,t,!0),s))}}}))(n)}});function Bl(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Pl(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Vl(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function Wl(e,t){return Pl(e,t.map((e=>1)),t)}function Ul(e,t,n){Q(Bl(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Gl(e,t){if(Bl(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function jl(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Hl(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const ql=Ks({logSumExp_:function(e,t=null,n=!1){const r=js(e,"x","logSumExp"),s=de(t,r.shape),a=Ml(r,s,!0),i=Uo(r,a),o=dl(i),u=Ll(o,s),l=Rl(u),c=Io(Su(a,l.shape),l);if(n){const e=Wl(c.shape,s);return Su(c,e)}return c}});const Kl=Ks({logicalAnd_:function(e,t){const n=js(e,"a","logicalAnd","bool"),r=js(t,"b","logicalAnd","bool");Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(gn,s)}});const Xl=Ks({logicalNot_:function(e){const t={x:js(e,"x","logicalNot","bool")};return Ls.runKernel(yn,t)}});const Yl=Ks({logicalOr_:function(e,t){const n=js(e,"a","logicalOr","bool"),r=js(t,"b","logicalOr","bool");Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(bn,s)}});const Jl=Ks({logicalXor_:function(e,t){const n=js(e,"a","logicalXor","bool"),r=js(t,"b","logicalXor","bool");return Ko(n.shape,r.shape),Kl(Yl(e,t),Xl(Kl(e,t)))}});const Zl=Ks({maxPool_:function(e,t,n,r,s){const a=js(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Su(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Q(Iu(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=s&&Q(ie(r),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=Ls.runKernel(Nn,u,l);return o?Su(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Ql=Ks({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=js(e,"x","maxPool3d");let o=i,u=!1;4===i.rank&&(u=!0,o=Su(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Q("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),null!=s&&Q(ie(r),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=Ls.runKernel(Cn,l,c);return u?Su(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ec=Ks({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a={x:js(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=Ls.runKernel(Tn,a,i);return{result:o[0],indexes:o[1]}}});const tc=Ks({mean_:function(e,t=null,n=!1){const r={x:js(e,"x","mean")},s={axis:t,keepDims:n};return Ls.runKernel($n,r,s)}});const nc=Ks({min_:function(e,t=null,n=!1){const r={x:js(e,"x","min")},s={axis:t,keepDims:n};return Ls.runKernel(An,r,s)}});const rc=Ks({minimum_:function(e,t){let n=js(e,"a","minimum"),r=js(t,"b","minimum");[n,r]=Ts(n,r),"bool"===n.dtype&&(n=Ha(n,"int32"),r=Ha(r,"int32")),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(Rn,s)}});const sc=Ks({mirrorPad_:function(e,t,n){Q("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=js(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Q(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let e=0;e<r.rank;e++)Q(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Q(t[e][0]>=0&&t[e][0]<=r.shape[e]-s&&t[e][1]>=0&&t[e][1]<=r.shape[e]-s,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return Ls.runKernel(_n,i,a)}});const ac=Ks({mod_:function(e,t){let n=js(e,"a","mod"),r=js(t,"b","mod");[n,r]=Ts(n,r);const s={a:n,b:r};return Ls.runKernel(Fn,s)}});const ic=Ks({moments_:function(e,t=null,n=!1){const r=de(t,(e=js(e,"x","moments")).shape),s=tc(e,r,n);let a=s.shape;n||(a=Wl(s.shape,r));const i=To(Uo(Ha(e,"float32"),Su(s,a)));return{mean:s,variance:tc(i,r,n)}}});const oc=Ks({multiRNNCell_:function(e,t,n,r){const s=js(t,"data","multiRNNCell"),a=Hs(n,"c","multiRNNCell"),i=Hs(r,"h","multiRNNCell");let o=s;const u=[];for(let t=0;t<e.length;t++){const n=e[t](o,a[t],i[t]);u.push(n[0]),u.push(n[1]),o=n[1]}const l=[],c=[];for(let e=0;e<u.length;e+=2)l.push(u[e]),c.push(u[e+1]);return[l,c]}});const uc=Ks({multinomial_:function(e,t,n,r=!1){const s=js(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Su(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},l=Ls.runKernel(Dn,o,u);return 1===i?Su(l,[l.size]):l}});const lc=Ks({notEqual_:function(e,t){let n=js(e,"a","notEqual"),r=js(t,"b","notEqual");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(Ln,s)}});function cc(e,t="float32"){if("complex64"===t){const t=cc(e,"float32"),n=cc(e,"float32");return Xs(t,n)}const n=Fe(re(e),t);return Ls.makeTensor(n,e,t)}function hc(e,t="float32"){if("complex64"===t){const t=hc(e,"float32"),n=cc(e,"float32");return Xs(t,n)}const n=_e(re(e),t);return Ls.makeTensor(n,e,t)}const pc=Ks({onesLike_:function(e){const t={x:js(e,"x","onesLike")};return Ls.runKernel(Vn,t)}});const dc=Ks({outerProduct_:function(e,t){const n=js(e,"v1","outerProduct"),r=js(t,"v2","outerProduct");Q(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Su(n,[-1,1]),a=Su(r,[1,-1]);return pi(s,a)}});const fc=Ks({pad_:function(e,t,n=0){const r=js(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return Ls.runKernel(Gn,a,s)}});const mc=Ks({pad1d_:function(e,t,n=0){return Q(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),fc(e,[t],n)}});const gc=Ks({pad2d_:function(e,t,n=0){return Q(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),fc(e,t,n)}});const yc=Ks({pad3d_:function(e,t,n=0){return Q(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),fc(e,t,n)}});const bc=Ks({pad4d_:function(e,t,n=0){return Q(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),fc(e,t,n)}});const xc=Ks({spaceToBatchND_:function(e,t,n){const r=js(e,"x","spaceToBatchND");Q(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Q(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Q(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return Ls.runKernel(xr,s,a)}});const wc=Ks({pool_:function(e,t,n,r,s,a){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const i=js(e,"x","maxPool");let o=i,u=!1;3===i.rank&&(u=!0,o=Su(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(Iu(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const l=du(o.shape,t,a,s,r),c=[l.dilationHeight,l.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([l.filterHeight,l.filterWidth],c):[[0,0],[0,0]];const p=1===c[0]&&1===c[1],[d,f]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),u=t.map(((e,t)=>[r[t],o[t]])),l=t.map(((e,t)=>[0,i[t]]));return[u,l]}([l.inHeight,l.inWidth],c,h),m=p?r:"valid",g=p?o:xc(o,c,d),y=("avg"===n?()=>Cu(g,t,a,m):()=>Zl(g,t,a,m))(),b=p?y:Fu(y,c,f);return u?Su(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});const vc=Ks({prelu_:function(e,t){const n={x:js(e,"x","prelu"),alpha:js(t,"alpha","prelu")};return Ls.runKernel(qn,n)}});const kc=Ks({prod_:function(e,t=null,n=!1){let r=js(e,"x","prod");"bool"===r.dtype&&(r=Ha(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Ls.runKernel(Kn,s,a)}});const Ic=Ks({rand_:function(e,t,n){const r=re(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return Ls.makeTensor(s,e,n)}});var Nc=n(377);class Sc{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=Nc.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Cc{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=Nc.alea(s.toString()),this.randn=new Sc(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Ec{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Nc.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Tc=Ks({randomGamma_:function(e,t,n=1,r="float32",s){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new Cc(t,n,r,s),i=ja(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const $c=Ks({randomNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Sc(t,n,r,!1,s),i=ja(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const Ac=Ks({randomUniform_:function(e,t=0,n=1,r="float32",s){const a=ja(e,r),i=new Ec(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}});function Rc(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return Ls.runKernel(Xn,{},s)}const _c=Ks({real_:function(e){const t={input:js(e,"input","real")};return Ls.runKernel(Yn,t)}});const Fc=Ks({reciprocal_:function(e){const t={x:js(e,"x","reciprocal")};return Ls.runKernel(Jn,t)}});const Dc=Ks({relu_:function(e){const t={x:js(e,"x","relu")};return Ls.runKernel(Zn,t)}});const Oc=Ks({relu6_:function(e){const t={x:js(e,"x","relu6")};return Ls.runKernel(sr,t)}});const Mc=Ks({reverse_:function(e,t){const n={x:js(e,"x","reverse")},r={dims:t};return Ls.runKernel(ar,n,r)}});const Lc=Ks({reverse1d_:function(e){const t=js(e,"x","reverse");return Q(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Mc(t,0)}});const zc=Ks({reverse2d_:function(e,t){const n=js(e,"x","reverse");return Q(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Mc(n,t)}});const Bc=Ks({reverse3d_:function(e,t){const n=js(e,"x","reverse");return Q(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Mc(n,t)}});const Pc=Ks({reverse4d_:function(e,t){const n=js(e,"x","reverse");return Q(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Mc(n,t)}});const Vc=Ks({round_:function(e){const t={x:js(e,"x","round")};return Ls.runKernel(ir,t)}});const Wc=Ks({rsqrt_:function(e){const t={x:js(e,"x","rsqrt")};return Ls.runKernel(or,t)}});const Uc=Ks({selu_:function(e){const t={x:js(e,"x","selu")};return Ls.runKernel(cr,t)}});const Gc=Ks({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=js(e,"x","separableConv2d"),u=js(t,"depthwiseFilter","separableConv2d"),l=js(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Su(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Q(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Q(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),Q(4===l.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),Q(1===l.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),Q(1===l.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));const p=u.shape[2],d=u.shape[3];Q(l.shape[2]===p*d,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${l.shape[2]}.`));const f=sl(c,u,r,s,i,a),m=Hu(f,l,1,"valid",i);return h?Su(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const jc=async function(e,t){const n=js(e,"x","setdiff1d"),r=js(t,"y","setdiff1d");Q(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Q(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Q(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const u=new ds([o],n.dtype),l=new ds([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(u.values[t]=s[e],l.values[t]=e,t++);return[u.toTensor(),l.toTensor()]};const Hc=Ks({sign_:function(e){const t={x:js(e,"x","sign")};return Ls.runKernel(fr,t)}});const qc=Ks({sin_:function(e){const t={x:js(e,"x","sin")};return Ls.runKernel(pr,t)}});const Kc=Ks({sinh_:function(e){const t={x:js(e,"x","sinh")};return Ls.runKernel(dr,t)}});const Xc=Ks({slice1d_:function(e,t,n){const r=js(e,"x","slice1d");return Q(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Au(r,[t],[n])}});const Yc=Ks({slice2d_:function(e,t,n){const r=js(e,"x","slice2d");return Q(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});const Jc=Ks({slice3d_:function(e,t,n){const r=js(e,"x","slice3d");return Q(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});const Zc=Ks({slice4d_:function(e,t,n){const r=js(e,"x","slice4d");return Q(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});const Qc=Ks({softmax_:function(e,t=-1){const n=js(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return Ls.runKernel(vr,r,s)}});const eh=Ks({fft_:function(e){Q("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Ls.runKernel(qt,t)}});const th=Ks({ifft_:function(e){Q("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Ls.runKernel(sn,t)}});const nh=Ks({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Su(e,[n,t]);r=th(s)}else{const s=[n,2*(t-1)],a=Su(_c(e),[n,t]),i=Su(kl(e),[n,t]),o=Mc(Au(a,[0,1],[n,t-2]),1),u=Co(Mc(Au(i,[0,1],[n,t-2]),1),Lo(-1)),l=Tu([a,o],1),c=Tu([i,u],1),h=Su(Xs(l,c),[s[0],s[1]]);r=th(h)}if(r=_c(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Su(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const rh=Ks({split_:function(e,t,n=0){const r={x:js(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Ls.runKernel(wr,r,s)}});const sh=Ks({rfft_:function(e,t){Q("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Au(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=Tu([e,cc(r)],e.shape.length-1),n=t}else s=e;const a=$o(s),i=Su(Xs(s,a),[r,n]),o=eh(i),u=Math.floor(n/2)+1,l=_c(o),c=kl(o),h=rh(l,[u,n-u],l.shape.length-1),p=rh(c,[u,n-u],c.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,Su(Xs(h[0],p[0]),d)}});const ah=Ks({squaredDifference_:function(e,t){let n=js(e,"a","squaredDifference"),r=js(t,"b","squaredDifference");[n,r]=Ts(n,r),Ko(n.shape,r.shape);const s={a:n,b:r};return Ls.runKernel(kr,s,{})}});const ih=Ks({squeeze_:function(e,t){const n=js(e,"x","squeeze");return Su(n,fe(n.shape,t).newShape)}});const oh=Ks({stack_:function(e,t=0){const n=Hs(e,"tensors","stack","string_or_numeric");Q(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Q(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return Ls.runKernel(Un,r,s)}});const uh=Ks({step_:function(e,t=0){const n={x:js(e,"x","step")},r={alpha:t};return Ls.runKernel(Mr,n,r)}});const lh=Ks({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,u=0){const l={x:js(e,"x","stridedSlice")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return Ls.runKernel(Cr,l,c)}});const ch=Ks({tan_:function(e){const t={x:js(e,"x","tan")};return Ls.runKernel(Er,t)}});function hh(e,t){te(e);const n=Ws(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ys(e,null,n,t)}function ph(e,t,n){if(te(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ws(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ys(e,t,r,n)}function dh(e,t,n){if(te(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Ws(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ys(e,t,r,n)}function fh(e,t,n){if(te(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Ws(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ys(e,t,r,n)}function mh(e,t,n){if(te(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Ws(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ys(e,t=t||r,r,n)}const gh=Ks({topk_:function(e,t=1,n=!0){const r=js(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,u]=Ls.runKernel(Ar,a,i);return{values:o,indices:u}}});const yh=Ks({truncatedNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Sc(t,n,r,!0,s),i=ja(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const bh=Ks({unique_:function(e,t=0){const n=js(e,"x","unique","string_or_numeric");Q(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=Ls.runKernel(_r,r,s);return{values:a,indices:i}}});const xh=Ks({unsortedSegmentSum_:function(e,t,n){const r=js(e,"x","unsortedSegmentSum"),s=js(t,"segmentIds","unsortedSegmentSum","int32");Q(ie(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return Ls.runKernel(Dr,a,i)}});const wh=Ks({unstack_:function(e,t=0){const n=js(e,"x","unstack","string_or_numeric");Q(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return Ls.runKernel(Fr,r,s)}});function vh(e,t=!0,n,r){return Ls.makeVariable(e,t,n,r)}function kh(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=ja(e,"int32"),s=ja([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),i=t*e.length;s.values.set(a,i)}return s.toTensor()}const Ih=async function(e){const t=js(e,"condition","whereAsync","bool"),n=await t.data(),r=kh(t.shape,n);return e!==t&&t.dispose(),r};const Nh=async function(e,t,n){const r=js(e,"tensor","boolMask"),s=js(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;Q(i>0,(()=>"mask cannot be scalar")),ee(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let e=a;e<a+i;e++)u*=o[e];const l=o.slice(0,a).concat([u],o.slice(a+i)),c=Su(r,l),h=Su(s,[-1]),p=await Ih(h),d=ih(p,[1]),f=xl(c,d,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),d.dispose(),c.dispose(),h.dispose(),p.dispose(),f};function Sh(e,t,n=null){if(0===e.rank)return jo(e);if(1!==e.rank&&null===n)return Sh(Su(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Ll(jo(e),n);if(t===1/0)return Ml(jo(e),n);if(t===-1/0)return nc(jo(e),n);if("euclidean"===t||2===t)return Eo(Ll(Wo(jo(e),Lo(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Ml(Ll(jo(e),n[0]),n[1]-1);if(t===1/0)return Ml(Ll(jo(e),n[1]),n[0]);if(t===-1/0)return nc(Ll(jo(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Eo(Ll(To(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ch=Ks({norm_:function(e,t="euclidean",n=null,r=!1){const s=Sh(e=js(e,"x","norm"),t,n);let a=s.shape;if(r){const t=de(n,e.shape);a=Wl(s.shape,t)}return Su(s,a)}});const Eh=Ks({movingAverage_:function(e,t,n,r,s=!0){const a=js(e,"v","movingAverage"),i=js(t,"x","movingAverage"),o=js(n,"decay","movingAverage");$s(a,i),Q(ae(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const u=Lo(1),l=Uo(u,o);let c=Co(Uo(i,a),l);if(s){Q(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=js(r,"step","movingAverage");c=So(c,Uo(u,Wo(o,e)))}return Io(a,c)}});const Th=Ks({scatterND_:function(e,t,n){const r=js(e,"indices","scatterND","int32"),s=js(t,"updates","scatterND");ki(s,r,n);const a={indices:r,updates:s},i={shape:n};return Ls.runKernel(ur,a,i)}});const $h=Ks({sparseToDense_:function(e,t,n,r=0){const s=js(e,"sparseIndices","sparseToDense","int32"),a=js(t,"sparseValues","sparseToDense"),i=js(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},u={outputShape:n};return Ls.runKernel(Sr,o,u)}});const Ah=Ks({gatherND_:function(e,t){const n=js(t,"indices","gatherND","int32"),r={params:js(e,"x","gatherND"),indices:n};return Ls.runKernel(en,r)}});const Rh=Ks({dropout_:function(e,t,n,r){const s=js(e,"x","dropout");if(Q("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Q(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof ys?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(ae(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=So(bl(Io(Ac(a,0,1,"float32",r),i)),i);return Co(s,o)}});function _h(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Fh(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return hh(s,"float32")}const Dh=async function(e,t,n=1){const r=js(e,"predictions","inTopK"),s=js(t,"targets","inTopK");Q(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Q(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),ee(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];Q(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[u,l]=[i.length/a,a],c=me("bool",u);for(let e=0;e<u;e++){const t=e*l,r=i.subarray(t,t+l),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort(((e,t)=>t.value-e.value)),c[e]=0;for(let t=0;t<n;t++)if(s[t].index===o[e]){c[e]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Js(c,s.shape,"bool")};const Oh=Ks({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=Su(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Su(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Q(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Q(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),Q(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];Q(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),Q(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=i&&Q(ie(s),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`));const h={x:o,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return Ls.runKernel(vt,h,p)}});function Mh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Co(e,uh(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Lh(e,t){let n=t;const r=qo(e.shape,t.shape);return r.length>0&&(n=Ll(n,r)),Su(n,e.shape)}function zh(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Dc(e);if("elu"===t)return hl(e);if("relu6"===t)return Oc(e);if("prelu"===t)return vc(e,n);if("leakyrelu"===t)return Cl(e,r);throw new Error(`Unknown fused activation ${t}.`)}const Bh=(e,t)=>!(e>0)||"linear"===t;const Ph=Ks({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",!1===Bh(Ls.state.gradientDepth,u)){let h=Hu(e,t,n,r,s,a,i);return null!=o&&(h=Io(h,o)),zh(h,u,l,c)}const h=js(e,"x","conv2d"),p=js(t,"filter","conv2d");let d=h,f=!1;3===h.rank&&(f=!0,d=Su(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Q(4===d.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`)),Q(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),null!=i&&Q(ie(r),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`)),Q(d.shape[3]===p.shape[2],(()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${p.shape[2]}.`)),Q(Iu(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Q("NHWC"===s,(()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`));const m=mu(d.shape,p.shape,n,a,r,i);let g,y;null!=o&&(g=js(o,"bias","fused conv2d"),[g]=Ts(g,h),Ko(m.outShape,g.shape)),null!=l&&(y=js(l,"prelu weights","fused conv2d"));const b=(e,t)=>{const[s,i,o,l]=t,c=Mh(e,o,u);Q(ku(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const h=[Ku(i.shape,c,s,n,r),Oh(i,c,s.shape,n,r)];if(null!=l){const e=Lh(l,c);h.push(e)}return h},x={x:d,filter:p,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){return Oo(((e,t,n)=>{let r=Ls.runKernel(Pr,x,w);return n([t,e,r]),f&&(r=Su(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(d,p)}return Oo(((e,t,n,r)=>{let s=Ls.runKernel(Pr,x,w);return r([t,e,s,n]),f&&(s=Su(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}}))(d,p,g)}});const Vh=Ks({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=Su(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Su(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:u},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return Ls.runKernel(Ft,l,c)}});const Wh=Ks({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,u=!1;3===t.rank&&(u=!0,o=Su(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=Ls.runKernel(Dt,l,c);return u?Su(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Uh=Ks({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Bh(Ls.state.gradientDepth,u)){let h=sl(e,t,n,r,s,a,i);return null!=o&&(h=Io(h,o)),zh(h,u,l,c)}const h=js(e,"x","depthwiseConv2d"),p=js(t,"filter","depthwiseConv2d");let d=h,f=!1;3===h.rank&&(f=!0,d=Su(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Q(4===d.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`)),Q(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),Q(d.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==a&&(a=[1,1]),Q(Iu(n,a),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),null!=i&&Q(ie(r),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`));const m=mu(d.shape,p.shape,n,a,r,i,!0);let g,y;null!=o&&(g=js(o,"bias","fused conv2d"),[g]=Ts(g,h),Ko(m.outShape,g.shape)),null!=l&&(y=js(l,"prelu weights","fused depthwiseConv2d"));const b=(e,t)=>{Q(ku(a),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[s,o,l,c]=t,h=Mh(e,l,u),p=Wh(o.shape,h,s,n,r,a,i),d=Vh(o,h,s.shape,n,r,a,i);if(null!=c){return[p,d,Lh(g,h)]}return[p,d]},x={x:d,filter:p,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){return Oo(((e,t,n)=>{let r=Ls.runKernel(Vr,x,w);return n([t,e,r]),f&&(r=Su(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(d,p)}return Oo(((e,t,n,r)=>{let s=Ls.runKernel(Vr,x,w);return r([t,e,s,n]),f&&(s=Su(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}}))(d,p,g)}});const Gh=Ks({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o}){if(!1===Bh(Ls.state.gradientDepth,a)){let u=pi(e,t,n,r);return null!=s&&(u=Io(u,s)),zh(u,a,i,o)}let u=js(e,"a","fused matMul"),l=js(t,"b","fused matMul");[u,l]=Ts(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=re(f),y=re(m);Q(u.rank>=2&&l.rank>=2&&u.rank===l.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`)),Q(ae(f,m),(()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`)),Q(c===h,(()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=u.shape.slice(0,-2).concat([p,d]),x=Su(u,n?[g,c,p]:[g,p,c]),w=Su(l,r?[y,d,h]:[y,h,d]);let v,k;null!=s&&(v=js(s,"bias","fused matMul"),[v]=Ts(v,u),Ko(b,v.shape)),null!=i&&(k=js(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[i,o,u,l]=t,c=Mh(Su(e,u.shape),u,a);let h,p;if(n||r?!n&&r?(h=pi(c,o,!1,!1),p=pi(c,i,!0,!1)):n&&!r?(h=pi(o,c,!1,!0),p=pi(i,c,!1,!1)):(h=pi(o,c,!0,!0),p=pi(c,i,!0,!0)):(h=pi(c,o,!1,!0),p=pi(i,c,!0,!1)),null!=s){return[h,p,Lh(l,c)]}return[h,p]},N={a:x,b:w,bias:v,preluActivationWeights:k},S={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){return Oo(((e,t,n)=>{const r=Ls.runKernel(Br,N,S);return n([e,t,r]),{value:Su(r,b),gradFunc:I}}))(x,w)}return Oo(((e,t,n,r)=>{const s=Ls.runKernel(Br,N,S);return r([e,t,s,n]),{value:Su(s,b),gradFunc:I}}))(x,w,v)}});const jh=Ks({hammingWindow_:function(e){return Fh(e,.54,.46)}});const Hh=Ks({hannWindow_:function(e){return Fh(e,.5,.5)}});const qh=Ks({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(Au(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Tu([Au(e,a,t-r),Po([r],s)]);i.push(o),a+=n}return 0===i.length?ph([],[0,t]):Su(Tu(i),[i.length,t])}});const Kh=Ks({stft_:function(e,t,n,r,s=Hh){null==r&&(r=_h(t));const a=qh(e,t,n),i=Co(a,s(t)),o=[];for(let e=0;e<a.shape[0];e++)o.push(sh(Au(i,[e,0],[1,t]),r));return Tu(o)}});const Xh=Ks({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=js(e,"image","cropAndResize"),o=js(t,"boxes","cropAndResize","float32"),u=js(n,"boxInd","cropAndResize","int32"),l=o.shape[0];Q(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Q(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`)),Q(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`)),Q(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Q(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Q("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return Ls.runKernel($t,c,h)}});const Yh=Ks({flipLeftRight_:function(e){const t=js(e,"image","flipLeftRight","float32");Q(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Ls.runKernel(Xt,n,{})}});const Jh=Ks({rotateWithOffset_:function(e,t,n=0,r=.5){const s=js(e,"image","rotateWithOffset","float32");Q(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return Ls.runKernel(zr,a,i)}});function Zh(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Q(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Q(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Q(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Q(1===t.rank,(()=>"scores must be a 1D tensor")),Q(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Q(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Qh=Ks({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=js(e,"boxes","nonMaxSuppression"),i=js(t,"scores","nonMaxSuppression"),o=Zh(a,i,n,r,s),u={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return Ls.runKernel(zn,{boxes:a,scores:i},u)}});function ep(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||tp)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function tp(e,t){return e>t?1:e<t?-1:0}function np(e,t,n,r,s){return ap(e,t,n,r,s,0)}function rp(e,t,n,r,s,a){return ap(e,t,n,r,s,0,!1,a,!0)}function sp(e,t,n,r,s,a){return ap(e,t,n,r,s,a,!0)}function ap(e,t,n,r,s,a,i=!1,o=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>s&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(up);const c=a>0?-.5/a:0,h=[],p=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let n=h.length-1;n>=i;--n){const i=ip(e,a,h[n]);if(i>=r){o=!0;break}if(t.score=t.score*op(r,c,i),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),p.push(t.score)):t.score>s&&ep(l,t,up))}const d=h.length,f=n-d;o&&f>0&&(h.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=p),u&&(m.validOutputs=d),m}function ip(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(o-a)*(u-i),f=(h-l)*(p-c);if(d<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,c),y=Math.min(o,h),b=Math.min(u,p),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(d+f-x)}function op(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function up(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const lp=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=js(e,"boxes","nonMaxSuppressionAsync"),i=js(t,"scores","nonMaxSuppressionAsync"),o=Zh(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=np(l,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),hh(h,"int32")};const cp=Ks({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=js(e,"boxes","nonMaxSuppression"),o=js(t,"scores","nonMaxSuppression"),u=Zh(i,o,n,r,s,a),l={boxes:i,scores:o},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma},h=Ls.runKernel(Pn,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}});const hp=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=js(e,"boxes","nonMaxSuppressionAsync"),o=js(t,"scores","nonMaxSuppressionAsync"),u=Zh(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:d}=sp(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:hh(p,"int32"),selectedScores:hh(d)}};const pp=Ks({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=js(e,"boxes","nonMaxSuppression"),o=js(t,"scores","nonMaxSuppression"),u=Zh(i,o,n,r,s,null),l={boxes:i,scores:o},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a},h=Ls.runKernel(Bn,l,c);return{selectedIndices:h[0],validOutputs:h[1]}}});const dp=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=js(e,"boxes","nonMaxSuppressionAsync"),o=js(t,"scores","nonMaxSuppressionAsync"),u=Zh(i,o,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,d]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=rp(p,d,l,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:hh(f,"int32"),validOutputs:Lo(m,"int32")}};const fp=Ks({resizeBilinear_:function(e,t,n=!1,r=!1){const s=js(e,"images","resizeBilinear");Q(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Q(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Q(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Su(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=Ls.runKernel(nr,o,u);return i?Su(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const mp=Ks({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=js(e,"images","resizeNearestNeighbor");Q(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Q(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Q("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Q(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Su(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=Ls.runKernel(er,o,u);return i?Su(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const gp=Ks({bandPart_:function(e,t,n){Q(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Q(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=js(e,"a","bandPart");Q(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);if(!(t<=a))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=a),n<0&&(n=i);const o=Su(Rc(0,a,1,"int32"),[-1,1]),u=Rc(0,i,1,"int32"),l=Uo(o,u),c=Kl(Tl(l,Lo(+t,"int32")),vl(l,Lo(-n,"int32"))),h=cc([a,i],r.dtype);return Su(oh(wh(Su(r,[-1,a,i])).map((e=>ul(c,e,h)))),s)}});const yp=Ks({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Q(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Q(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=rh(e,e.shape[0],0).map((e=>ih(e,[0])));Q(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(Ls.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=Co(Ll(Co(n[r],e)),n[r]);e=Uo(e,t)}return So(e,Ch(e,"euclidean"))})));return t?oh(n,0):n}});function bp(e,t=!1){return Ls.tidy((()=>{Q(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=yl(n),a=qa(e);const i=ph([[1]],[1,1]);let o=qa(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=a,u=o,l=s;[o,a,s]=Ls.tidy((()=>{const t=Au(a,[e,e],[n-e,1]),u=Ch(t),l=Au(a,[e,e],[1,1]),c=ul(wl(l,0),ph([[-1]]),ph([[1]])),h=Uo(l,Co(c,u)),p=So(t,h);o=1===p.shape[0]?qa(i):Tu([i,Au(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const d=Fl(So(pi(c,h),u)),f=Au(a,[e,0],[n-e,r]),m=Co(d,o),g=fi(o);if(0===e)a=Uo(f,pi(m,pi(g,f)));else{const t=Uo(f,pi(m,pi(g,f)));a=Tu([Au(a,[0,0],[e,r]),t],0)}const y=fi(m),b=Au(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Uo(b,pi(pi(b,o),y));else{const t=Uo(b,pi(pi(b,o),y));s=Tu([Au(s,[0,0],[n,e]),t],1)}return[o,a,s]})),co([t,u,l])}return!t&&n>r&&(s=Au(s,[0,0],[n,r]),a=Au(a,[0,0],[r,r])),[s,a]}))}const xp=Ks({qr_:function(e,t=!1){if(Q(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return bp(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=wh(Su(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=bp(e,t);s.push(n),a.push(r)}));return[Su(oh(s,0),e.shape),Su(oh(a,0),e.shape)]}}});var wp;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(wp||(wp={}));const vp=Ks({computeWeightedLoss_:function(e,t,n=wp.SUM_BY_NONZERO_WEIGHTS){const r=js(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=js(t,"weights","computeWeightedLoss"));const a=null==s?r:Co(r,s);if(n===wp.NONE)return a;if(n===wp.SUM)return Ll(a);if(n===wp.MEAN){if(null==s)return tc(a);{const e=r.size/s.size,t=So(Ll(a),Ll(s));return e>1?So(t,Lo(e)):t}}if(n===wp.SUM_BY_NONZERO_WEIGHTS){if(null==s)return So(Ll(a),Lo(r.size));{const e=Co(s,hc(r.shape)),t=Ha(Ll(lc(e,Lo(0))),"float32");return So(Ll(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const kp=Ks({absoluteDifference_:function(e,t,n,r=wp.SUM_BY_NONZERO_WEIGHTS){const s=js(e,"labels","absoluteDifference"),a=js(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=js(n,"weights","absoluteDifference")),ee(s.shape,a.shape,"Error in absoluteDifference: ");const o=jo(Uo(s,a));return vp(o,i,r)}});const Ip=Ks({cosineDistance_:function(e,t,n,r,s=wp.SUM_BY_NONZERO_WEIGHTS){const a=js(e,"labels","cosineDistance"),i=js(t,"predictions","cosineDistance");let o=null;null!=r&&(o=js(r,"weights","cosineDistance")),ee(a.shape,i.shape,"Error in cosineDistance: ");const u=Lo(1),l=Uo(u,Ll(Co(a,i),n,!0));return vp(l,o,s)}});const Np=Ks({hingeLoss_:function(e,t,n,r=wp.SUM_BY_NONZERO_WEIGHTS){let s=js(e,"labels","hingeLoss");const a=js(t,"predictions","hingeLoss");let i=null;null!=n&&(i=js(n,"weights","hingeLoss")),ee(s.shape,a.shape,"Error in hingeLoss: ");const o=Lo(1);s=Uo(Co(Lo(2),s),o);const u=Dc(Uo(o,Co(s,a)));return vp(u,i,r)}});const Sp=Ks({huberLoss_:function(e,t,n,r=1,s=wp.SUM_BY_NONZERO_WEIGHTS){const a=js(e,"labels","huberLoss"),i=js(t,"predictions","huberLoss");let o=null;null!=n&&(o=js(n,"weights","huberLoss")),ee(a.shape,i.shape,"Error in huberLoss: ");const u=Lo(r),l=jo(Uo(i,a)),c=rc(l,u),h=Uo(l,c),p=Io(Co(Lo(.5),To(c)),Co(u,h));return vp(p,o,s)}});const Cp=Ks({logLoss_:function(e,t,n,r=1e-7,s=wp.SUM_BY_NONZERO_WEIGHTS){const a=js(e,"labels","logLoss"),i=js(t,"predictions","logLoss");let o=null;null!=n&&(o=js(n,"weights","logLoss")),ee(a.shape,i.shape,"Error in logLoss: ");const u=Lo(1),l=Lo(r),c=Fl(Co(a,Rl(Io(i,l)))),h=Co(Uo(u,a),Rl(Io(Uo(u,i),l))),p=Uo(c,h);return vp(p,o,s)}});const Ep=Ks({meanSquaredError_:function(e,t,n,r=wp.SUM_BY_NONZERO_WEIGHTS){const s=js(e,"labels","meanSquaredError"),a=js(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=js(n,"weights","meanSquaredError")),ee(s.shape,a.shape,"Error in meanSquaredError: ");const o=ah(s,a);return vp(o,i,r)}});const Tp=Ks({sigmoidCrossEntropy_:function(e,t,n,r=0,s=wp.SUM_BY_NONZERO_WEIGHTS){let a=js(e,"multiClassLabels","sigmoidCrossEntropy");const i=js(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=js(n,"weights","sigmoidCrossEntropy")),ee(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Lo(r),t=Lo(1),n=Lo(.5);a=Io(Co(a,Uo(t,e)),Co(n,e))}const u=function(e,t){const n=js(e,"labels","sigmoidCrossEntropyWithLogits"),r=js(t,"logits","sigmoidCrossEntropyWithLogits");ee(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Dc(r),a=Co(r,n),i=_l(dl(Fl(jo(r))));return Io(Uo(s,a),i)}(a,i);return vp(u,o,s)}});const $p=Ks({softmaxCrossEntropy_:function(e,t,n,r=0,s=wp.SUM_BY_NONZERO_WEIGHTS){let a=js(e,"onehotLabels","softmaxCrossEntropy");const i=js(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=js(n,"weights","softmaxCrossEntropy")),ee(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Lo(r),t=Lo(1),n=Lo(a.shape[1]);a=Io(Co(a,Uo(t,e)),So(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Oo(((e,t,r)=>{const s=ql(t,[n],!0),a=Uo(Ha(t,"float32"),s);r([e,a]);const i=Fl(Co(a,e));return{value:Ll(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=Wl(e.shape,[n]);return[Co(Su(e,a),Uo(Ha(r,"float32"),dl(s))),Co(Su(e,a),Uo(dl(s),Ha(r,"float32")))]}}}))(e,t)}(a,i);return vp(u,o,s)}}),Ap={fft:eh,ifft:th,rfft:sh,irfft:nh},Rp={hammingWindow:jh,hannWindow:Hh,frame:qh,stft:Kh},_p={flipLeftRight:Yh,resizeNearestNeighbor:mp,resizeBilinear:fp,rotateWithOffset:Jh,cropAndResize:Xh,nonMaxSuppression:Qh,nonMaxSuppressionAsync:lp,nonMaxSuppressionWithScore:cp,nonMaxSuppressionWithScoreAsync:hp,nonMaxSuppressionPadded:pp,nonMaxSuppressionPaddedAsync:dp},Fp={bandPart:gp,gramSchmidt:yp,qr:xp},Dp={absoluteDifference:kp,computeWeightedLoss:vp,cosineDistance:Ip,hingeLoss:Np,huberLoss:Sp,logLoss:Cp,meanSquaredError:Ep,sigmoidCrossEntropy:Tp,softmaxCrossEntropy:$p};class Op{static sgd(e){return new Jo(e)}static momentum(e,t,n=!1){return new Zo(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Qo(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Go(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Bo(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Yo(e,t,n,r,s)}static adagrad(e,t=.1){return new Vo(e,t)}}const Mp={sgd:Op.sgd,momentum:Op.momentum,adadelta:Op.adadelta,adagrad:Op.adagrad,rmsprop:Op.rmsprop,adamax:Op.adamax,adam:Op.adam},Lp="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function zp(){return new Promise((e=>Lp((()=>e()))))}function Bp(e,t){const n=e[0].length;e.forEach(((e,t)=>{Q(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Q(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)Q(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function Pp(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}const Vp=30;function Wp(e){return e<=Vp?e:Te(e,Math.floor(Math.sqrt(e)))}function Up(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Gp(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function jp(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function Hp(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function qp(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Kp(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}const Xp=1.7580993408473768,Yp=1.0507009873554805,Jp=.3275911,Zp=.254829592,Qp=-.284496736,ed=1.421413741,td=-1.453152027,nd=1.061405429;function rd(...e){Ve().getBool("IS_TEST")||console.warn(...e)}function sd(...e){Ve().getBool("IS_TEST")||console.log(...e)}function ad(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function id(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function od(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function ud(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function ld(e,t){return{real:e[2*t],imag:e[2*t+1]}}function cd(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function hd(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function pd(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}function dd(e,t,n=0){let r=[];if("number"==typeof t)Q(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{Q(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Q(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function fd(e,t){let n,r=!1;for(e<=Vp?(n=e,r=!0):n=Te(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Te(e,n+1);return n}function md(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function gd(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let u=1,l=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),u*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:o}}function yd(e){try{return e.map((e=>ps(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function bd(e){return e.map((e=>hs(e)))}const xd={kernelName:He,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,uh(Ha(n,"float32"),-1))}}},wd={kernelName:qe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=To(Ha(n,"float32")),r=Eo(Uo(Lo(1),t));return Fl(So(e,r))}}}},vd={kernelName:Ke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Eo(Uo(To(Ha(n,"float32")),1));return So(e,t)}}}},kd={kernelName:Xe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{let t=e;const r=qo(n.shape,s);return r.length>0&&(t=Ll(t,r)),Su(t,n.shape)},b:()=>{let t=e;const n=qo(r.shape,s);return n.length>0&&(t=Ll(t,n)),Su(t,r.shape)}}}},Id={kernelName:Ye,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Nd={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$o(n)}}},Sd={kernelName:et,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$o(n)}}},Cd={kernelName:tt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Eo(Uo(Lo(1),To(Ha(n,"float32")))))}}},Ed={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Eo(Io(Lo(1),To(Ha(n,"float32"))));return So(e,t)}}}},Td={kernelName:at,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{const t=Io(To(n),To(r));let a=Co(e,So(r,t));const i=qo(n.shape,s);return i.length>0&&(a=Ll(a,i)),Su(a,n.shape)},b:()=>{const t=Io(To(n),To(r));let a=Fl(Co(e,So(n,t)));const i=qo(r.shape,s);return i.length>0&&(a=Ll(a,i)),Su(a,r.shape)}}}},$d={kernelName:rt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Io(To(Ha(n,"float32")),1))}}},Ad={kernelName:st,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Uo(Lo(1),To(Ha(n,"float32"))))}}};const Rd=Ks({avgPool3dGrad_:function(e,t,n,r,s,a){const i=js(e,"dy","avgPool3dGrad"),o=js(t,"input","avgPool3dGrad");let u=i,l=o,c=!1;4===o.rank&&(c=!0,u=Su(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=Su(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(5===u.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),Q(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),null!=a&&Q(ie(s),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`));const h={dy:u,input:l},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},d=Ls.runKernel(lt,h,p);return c?Su(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),_d={kernelName:ut,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>Rd(e,r,s,a,i,o)}}};const Fd=Ks({avgPoolGrad_:function(e,t,n,r,s){const a=js(e,"dy","avgPoolGrad"),i=js(t,"input","avgPoolGrad");Q(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,u=a,l=!1;3===i.rank&&(l=!0,o=Su(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=Su(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(4===u.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)),Q(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:u,input:o},h={filterSize:n,strides:r,pad:s},p=Ls.runKernel(ot,c,h);return l?Su(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Dd={kernelName:it,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Fd(e,r,s,a,i)}}},Od={kernelName:ct,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>pi(e,s,!1,!1),b:()=>pi(e,r,!0,!1)}:a&&!i?{a:()=>pi(s,e,!1,!0),b:()=>pi(r,e,!1,!1)}:{a:()=>pi(s,e,!0,!0),b:()=>pi(e,r,!0,!0)}:{a:()=>pi(e,s,!1,!0),b:()=>pi(r,e,!0,!1)}}},Md={kernelName:ht,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>xc(e,r,s)}}},Ld={kernelName:dt,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>Ll(e,o,!0)}}},zd={kernelName:ft,gradFunc:e=>({x:()=>e.clone()})},Bd={kernelName:mt,gradFunc:e=>({x:()=>$o(e)})},Pd={kernelName:gt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>ul(Kl(vl(r,s),Tl(r,a)),e,$o(e))}}},Vd={kernelName:bt,inputsToSave:["x"],gradFunc:xd.gradFunc},Wd={kernelName:xt,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=de(s,t[0].shape)[0],i=r.map((e=>e[a]));return rh(e,i,a).map((e=>()=>e))}},Ud={kernelName:wt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return Q(ku(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>Ku(r.shape,e,s,i,o,u),filter:()=>Oh(r,e,s.shape,i,o,u)}}},Gd={kernelName:kt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Hu(e,s,a,i,o,1,u),filter:()=>Oh(e,r,s.shape,a,i,o,u)}}};const jd=Ks({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Su(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Su(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Q(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),Q(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Q(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Q(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),Q(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},u={strides:r,pad:s,filterShape:n};return Ls.runKernel(Nt,o,u)}}),Hd={kernelName:It,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Q(ku(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>Ju(i.shape,e,o,s,a),filter:()=>jd(i,e,o.shape,s,a)}}},qd={kernelName:Ct,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(Fl(qc(Ha(n,"float32"))),e)}}},Kd={kernelName:Et,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(Kc(Ha(n,"float32")),e)}}},Xd={kernelName:Tt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Gl([s],r.rank);let n=tl(e,s,a,!i);return null!=t&&(n=fi(n,t)),n}}}},Yd={kernelName:_t,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Q(ku(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[u,l]=t;return Q(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),Q(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),Q(u.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Q(Iu(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),null!=i&&Q(ie(a),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`)),{x:()=>Wh(u.shape,e,l,s,a,r,i),filter:()=>Vh(u,e,l.shape,s,a,r,i)}}},Jd={kernelName:Mt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>Ls.runKernel(Lt,a,n),filter:()=>Ls.runKernel(zt,i,n)}}},Zd={kernelName:Pt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Ls.runKernel(Vt,r)}}},Qd={kernelName:Wt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Co(dl(Fl(To(n))),2/Math.sqrt(Math.PI));return{x:()=>Co(e,r)}}},ef={kernelName:Gt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,n)}}},tf={kernelName:jt,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Su(e,n.shape)}}},nf={kernelName:Ht,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,dl(n))}}},rf={kernelName:Yt,gradFunc:e=>({x:()=>$o(e)})},sf={kernelName:Jt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{const t=So(e,Ha(r,"float32")),a=qo(n.shape,s);return a.length>0?Su(Ll(t,a),n.shape):t},b:()=>{let t=Co(e,Ha(n,"float32"));const a=qo(r.shape,s);a.length>0&&(t=Su(Ll(t,a),r.shape));const i=To(r);return Fl(So(t,Ha(i,"float32")))}}}},af={kernelName:Zt,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,u=null==o?Lo(1):o,l=qo(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=Uo(s,a),p=Co(e,u),d=Wc(Io(i,Lo(r))),f=Co(Co(Co(d,d),d),Lo(-.5));return{x:()=>1===a.rank?Su(Co(Co(e,gl(Su(d,[1,1,1,a.shape[0]]),c)),u),s.shape):Su(Co(Co(e,d),u),s.shape),mean:()=>{let e=Co(Co(d,Lo(-1)),p);return 1===a.rank&&(e=Ll(e,l)),Su(e,a.shape)},variance:()=>{let e=Co(Co(f,h),p);return 1===a.rank&&(e=Ll(e,l)),Su(e,a.shape)},scale:()=>{const t=Co(h,d);let n=Co(e,t);return 1===a.rank&&(n=Ll(n,l)),Su(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Ll(t,l)),Su(t,a.shape)}}}},of={kernelName:Qt,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a}=n,i=de(a,r.shape)[0];return{x:()=>{const t=r.shape,n=s.size,o=t.slice(0,i),u=o.length,l=t.slice(a,t.length).slice(1),c=l.length,h=uf(0,u),p=uf(u+1,u+1+c),d=lf([o,[n],l]),f=Su(e,d),m=Su(s,[n]),g=lf([[u],h,p]),y=fi(f,g);let b=xh(y,m,r.shape[i]);const x=jl(g);return b=fi(b,x),b},indices:()=>s}}};function uf(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function lf(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const cf={kernelName:nn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>$o(n),b:()=>$o(r)}}},hf={kernelName:rn,gradFunc:e=>({x:()=>Ha(e,"float32")})},pf={kernelName:on,gradFunc:e=>({x:()=>$o(e)})},df={kernelName:un,gradFunc:e=>({x:()=>$o(e)})},ff={kernelName:ln,gradFunc:e=>({x:()=>$o(e)})},mf={kernelName:cn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=wl(r,0);return{x:()=>ul(a,e,Co(e,s))}}},gf={kernelName:mn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Io(n,1))}}},yf={kernelName:fn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Ha(n,"float32"))}}},bf={kernelName:xn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=dl(r);return Uo(e,Co(Ll(e,s,!0),t))}}}};const xf=Ks({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:i};return Ls.runKernel(vn,o,u)}}),wf={kernelName:wn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>xf(r,s,e,a,i,o,u)}}};function vf(e,t,n,r){return t.rank<n.rank&&(t=Su(t,Wl(t.shape,r))),e.rank<n.rank&&(e=Su(e,Wl(e.shape,r))),{x:()=>Co(e,Ha(ol(n,t),e.dtype))}}const kf={kernelName:kn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=vf(e,t[1],a,de(s,a.shape));return{x:()=>i.x()}}},If={kernelName:In,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Co(e,Ha(vl(n,r),"float32")),b:()=>Co(e,Ha(El(n,r),"float32"))}}};const Nf=Ks({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=js(e,"dy","maxPool3dGrad"),u=js(t,"input","maxPool3dGrad"),l=js(n,"output","maxPool3dGrad");let c=o,h=u,p=l,d=!1;4===u.rank&&(d=!0,c=Su(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Su(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=Su(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Q(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Q(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),Q(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),null!=i&&Q(ie(a),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`));const f={dy:c,input:h,output:p},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=Ls.runKernel(En,f,m);return d?Su(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Sf={kernelName:Cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>Nf(e,r,s,a,i,o,u)}}};const Cf=Ks({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=js(e,"dy","maxPoolGrad"),u=js(t,"input","maxPoolGrad"),l=js(n,"output","maxPoolGrad");Q(u.rank===o.rank,(()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`)),Q(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Q(4===u.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)),null!=i&&Q(ie(a),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`));const c={dy:o,input:u,output:l},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return Ls.runKernel(Sn,c,h)}}),Ef={kernelName:Gn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Au(e,a,r.shape)}}},Tf={kernelName:xr,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Fu(e,r,s)}}},$f={kernelName:wr,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Tu(e,r)}}};const Af=[xd,wd,vd,kd,Id,Nd,Sd,Cd,Ed,Td,$d,Ad,_d,Dd,Od,Md,Ld,zd,Bd,Pd,Vd,Wd,Gd,Ud,Hd,qd,Kd,Xd,Yd,Jd,{kernelName:Bt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{const t=So(e,Ha(r,"float32")),a=qo(n.shape,s);return a.length>0?Su(Ll(t,a),n.shape):t},b:()=>{let t=Co(e,Ha(n,"float32"));const a=qo(r.shape,s);a.length>0&&(t=Su(Ll(t,a),r.shape));const i=To(r);return Fl(So(t,Ha(i,"float32")))}}}},Zd,Qd,ef,tf,nf,sf,rf,af,of,cf,hf,pf,df,ff,mf,gf,yf,bf,wf,kf,kf,If,Sf,{kernelName:Nn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>Cf(e,r,s,a,i,o)}}},{kernelName:$n,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=de(s,r.shape),i=re(Vl(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Su(e,t);return So(Co(n,hc(r.shape,"float32")),i)}}}},{kernelName:An,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=vf(e,i,a,de(s,a.shape));return{x:()=>o.x()}}},{kernelName:Rn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Co(e,Ha(Tl(n,r),"float32")),b:()=>Co(e,Ha(wl(n,r),"float32"))}}},{kernelName:_n,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Au(e,a,r.shape)}}},{kernelName:Fn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{const t=qo(n.shape,s);return t.length>0?Su(Ll(e,t),n.shape):e},b:()=>{const t=Co(e,Fl(bl(So(n,r)))),a=qo(r.shape,s);return a.length>0?Su(Ll(t,a),r.shape):t}}}},{kernelName:On,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{const t=Co(e,Ha(r,"float32")),a=qo(n.shape,s);return a.length>0?Su(Ll(t,a),n.shape):t},b:()=>{const t=Co(e,Ha(n,"float32")),a=qo(r.shape,s);return a.length>0?Su(Ll(t,a),r.shape):t}}}},{kernelName:Mn,gradFunc:e=>({x:()=>Fl(e)})},{kernelName:Wn,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>cc(n.shape,"float32")}}},{kernelName:Vn,gradFunc:e=>({x:()=>$o(e)})},{kernelName:Un,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return wh(e,r).map((e=>()=>e))}},Ef,Ef,{kernelName:Hn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Ko(a.shape,i.shape);return{a:()=>{const t=Ha(i,"float32");let n=Co(e,Co(t,Wo(a,Uo(t,Lo(1)))));const r=qo(a.shape,o);return r.length>0&&(n=Ll(n,r)),Su(n,a.shape)},b:()=>{const t=wl(a,0),n=ul(t,Rl(a),$o(a));let r=Co(e,Co(s,n));const u=qo(i.shape,o);return u.length>0&&(r=Ll(r,u)),Su(r,i.shape)}}}},{kernelName:qn,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=wl(n,0);return{x:()=>ul(s,e,Co(e,r)),alpha:()=>{let t=ul(s,$o(e),Co(e,n));const a=qo(r.shape,e.shape);return a.length>0&&(t=Ll(t,a)),Su(t,r.shape)}}}},{kernelName:Jn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Fl(To(n)))}}},{kernelName:sr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Co(Tl(n,6),uh(n));return{x:()=>Co(e,Ha(r,"float32"))}}},{kernelName:Zn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,Ha(uh(n),"float32"))}}},{kernelName:Qn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Su(e,n.shape)}}},{kernelName:nr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Ls.runKernel(rr,s,n)}}},{kernelName:er,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Ls.runKernel(tr,s,n)}}},{kernelName:ar,gradFunc:(e,t,n)=>{const{dims:r}=n,s=de(r,e.shape);return{x:()=>Mc(e,s)}}},{kernelName:ir,gradFunc:e=>({x:()=>$o(e)})},{kernelName:or,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Fl(So(e,Co(Wo(n,1.5),2)))}}},{kernelName:lr,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Ha($o(n),"float32"),t:()=>Co(e,Ha(n,e.dtype)),e:()=>Co(e,Ha(Xl(n),e.dtype))}}},{kernelName:cr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=wl(n,Lo(0)),r=Lo(Xp),s=Lo(Yp),a=Co(e,s),i=Co(Co(e,r),dl(Ha(n,"float32")));return ul(t,a,i)}}}},{kernelName:mr,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,Co(n,Uo(Lo(1),n)))}}},{kernelName:fr,gradFunc:e=>({x:()=>$o(e)})},{kernelName:pr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(Qu(Ha(n,"float32")),e)}}},{kernelName:dr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(el(Ha(n,"float32")),e)}}},{kernelName:hr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,u]=zi(r,s,a),l=[];for(let t=0;t<e.rank;t++)l.push([o[t],i[t]-o[t]-u[t]]);return{x:()=>fc(e,l)}}},{kernelName:vr,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=Co(e,r);return{logits:()=>Uo(a,Co(Ll(a,[s],true),r))}}},{kernelName:gr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,$u(n))}}},Tf,Tf,$f,$f,{kernelName:yr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,Co(Eo(Ha(n,"float32")),2))}}},{kernelName:kr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Lo(2);return{a:()=>Co(e,Co(s,Uo(n,r))),b:()=>Co(e,Co(s,Uo(r,n)))}}},{kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(e,Co(Ha(n,"float32"),2))}}},{kernelName:Mr,gradFunc:e=>({x:()=>$o(e)})},{kernelName:Nr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ko(n.shape,r.shape);return{a:()=>{let t=e;const r=qo(n.shape,s);return r.length>0&&(t=Ll(t,r)),Su(t,n.shape)},b:()=>{let t=e;const n=qo(r.shape,s);return n.length>0&&(t=Ll(t,n)),Su(Fl(t),r.shape)}}}},{kernelName:br,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;de(a,r.shape).forEach((e=>{s[e]=1}));const i=Su(e,s),o=Co(i,hc(r.shape,"float32"));return{x:()=>o}}},{kernelName:Er,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>So(e,To(Qu(n)))}}},{kernelName:Tr,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Co(Uo(Lo(1),To(n)),e)}}},{kernelName:$r,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=$o(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=Io(t,Au(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=Io(t,Au(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=Io(t,Au(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=Io(t,Au(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:Rr,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=jl(s);return{x:()=>fi(e,a)}}},{kernelName:Fr,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>oh(e,s)}}},{kernelName:Dr,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Xo(t,$o(t)),r=xl(e,n);let s=vl(t,Lo(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=fl(s,e+1);s=Kl(s,hc(r.shape,"bool"));const i=$o(r);return ul(s,r,i)}(e,n)}}},{kernelName:Or,gradFunc:e=>({x:()=>$o(e)})}];for(const e of Af)Kr(e);let Rf;function _f(){return null==Rf&&(Rf=vo().epsilon()),Rf}bs().prototype.abs=function(){return this.throwIfDisposed(),jo(this)},bs().prototype.acos=function(){return this.throwIfDisposed(),eu(this)},bs().prototype.acosh=function(){return this.throwIfDisposed(),tu(this)},bs().prototype.add=function(e){return this.throwIfDisposed(),Io(this,e)},bs().prototype.all=function(e,t){return this.throwIfDisposed(),ru(this,e,t)},bs().prototype.any=function(e,t){return this.throwIfDisposed(),su(this,e,t)},bs().prototype.argMax=function(e){return this.throwIfDisposed(),au(this,e)},bs().prototype.argMin=function(e){return this.throwIfDisposed(),iu(this,e)},bs().prototype.asScalar=function(){return this.throwIfDisposed(),Q(1===this.size,(()=>"The array must have only 1 element.")),Su(this,[])},bs().prototype.asType=function(e){return this.throwIfDisposed(),Ha(this,e)},bs().prototype.as1D=function(){return this.throwIfDisposed(),Su(this,[this.size])},bs().prototype.as2D=function(e,t){return this.throwIfDisposed(),Su(this,[e,t])},bs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Su(this,[e,t,n])},bs().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Su(this,[e,t,n,r])},bs().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Su(this,[e,t,n,r,s])},bs().prototype.asin=function(){return this.throwIfDisposed(),ou(this)},bs().prototype.asinh=function(){return this.throwIfDisposed(),uu(this)},bs().prototype.atan=function(){return this.throwIfDisposed(),lu(this)},bs().prototype.atan2=function(e){return this.throwIfDisposed(),cu(this,e)},bs().prototype.atanh=function(){return this.throwIfDisposed(),hu(this)},bs().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Cu(this,e,t,n,r)},bs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Fu(this,e,t)},bs().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Du(this,e,t,n,r,s)},bs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Bu(this,e)},bs().prototype.cast=function(e){return this.throwIfDisposed(),Ha(this,e)},bs().prototype.ceil=function(){return this.throwIfDisposed(),Pu(this)},bs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Vu(this,e,t)},bs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ys&&(e=[e]),Tu([this,...e],t)},bs().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),qu(this,e,t,n,r,s,a)},bs().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Xu(this,e,t,n,r,s)},bs().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Hu(this,e,t,n,r,s,a)},bs().prototype.cos=function(){return this.throwIfDisposed(),Qu(this)},bs().prototype.cosh=function(){return this.throwIfDisposed(),el(this)},bs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),tl(this,e,t,n)},bs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),rl(this,e,t)},bs().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),sl(this,e,t,n,r,s,a)},bs().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),il(this,e,t,n,r,s)},bs().prototype.divNoNan=function(e){return this.throwIfDisposed(),ll(this,e)},bs().prototype.div=function(e){return this.throwIfDisposed(),So(this,e)},bs().prototype.dot=function(e){return this.throwIfDisposed(),cl(this,e)},bs().prototype.elu=function(){return this.throwIfDisposed(),hl(this)},bs().prototype.equal=function(e){return this.throwIfDisposed(),ol(this,e)},bs().prototype.erf=function(){return this.throwIfDisposed(),pl(this)},bs().prototype.exp=function(){return this.throwIfDisposed(),dl(this)},bs().prototype.expandDims=function(e){return this.throwIfDisposed(),fl(this,e)},bs().prototype.expm1=function(){return this.throwIfDisposed(),ml(this)},bs().prototype.fft=function(){return this.throwIfDisposed(),eh(this)},bs().prototype.flatten=function(){return this.throwIfDisposed(),Su(this,[this.size])},bs().prototype.floor=function(){return this.throwIfDisposed(),bl(this)},bs().prototype.floorDiv=function(e){return this.throwIfDisposed(),No(this,e)},bs().prototype.gather=function(e,t){return this.throwIfDisposed(),xl(this,e,t)},bs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),vl(this,e)},bs().prototype.greater=function(e){return this.throwIfDisposed(),wl(this,e)},bs().prototype.ifft=function(){return this.throwIfDisposed(),th(this)},bs().prototype.irfft=function(){return this.throwIfDisposed(),nh(this)},bs().prototype.isFinite=function(){return this.throwIfDisposed(),Il(this)},bs().prototype.isInf=function(){return this.throwIfDisposed(),Nl(this)},bs().prototype.isNaN=function(){return this.throwIfDisposed(),Sl(this)},bs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Cl(this,e)},bs().prototype.lessEqual=function(e){return this.throwIfDisposed(),Tl(this,e)},bs().prototype.less=function(e){return this.throwIfDisposed(),El(this,e)},bs().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Al(this,e,t,n,r)},bs().prototype.logSigmoid=function(){return this.throwIfDisposed(),Ol(this)},bs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),zl(this,e)},bs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),ql(this,e,t)},bs().prototype.log=function(){return this.throwIfDisposed(),Rl(this)},bs().prototype.log1p=function(){return this.throwIfDisposed(),_l(this)},bs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Kl(this,e)},bs().prototype.logicalNot=function(){return this.throwIfDisposed(),Xl(this)},bs().prototype.logicalOr=function(e){return this.throwIfDisposed(),Yl(this,e)},bs().prototype.logicalXor=function(e){return this.throwIfDisposed(),Jl(this,e)},bs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),pi(this,e,t,n)},bs().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Zl(this,e,t,n,r)},bs().prototype.max=function(e,t){return this.throwIfDisposed(),Ml(this,e,t)},bs().prototype.maximum=function(e){return this.throwIfDisposed(),Xo(this,e)},bs().prototype.mean=function(e,t){return this.throwIfDisposed(),tc(this,e,t)},bs().prototype.min=function(e,t){return this.throwIfDisposed(),nc(this,e,t)},bs().prototype.minimum=function(e){return this.throwIfDisposed(),rc(this,e)},bs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),sc(this,e,t)},bs().prototype.mod=function(e){return this.throwIfDisposed(),ac(this,e)},bs().prototype.mul=function(e){return this.throwIfDisposed(),Co(this,e)},bs().prototype.neg=function(){return this.throwIfDisposed(),Fl(this)},bs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ch(this,e,t,n)},bs().prototype.notEqual=function(e){return this.throwIfDisposed(),lc(this,e)},bs().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),di(this,e,t,n)},bs().prototype.onesLike=function(){return this.throwIfDisposed(),pc(this)},bs().prototype.pad=function(e,t){return this.throwIfDisposed(),fc(this,e,t)},bs().prototype.pool=function(e,t,n,r,s){return this.throwIfDisposed(),wc(this,e,t,n,r,s)},bs().prototype.pow=function(e){return this.throwIfDisposed(),Wo(this,e)},bs().prototype.prelu=function(e){return this.throwIfDisposed(),vc(this,e)},bs().prototype.prod=function(e,t){return this.throwIfDisposed(),kc(this,e,t)},bs().prototype.reciprocal=function(){return this.throwIfDisposed(),Fc(this)},bs().prototype.relu=function(){return this.throwIfDisposed(),Dc(this)},bs().prototype.relu6=function(){return this.throwIfDisposed(),Oc(this)},bs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Su(this,e.shape)},bs().prototype.reshape=function(e){return this.throwIfDisposed(),Su(this,e)},bs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),fp(this,e,t,n)},bs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),mp(this,e,t,n)},bs().prototype.reverse=function(e){return this.throwIfDisposed(),Mc(this,e)},bs().prototype.rfft=function(){return this.throwIfDisposed(),sh(this)},bs().prototype.round=function(){return this.throwIfDisposed(),Vc(this)},bs().prototype.rsqrt=function(){return this.throwIfDisposed(),Wc(this)},bs().prototype.selu=function(){return this.throwIfDisposed(),Uc(this)},bs().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Gc(this,e,t,n,r,s,a)},bs().prototype.sigmoid=function(){return this.throwIfDisposed(),$u(this)},bs().prototype.sign=function(){return this.throwIfDisposed(),Hc(this)},bs().prototype.sin=function(){return this.throwIfDisposed(),qc(this)},bs().prototype.sinh=function(){return this.throwIfDisposed(),Kc(this)},bs().prototype.slice=function(e,t){return this.throwIfDisposed(),Au(this,e,t)},bs().prototype.softmax=function(e){return this.throwIfDisposed(),Qc(this,e)},bs().prototype.softplus=function(){return this.throwIfDisposed(),Dl(this)},bs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),xc(this,e,t)},bs().prototype.split=function(e,t){return this.throwIfDisposed(),rh(this,e,t)},bs().prototype.sqrt=function(){return this.throwIfDisposed(),Eo(this)},bs().prototype.square=function(){return this.throwIfDisposed(),To(this)},bs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),ah(this,e)},bs().prototype.squeeze=function(e){return this.throwIfDisposed(),ih(this,e)},bs().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof ys?[this,e]:[this,...e];return oh(n,t)},bs().prototype.step=function(e){return this.throwIfDisposed(),uh(this,e)},bs().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),lh(this,e,t,n,r,s,a,i,o)},bs().prototype.sub=function(e){return this.throwIfDisposed(),Uo(this,e)},bs().prototype.sum=function(e,t){return this.throwIfDisposed(),Ll(this,e,t)},bs().prototype.tan=function(){return this.throwIfDisposed(),ch(this)},bs().prototype.tanh=function(){return this.throwIfDisposed(),Ru(this)},bs().prototype.tile=function(e){return this.throwIfDisposed(),gl(this,e)},bs().prototype.toBool=function(){return this.throwIfDisposed(),Ha(this,"bool")},bs().prototype.toFloat=function(){return this.throwIfDisposed(),Ha(this,"float32")},bs().prototype.toInt=function(){return this.throwIfDisposed(),Ha(this,"int32")},bs().prototype.topk=function(e,t){return this.throwIfDisposed(),gh(this,e,t)},bs().prototype.transpose=function(e){return this.throwIfDisposed(),fi(this,e)},bs().prototype.unique=function(e){return this.throwIfDisposed(),bh(this,e)},bs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),xh(this,e,t)},bs().prototype.unstack=function(e){return this.throwIfDisposed(),wh(this,e)},bs().prototype.where=function(e,t){return this.throwIfDisposed(),ul(e,this,t)},bs().prototype.zerosLike=function(){return this.throwIfDisposed(),$o(this)};class Ff extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ff.prototype)}}class Df extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Df.prototype)}}class Of extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Of.prototype)}}class Mf extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Mf.prototype)}}class Lf extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Lf.prototype)}}Error;function zf(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Bf(e,t){if(!e)throw new Lf(t)}function Pf(e,t){let n=0;for(const r of e)r===t&&n++;return n}function Vf(e){return 1===e.length?e[0]:e}function Wf(e){return Array.isArray(e)?e:[e]}function Uf(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Gf(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let jf={};function Hf(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function qf(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>qf(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?qf(t):e[n]=t.value)}}}function Kf(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in jf)a=jf[s];else if(a=t[s],null==a)throw new Of(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new Of(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,u;if(i in n?[o,u]=n[i]:i in jf?[o,u]=jf.className:i in t&&([o,u]=t[i]),null==o)throw new Of(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const t of Object.keys(jf))e[t]=jf[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},jf);for(const e of Object.keys(n))jf[e]=n[e];qf(a.config);const r=u(o,a.config,n,s);return jf=Object.assign({},t),r}{const e=Object.assign({},jf);for(const e of Object.keys(n))jf[e]=n[e];const t=new o(a.config);return jf=Object.assign({},e),t}}}function Xf(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Yf(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Jf(e){if(null==e)throw new Of(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Zf(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Of(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Qf(e,t,n=0,r=1/0){return Bf(n>=0),Bf(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function em(e,t){Array.isArray(e)?(Q(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>em(e,`element ${n+1} of ${t}`)))):Q(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${tm(e)}.`))}function tm(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>tm(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function nm(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function rm(e,t){return lo((()=>Eo(Ll(Co(e,e),t,!0))))}class sm extends Pi{getConfig(){return{}}}class am extends sm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lo((()=>{const t=rm(e,this.axis),n=Vu(t,0,this.maxValue);return Co(e,So(n,Io(_f(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}am.className="MaxNorm",Wi(am);class im extends sm{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lo((()=>So(e,Io(_f(),rm(e,this.axis)))))}getConfig(){return{axis:this.axis}}}im.className="UnitNorm",Wi(im);class om extends sm{apply(e){return Dc(e)}}om.className="NonNeg",Wi(om);class um extends sm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lo((()=>{const t=rm(e,this.axis),n=Io(Co(this.rate,Vu(t,this.minValue,this.maxValue)),Co(1-this.rate,t));return Co(e,So(n,Io(_f(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}um.className="MinMaxNorm",Wi(um);const lm={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function cm(e){return Hf(e)}function hm(e,t={}){return Kf(e,Vi.getMap().classNameMap,t,"constraint")}function pm(e){if(null==e)return null;if("string"==typeof e){return hm({className:e in lm?lm[e]:e,config:{}})}return e instanceof sm?e:hm(e)}function dm(e){return new am(e)}function fm(e){return new im(e)}function mm(){return new om}function gm(e){return new um(e)}const ym=["channelsFirst","channelsLast"],bm=["nearest","bilinear"],xm=["valid","same","causal"],wm=["max","avg"],vm=["sum","mul","concat","ave"],km=new Map;function Im(e){Zf(ym,"DataFormat",e)}function Nm(e){Zf(xm,"PaddingMode",e)}function Sm(e){Zf(wm,"PoolMode",e)}const Cm=[];function Em(e,t){Cm.push(e);try{const e=t();return Cm.pop(),e}catch(e){throw Cm.pop(),e}}function Tm(e){if(!Rm(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Cm.length?"":Cm.join("/")+"/")+e}function $m(e){if(!Rm(e))throw new Error("Not a valid tensor name: '"+e+"'");km.has(e)||km.set(e,0);const t=km.get(e);if(km.set(e,km.get(e)+1),t>0){const n=`${e}_${t}`;return km.set(n,1),n}return e}const Am=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Rm(e){return!!e.match(Am)}function _m(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Fm(e){return hh(e=Array.isArray(e)?new Float32Array(e):e)}function Dm(e){return nc(Fm(e)).dataSync()[0]}function Om(e){return Ml(Fm(e)).dataSync()[0]}function Mm(e,t){if(t<e)throw new Of(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Lm(e,t){return e.asType(t)}function zm(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function Bm(e,t,n){return lo((()=>{switch(e.rank){case 1:return Xc(e,t,n);case 2:return Yc(e,[t,0],[n,e.shape[1]]);case 3:return Jc(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Zc(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Au(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Au(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Of(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Pm(e,t,n){return lo((()=>{switch(e.rank){case 1:return Xc(e,t,n);case 2:return Yc(e,[0,t],[e.shape[0],n]);case 3:return Jc(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Zc(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Of(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Vm(e,t,n,r){return lo((()=>{switch(e.rank){case 1:return Xc(e,t,n);case 2:switch(r){case 1:return Bm(e,t,n);case 2:return Pm(e,t,n);default:throw new Of(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Bm(e,t,n);case 2:return Jc(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Pm(e,t,n);default:throw new Of(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Bm(e,t,n);case 2:return Zc(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Zc(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Pm(e,t,n);default:throw new Of(`The axis is not within the rank of the tensor ${r}`)}default:throw new Of(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Wm(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Tu(e,t)}function Um(e,t){switch(e.rank){case 1:return Wu([e,t]);case 2:return Uu([e,t],0);case 3:return Gu([e,t],0);case 4:return ju([e,t],0);default:throw new Of(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Gm(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Of(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return gl(e,t)}function jm(e,t=0,n=1,r,s){return $c(e,t,n,r,s)}function Hm(e,t,n,r){if(e.rank<2||t.rank<2)throw new Mf(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Mf(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return Gh({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Xm(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=e.reshape([-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),l=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=t.transpose(c).reshape([u,-1]);const h=[...s,...l];return Gh({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Xm(e.rank,r,"channelsLast"):null,activation:n}).reshape(h)}}function qm(e,t,n){return lo((()=>(t=Array.isArray(t)?hh(t,"int32"):t.toInt(),xl(e,t,n))))}function Km(e){return Co(e,e)}function Xm(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new Of(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1,1]):t.reshape([1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,1,r[0]]):t.reshape([1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1]):t.reshape([1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,r[0]]):t.reshape([1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1]):t.reshape([1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,r[0]]):t.reshape([1].concat(r))}else if(e<3)return t;throw new Of(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ym(e,t,n){return lo((()=>(null==n&&(n="channelsLast"),Im(n),e.add(Xm(e.rank,t,n)))))}function Jm(e,t,n,r){return lo((()=>Rh(e,t,n,r)))}function Zm(e,t,n=!1){return n?e():t()}const Qm=["fanIn","fanOut","fanAvg"],eg=["normal","uniform","truncatedNormal"];class tg extends Pi{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class ng extends tg{apply(e,t){return cc(e,t)}}ng.className="Zeros",Wi(ng);class rg extends tg{apply(e,t){return hc(e,t)}}rg.className="Ones",Wi(rg);class sg extends tg{constructor(e){if(super(),"object"!=typeof e)throw new Of(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Of(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return lo((()=>Co(Lo(this.value),hc(e,t))))}getConfig(){return{value:this.value}}}sg.className="Constant",Wi(sg);class ag extends tg{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ac(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ag.className="RandomUniform",Wi(ag);class ig extends tg{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Mf(`randomNormal does not support dType ${t}.`);return jm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ig.className="RandomNormal",Wi(ig);class og extends tg{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Mf(`truncatedNormal does not support dType ${t}.`);return yh(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}og.className="TruncatedNormal",Wi(og);class ug extends tg{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return lo((()=>{if(2!==e.length||e[0]!==e[1])throw new Of("Identity matrix initializer can only be used for 2D square matrices.");return Co(this.gain,yl(e[0]))}))}getConfig(){return{gain:this.gain}}}ug.className="Identity",Wi(ug);class lg extends tg{constructor(e){if(super(),e.scale<0)throw new Of(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Zf(Qm,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Zf(eg,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(Im(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=_m(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=_m(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=_m(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Mf(`${this.getClassName()} does not support dType ${t}.`);return yh(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return Ac(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}lg.className="VarianceScaling",Wi(lg);class cg extends lg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return lg.className}}cg.className="GlorotUniform",Wi(cg);class hg extends lg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return lg.className}}hg.className="GlorotNormal",Wi(hg);class pg extends lg{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return lg.className}}pg.className="HeNormal",Wi(pg);class dg extends lg{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return lg.className}}dg.className="HeUniform",Wi(dg);class fg extends lg{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return lg.className}}fg.className="LeCunNormal",Wi(fg);class mg extends lg{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return lg.className}}mg.className="LeCunNormal",Wi(mg);class gg extends tg{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new Mf("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return lo((()=>{if(e.length<2)throw new Mf("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=jm(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Fp.gramSchmidt(t);return e[0]>e[1]&&(n=n.transpose()),Co(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}gg.className="Orthogonal",Wi(gg);const yg={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function bg(e,t={}){return Kf(e,Vi.getMap().classNameMap,t,"initializer")}function xg(e){return Hf(e)}function wg(e){if("string"==typeof e){const t=e in yg?yg[e]:e;if("GlorotNormal"===t)return new hg;if("GlorotUniform"===t)return new cg;if("HeNormal"===t)return new pg;if("HeUniform"===t)return new dg;if("LeCunNormal"===t)return new fg;if("LeCunUniform"===t)return new mg;{const e={};return e.className=t,e.config={},bg(e)}}return e instanceof tg?e:bg(e)}function vg(){return new ng}function kg(){return new rg}function Ig(e){return new sg(e)}function Ng(e){return new ag(e)}function Sg(e){return new ig(e)}function Cg(e){return new og(e)}function Eg(e){return new ug(e)}function Tg(e){return new lg(e)}function $g(e){return new cg(e)}function Ag(e){return new hg(e)}function Rg(e){return new pg(e)}function _g(e){return new dg(e)}function Fg(e){return new fg(e)}function Dg(e){return new mg(e)}function Og(e){return new gg(e)}let Mg=0;function Lg(){return Mg++}const zg={};function Bg(e=""){return e in zg||(zg[e]=0),zg[e]+=1,e+zg[e].toString()}function Pg(e){return Array.isArray(e)&&Array.isArray(e[0])}function Vg(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Wg(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Of(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ug(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new Of(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Gg(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const jg="Variable";class Hg{constructor(e,t="float32",n="Variable",r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Lg(),n=null==n?jg:n,this.originalName=Tm(n),this.name=$m(this.originalName),this.trainable_=r,this.constraint=s,this.val=vh(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function qg(e){return e.map((e=>e.read()))}function Kg(e){e.forEach((e=>{e[0].write(e[1])}))}class Xg{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Yg{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Lg(),null!=a&&(this.originalName=Tm(a),this.name=$m(this.originalName)),this.rank=t.length}}let Jg=0;class Zg{constructor(e,t){this.callArgs=t,this.id=Jg++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Qg=0;class ey extends Pi{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Qg++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Uf(e)+"_"+Bg(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Df(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Of(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Vf(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Vf(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ff(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ff(`Layer ${this.name} is not connected, no input to return.`);return Vf(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ff(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ff(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Vf(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Wf(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=Wf(this.inputSpec);if(e.length!==t.length)throw new Of(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],s=t[n];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new Of(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new Of(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new Of(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new Of(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const e=r.shape;for(const t in s.axes){const r=Number(t),a=s.axes[t],i=r>=0?e[r]:e[e.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new Of(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${e}.`)}}if(null!=s.shape)for(let e=0;e<s.shape.length;++e){const t=s.shape[e],a=r.shape[e];if(null!=t&&null!=a&&t!==a)throw new Of(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Wf(e);let r=!0;for(const e of n)if(!(e instanceof Yg)){r=!1;break}let s=!0;for(const e of n)if(e instanceof Yg){s=!1;break}if(r===s)throw new Of("Arguments to apply() must be all SymbolicTensors or all Tensors");return Em(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Wf(e))t.push(n.shape);this.build(Vf(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);const s=Wf(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=Vf(a),null!=this.activityRegularizer)throw new Mf("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=Wf(e);const t=[];for(const n of e)t.push(n.shape);return Vf(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new Yg(a,n,this,Wf(e),t,this.name,r))):new Yg(a,r,this,Wf(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new Mf("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ff(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ff(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Df(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Gg(this.weights)}build(e){this.built=!0}getWeights(e=!1){return qg(e?this.trainableWeights:this.weights)}setWeights(e){lo((()=>{const t=this.weights;if(t.length!==e.length)throw new Of(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=qg(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!ae(a.shape,o.shape))throw new Of(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Kg(n)}))}addWeight(e,t,n,r,s,a,i){if(-1!==this._addedWeightNames.indexOf(e))throw new Of(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=wg("zeros"));const o=r.apply(t,n),u=new Hg(o,n,e,a,i);return o.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Wf(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,s,a,i=null){const o=Wf(e);t=Wf(t),n=Wf(n),r=Wf(r),s=Vg(s),a=Vg(a);const u=[],l=[],c=[];for(const e of o)u.push(e.sourceLayer),l.push(e.nodeIndex),c.push(e.tensorIndex);new Zg({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function ty(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=ty(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class ny extends ey{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Bg("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Of("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Of("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Of("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new Yg(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Zg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Of(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function ry(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Of("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");return new ny({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}async function sy(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];co(r)}}function ay(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var iy;ny.className="InputLayer",Wi(ny),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(iy||(iy={}));class oy{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class uy{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class ly extends oy{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=lo((()=>Io(this.totals[e],Co(r,n))));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:lo((()=>{const n=Co(So(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),ho(t[e])})))}}class cy extends oy{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e){this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}}class hy extends oy{constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Se(this.yieldEvery)&&(this.maybeWait=function(e,t){let n,r=ls();return(...s)=>{const a=ls();return a-r<t||(r=a,n=e(...s)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await sy(n),r.push(this.yield(e,t,n))),r.push(zp()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await sy(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await sy(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(zp()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await sy(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await sy(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(zp()):Se(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await sy(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await sy(e),await this.trainEnd(e))}}function py(e,t){if(null==e&&(e={}),e instanceof oy)return[e];if(Array.isArray(e)&&e[0]instanceof oy)return e;return Wf(e).map((e=>new hy(e,t)))}class dy{constructor(){}static registerCallbackConstructor(e,t){Q(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),dy.checkForDuplicate(t),null==dy.constructors[e]&&(dy.constructors[e]=[]),dy.constructors[e].push(t)}static checkForDuplicate(e){for(const t in dy.constructors){dy.constructors[+t].forEach((t=>{if(t===e)throw new Of("Duplicate callback constructor.")}))}}static clear(){dy.constructors={}}static createCallbacks(e){const t=[];for(const n in dy.constructors){const r=+n;e>=r&&t.push(...dy.constructors[r])}return t.map((e=>new e))}}function fy(e,t,n,r,s,a,i,o,u){const l=new cy,c=[new ly,...dy.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const h=new uy(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:l}}function my(e,t={},n=!1){return Kf(e,Vi.getMap().classNameMap,t,"layer",n)}function gy(e,t){return lo((()=>{"float32"!==e.dtype&&(e=e.asType("float32"));const n=Ll(Km(e),t,!0),r=Po(n.shape,_f()),s=Eo(Xo(n,r));return So(e,s)}))}function yy(e,t){return lo((()=>tc(Km(Uo(t,e)),-1)))}function by(e,t){return lo((()=>tc(jo(Uo(t,e)),-1)))}function xy(e,t){return lo((()=>{const n=Uo(e,t),r=Vu(jo(e),_f(),Number.MAX_VALUE),s=jo(So(n,r));return Co(100,tc(s,-1))}))}function wy(e,t){return lo((()=>{const n=Vu(t,_f(),Number.MAX_VALUE),r=Rl(Io(1,n)),s=Vu(e,_f(),Number.MAX_VALUE),a=Rl(Io(1,s));return tc(Km(Uo(r,a)),-1)}))}function vy(e,t,n=!1){return lo((()=>{if(n)t=Qc(t);else{const e=Ll(t,t.shape.length-1,!0);t=So(t,e)}return t=Vu(t,_f(),1-_f()),Fl(Ll(Co(e.toFloat(),Rl(t)),t.shape.length-1))}))}function ky(e,t,n=!1){return lo((()=>{const r=bl(function(e){const t=[_m(e.shape)];return e.reshape(t)}(e)).toInt(),s=(t=Vu(t,_f(),1-_f())).shape;return vy(di(r,s[s.length-1]).reshape(s),t,n)}))}function Iy(e,t){return lo((()=>{let n;return n=Vu(t,_f(),1-_f()),n=Rl(So(n,Uo(1,n))),tc(function(e,t){if(!ae(e.shape,t.shape))throw new Of(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return lo((()=>{const n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())}))}(e,n),-1)}))}function Ny(e,t){return lo((()=>{const n=Vu(e,_f(),1),r=Vu(t,_f(),1);return Ll(Co(e,Rl(So(n,r))),-1)}))}function Sy(e,t){return lo((()=>{const n=gy(e,-1),r=gy(t,-1),s=Co(n,r);return Fl(Ll(s,-1))}))}dy.constructors={};const Cy={meanSquaredError:yy,meanAbsoluteError:by,meanAbsolutePercentageError:xy,meanSquaredLogarithmicError:wy,squaredHinge:function(e,t){return lo((()=>{const n=Xo(0,Uo(1,Co(e,t)));return tc(Km(n),-1)}))},hinge:function(e,t){return lo((()=>{const n=Xo(0,Uo(1,Co(e,t)));return tc(n,-1)}))},categoricalHinge:function(e,t){return lo((()=>{const n=Ll(Co(e,t),-1),r=Ml(Co(Uo(1,e),t),-1);return Xo(0,Io(1,Uo(r,n)))}))},logcosh:function(e,t){return lo((()=>{const n=Math.log(2),r=Uo(t,e),s=Uo(Io(r,Dl(Co(-2,r))),n);return tc(s,-1)}))},categoricalCrossentropy:vy,sparseCategoricalCrossentropy:ky,binaryCrossentropy:Iy,kullbackLeiblerDivergence:Ny,poisson:function(e,t){return lo((()=>{const n=Rl(Io(_f(),t));return tc(Uo(t,Co(e,n)),-1)}))},cosineProximity:Sy};function Ey(e){if("string"==typeof e){if(e in Cy)return Cy[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Of(t)}return e}function Ty(e,t){return lo((()=>{const n=Co(.5,pc(t)),r=Lm(wl(t,n),e.dtype);return tc(ol(e,r),-1)}))}function $y(e,t){return lo((()=>Lm(ol(au(e,-1),au(t,-1)),"float32")))}function Ay(e,t){return lo((()=>Kl(e.equal(1),t.equal(1)).sum().cast("float32")))}function Ry(e,t){return lo((()=>{const n=Ay(e,t),r=function(e,t){return lo((()=>Kl(e.equal(0),t.equal(1)).sum().cast("float32")))}(e,t),s=n.add(r);return ul(wl(s,0),n.div(s),0).cast("float32")}))}function _y(e,t){return lo((()=>{const n=Ay(e,t),r=function(e,t){return lo((()=>Kl(e.equal(1),t.equal(0)).sum().cast("float32")))}(e,t),s=n.add(r);return ul(wl(s,0),n.div(s),0).cast("float32")}))}function Fy(e,t){return Iy(e,t)}function Dy(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),ol(e,t).asType("float32")}const Oy=vy,My=ky,Ly={binaryAccuracy:Ty,categoricalAccuracy:$y,precision:Ry,categoricalCrossentropy:Oy,sparseCategoricalCrossentropy:My,mse:yy,MSE:yy,mae:by,MAE:by,mape:xy,MAPE:xy,cosine:Sy};function zy(e){if("string"==typeof e&&e in Ly)return Ly[e];if("string"!=typeof e&&null!=e)return e;throw new Of(`Unknown metric ${e}`)}function By(e){if(Bf(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(Cy))if(Cy[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Ly))if(Ly[n]===e){t=n;break}return void 0!==t?t:e.name}}const Py=1048576;function Vy(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Wy(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>Py&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Wy(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!Wy(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Wy(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Uy(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Output shape","Param #"];let i;if(s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),Gy(a,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)s?jy(o[e],n,r):Hy(o[e],n,i,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;t=null!=e.collectedTrainableWeights?Gg(e.collectedTrainableWeights):Gg(e.trainableWeights);return t}(e),l=Gg(e.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}function Gy(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function jy(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}Gy([`${e.name} (${e.getClassName()})`,r,e.countParams().toString()],t,n)}function Hy(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const a=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];a.push(`${n}[${r}][${s}]`)}const i=e.name,o=e.getClassName(),u=0===a.length?"":a[0];Gy([`${i} (${o})`,s,e.countParams().toString(),u],t,r);for(let e=1;e<a.length;++e)Gy(["","","",a[e]],t,r)}function qy(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Ky(e,t){if(null===e)return null;if("string"==typeof e)return Gf(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];qy(t,s,r)?n.push(r):n.push(Ky(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=Gf(n);t[e]=Ky(r,e)}}return t}}function Xy(e,t){if(null==e)return null;if("string"==typeof e)return Uf(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];qy(t,s,r)?n.push(r):n.push(Xy(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=Uf(n);t[s]="name"!==n&&"className"!==n||"string"!=typeof r?Xy(r,n):r}return t}}const Yy="3.0.0";class Jy{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Jy)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Of(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Ha(t,e.dtype)}catch(n){throw new Of(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Yg){if(null==this.id2Value[e.id])throw new Of(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Of(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Yg){if(null==this.id2Value[e.id])throw new Of(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Of(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&co(this.id2Mask)}}const Zy={},Qy={};function eb(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),u=[],l=t.names();for(const e of o)-1!==l.indexOf(e)?u.push(t.getValue(e)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().join(",");let h,p;if(null==Zy[c]){const e=function(e,t){Q(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=nb(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=nb(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:tb(r)}}(i,t);h=e.sorted,p=e.recipientCounts,Zy[c]=h,Qy[c]=p}h=Zy[c],p={},s||Object.assign(p,Qy[c]);const d=new Jy(t);for(let e=0;e<h.length;++e){if(null!=r){const e=oo().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const a=h[e],i=a.sourceLayer;if(i instanceof ny)continue;const l=[],c=[],f=[];let m=!1;for(const e of a.inputs){const n=d.getValue(e),r=d.getMask(e);l.push(n),c.push(r),null!=r&&(m=!0),s||(p[e.name]--,0!==p[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=Wf(i.apply(l,n));let y=null;i.supportsMasking&&(y=i.computeMask(l,c));const b=rb(a),x=Array.isArray(b)?b:[b];for(let e=0;e<x.length;++e){d.hasKey(x[e])||d.add(x[e],g[e],Array.isArray(y)?y[0]:y);const t=o.indexOf(x[e].name);-1!==t&&(u[t]=g[e])}s||co(f)}return d.disposeMasks(),a?u:u[0]}function tb(e){const t={};for(const n in e)t[n]=e[n].size;return t}function nb(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function rb(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class sb extends ey{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Bg(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Yf(this.inputs).length!==this.inputs.length)throw new Of(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Yf(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;Bf(0===n,"input layer has >1 nodes"),Bf(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof ny))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,u)=>{null!=r&&null!=s&&null!=u||(r=e.sourceLayer,s=e.nodeIndex,u=e.tensorIndex);const l=r.inboundNodes[s];if(-1!==n.indexOf(l))throw new Df(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(sb.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let e=0;e<c;e++){const r=l.inputTensors[e],s=l.inboundLayers[e],a=l.nodeIndices[e],i=l.tensorIndices[e];o(r,t,n,s,a,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},u=[],l=[];for(const e of this.outputs)o(e,u,l);const c=i.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],o=s.inboundNodes[i],u=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(a+1,u),n[o.id]=o}}const h={};for(const e in t){const r=t[e];r in h||(h[r]=[]),h[r].push(n[e])}const p={};for(const e in r){const t=r[e];t in p||(p[t]=[]),p[t].push(s[e])}let d=Object.keys(p).map((e=>parseInt(e,10))).sort(Xf);this.layers=[];for(const e of d){const t=p[e];t.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof sb&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=p,d=Object.keys(h).map((e=>parseInt(e,10))).sort(Xf);const f=this.inputs.slice(),m=[];for(const e of d)for(const t of h[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new Df(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const e of g){const t=g.filter((t=>t===e)).length;if(1!==t)throw new Df(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Zg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Of("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const e of this.layers)for(const t of e.weights){if(null!=n[t.originalName])throw new Of(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,r++}const s=[];for(const r in e){let a=r;if(null==n[r]){const e=r.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])s.push([n[a],e[r]]);else if(t)throw new Of(`Provided weight data has no target variable: ${r}`);delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Of(`${e.length} of ${r} weights are not set: ${e}`)}Kg(s)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Yy}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Xy(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return lo((()=>{e=Wf(e);const n=new Jy;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return eb(this.outputs,n,t)}))}computeMask(e,t){return lo((()=>{let n;return e=Wf(e),n=null==t?zf(null,e.length):Wf(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Vg(e);if(t.length!==this.inputLayers.length)throw new Of(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Xf);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${s.name}_${a}_${i}`];r.push(o)}const s=Vg(t.computeOutputShape(Vf(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++){n[`${t.name}_${a}_${e}`]=s[e]}}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];Bf(t in n),s.push(n[t])}return Vf(s)}runInternalGraph(e,t){null==t&&(t=zf(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Xf);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,o,u,l={};if(null!=e.callArgs&&(l=e.callArgs),1===a.length){const[e,n]=a[0];null==l.mask&&(l.mask=n),o=Wf(t.call(e,l)),u=Wf(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==l.mask&&(l.mask=i),o=Wf(t.call(r,l)),u=Wf(t.computeMask(r,i));if(t.activityRegularizer)throw new Mf("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=u[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){Bf(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof sb?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=sb.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new Of(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new Of("Provide either a layer name or layer index");for(const t of this.layers)if(t.name===e)return t;throw new Of(`No such layer: ${e}`)}calculateLosses(){return lo((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=sb.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=sb.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],o=r.tensorIndices[n];let u=t[sb.nodeKey(s,a)];null==u&&(u=0),e.push([s.name,u,o,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=sb.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=sb.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.outputLayersTensorIndices[e];s.push([n.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],u=a[1],l=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=u)return void i(e,t);const h=c.inboundNodes[u];n.push(h.outputTensors[l])}n.length>0&&e.apply(Vf(n),r)}function u(e){const n=e.name,a=my(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Of(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const l=t.name,c=t.layers;for(const e of c)u(e);for(;!Jf(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],p=[],d=t.inputLayers;for(const e of d){const t=e[0],n=e[1],r=e[2];Bf(t in s);const a=s[t].inboundNodes[n].outputTensors;h.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];Bf(t in s);const a=s[t].inboundNodes[n].outputTensors;p.push(a[r])}return new e({inputs:h,outputs:p,name:l})}get stateful(){if(this._stateful)throw new Of("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){lo((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function ab(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function ib(e,t){return ab(e,t,"classWeight")}async function ob(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=lo((()=>{if(1===e.shape.length)return e.clone();if(2===e.shape.length){if(e.shape[1]>1){const t=1;return e.argMax(t)}if(1===e.shape[1])return e.reshape([e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());co(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),hh(s,"float32")}return null}function ub(e,t){return Co(e,t)}function lb(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Q(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=cb("input",e.inputNames,n),i=cb("output",e.outputNames,r),o=a[0].shape[0];Q(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Q(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<a.length;t++)Q(a[t].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let t=0;t<i.length;t++)Q(i[t].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function cb(e,t,n){if(n instanceof ys)return[n];if(Array.isArray(n))return Q(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new Of(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function hb(e,t,n){const r=null!=n.batchesPerEpoch;if(Q(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Q(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Q(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Q(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Q(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(pb(n.validationData))Q(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new Mf("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=s?u.slice().concat(u.map((e=>"val_"+e))):u.slice();const c=py(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:p,history:d}=fy(c,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,l);p.setModel(e),e.history=d,await p.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await p.onEpochBegin(f);let c=0,h=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=lb(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await p.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=ib(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await ob(s[e],null,t[e]))}const l=r.concat(s).concat(i),d=o(l);co(l);for(let e=0;e<u.length;++e){const t=u[e],n=d[e];a[t]=n,ho(n)}await p.onBatchEnd(h,a),ay(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=pb(n.validationData)?Wf(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Wf(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,l),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function pb(e){return"function"==typeof e.iterator}function db(e){Q(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function fb(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Bm(e,t,n-t))):Bm(e,t,n-t)}function mb(e,t){return lo((()=>null==e?null:Array.isArray(e)?e.map((e=>mb(e,t))):qm(e,"int32"===t.dtype?t:t.toInt())))}function gb(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}async function yb(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,a,i,o,u,l,c;e.isTraining=!0;try{const h=null==r.batchSize?32:r.batchSize;db(h);const p=!1,d=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,p,h);s=d[0],a=d[1],c=d[2];let f,m=!1;if(null!=r.validationData&&r.validationData.length>0){if(m=!0,2!==r.validationData.length)throw 3===r.validationData.length?new Mf("validationData including sample weights is not supported yet."):new Of(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);i=r.validationData[0],o=r.validationData[1];const t=!0,n=await e.standardizeUserData(i,o,null,null,t,h);u=n[0],l=n[1],f=u.concat(l)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){m=!0;const e=Math.floor(s[0].shape[0]*(1-r.validationSplit)),t=s[0].shape[0];u=fb(s,e,t),s=fb(s,0,e),l=fb(a,e,t),a=fb(a,0,e),f=u.concat(l)}else null!=r.validationSteps&&(m=!0);const g=s.concat(a).concat(c);e.checkTrainableWeightsConsistency();const y=e.makeTrainFunction(),b=e.getDedupedMetricsNames();let x,w;m?(e.makeTestFunction(),x=e.testFunction,w=b.slice().concat(b.map((e=>"val_"+e)))):(x=null,f=[],w=b.slice());const v=py(r.callbacks,r.yieldEvery);return await async function(e,t,n,r,s,a,i,o,u,l,c,h,p,d,f){null==s&&(s=32),null==a&&(a=1),null==c&&(c=!0),null==p&&(p=0);let m=!1;if(null!=u&&null!=l&&(m=!0),null!=f&&(m=!0,null==d))throw new Of("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,s,d,"steps_per_epoch");let y;null!=g&&(y=Mm(0,g)),null==i&&(i=1);const{callbackList:b,history:x}=fy(o,i,a,p,g,d,s,m,h);b.setModel(e),e.history=x,await b.onTrainBegin(),e.stopTraining_=!1;for(let i=p;i<a;++i){await b.onEpochBegin(i);const a={};if(null!=d)throw new Mf("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new Mf("batch shuffling is not implemneted yet");c&&H(y);const i=hh(y),o=gb(g,s);for(let c=0;c<o.length;++c){const h={};if(await b.onBatchBegin(c,h),lo((()=>{const p=o[c][0],d=o[c][1],f=Bm(i,p,d-p);h.batch=c,h.size=d-p;const g=mb(n,f),y=t(g);for(let e=0;e<r.length;++e){const t=r[e],n=y[e];h[t]=n,ho(n)}if(c===o.length-1&&m){const t=e.testLoop(u,l,s);for(let e=0;e<r.length;++e){const n=r[e],s=t[e];ho(s),a["val_"+n]=s}}})),await b.onBatchEnd(c,h),ay(h),e.stopTraining_)break}i.dispose()}if(await b.onEpochEnd(i,a),e.stopTraining_)break}return await b.onTrainEnd(),await e.history.syncData(),e.history}(e,y,g,b,h,r.epochs,r.verbose,v,x,f,r.shuffle,w,r.initialEpoch,null,null)}finally{e.isTraining=!1,xb(s,t),xb(a,n),xb(u,i),xb(l,o),null!=c&&co(c)}}function bb(e){const t=[];e instanceof ys&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(zm(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function xb(e,t){if(null==e)return;const n=[];if(t instanceof ys)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof ys)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function wb(e){return Array.isArray(e)}function vb(e){return!function(e){return e instanceof ys}(e)&&!wb(e)}function kb(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(wb(e)&&e.length>0)t=!0;else if(vb(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Of(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(vb(e)){e=e,a=[];for(const n of t){if(null==e[n])throw new Of(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(wb(e)){if((e=e).length!==t.length)throw new Of(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new Of(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=bb(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new Of(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],u=n[e][a];if(null!=u&&u>=0&&o!==u)throw new Of(`Error when checking ${s}: expected ${t[e]} to have shape [${n[e]}], but got array with shape [${i.shape}].`)}}return a}function Ib(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new Of(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new Of(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new Of(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],u=n[e][a];if(null!=u&&u!==o)throw new Of(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class Nb extends sb{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Of("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Uy(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Mp.adagrad(.01),Adadelta:()=>Mp.adadelta(1,.95,_f()),Adam:()=>Mp.adam(.001,.9,.999,_f()),Adamax:()=>Mp.adamax(.002,.9,.999,_f(),0),RMSProp:()=>Mp.rmsprop(.001,.9,0,_f()),SGD:()=>Mp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Of(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zo))throw new Of("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Of(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>Ey(e)))}else{const n=Ey(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Of(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(Ey(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Em("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Em("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===Iy?-1!==["accuracy","acc"].indexOf(i)?r=Ty:-1!==["crossentropy","ce"].indexOf(i)&&(r=Fy):this.lossFunctions[e]===ky?-1!==["accuracy","acc"].indexOf(i)?r=Dy:-1!==["crossentropy","ce"].indexOf(i)&&(r=My):-1!==["accuracy","acc"].indexOf(i)?r=$y:-1!==["crossentropy","ce"].indexOf(i)&&(r=Oy),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=zy(i);a=e,n=""+By(i)}let t;Em(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;db(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const a=s[0].concat(s[1]);this.makeTestFunction();const i=this.testFunction;return Vf(this.testLoop(i,a,r,n.verbose,n.steps))}finally{xb(s[0],e),xb(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new Mf("Verbose mode is not implemented yet.");Q(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"==typeof t.next?t:await t.iterator();let o=0,u=0;for(;!r||u<n.batches;){const t=await i.next();if(a=lo((()=>{if(t.value){const{xs:n,ys:r}=lb(e,t.value),i=n.concat(r),l=lo((()=>s(i)));if(co(i),0===u)for(let e=0;e<l.length;++e)a.push(Lo(0));const c=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=lo((()=>Io(a[e],Co(c,t)))),u>0&&co(n)}co(l),o+=c,++u}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){const t=a[e];a[e]=So(a[e],o),co(t)}return Vf(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new Of(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Of(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Of("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Jy;if(e instanceof ys&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Of(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new Of(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=eb(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=zf(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new Of(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return lo((()=>{const r=this.checkNumSamples(e);if(n)throw new Mf("Verbose predictLoop() is not implemented yet.");const s=gb(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){lo((()=>{const n=s[t][0],r=s[t][1],a=fb(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new Jy(i);return eb(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)))}return Vf(a.map((e=>Tu(e,0))))}))}predict(e,t={}){const n=bb(e);Ib(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==t.batchSize?32:t.batchSize;return db(r),this.predictLoop(n,r)}finally{xb(n,e)}}predictOnBatch(e){Ib(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new Df("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===ky?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t,n){const r=Yf(e.map((e=>e.shape[0])));r.sort();const s=Yf(t.map((e=>e.shape[0])));if(s.sort(),r.length>1)throw new Of(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(s.length>1)throw new Of(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&s.length>0&&!ae(r,s))throw new Of(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=kb(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=kb(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[yy,Iy,vy];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===vy&&1===a.shape[a.shape.length-1])throw new Of(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new Of(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new Of(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){const e=ib(r,this.outputNames);u=[];for(let t=0;t<e.length;++t)u.push(await ob(o[t],null,e[t]))}return[i,o,u]}testLoop(e,t,n,r=0,s){return lo((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Mf("Verbose mode is not implemented yet.");if(null!=s)throw new Mf("steps mode in testLoop() is not implemented yet");{const r=gb(a,n),s=hh(Mm(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],u=Bm(s,a,o-a),l=mb(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)i.push(Lo(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=Io(i[e],Co(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=So(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(Pf(e,r)>1){s+=`_${Pf(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new Jy(e),o=eb(this.outputs,i,{training:!0});let u;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=s[e]&&(n=ub(n,s[e]));const a=tc(n);t.push(a),u=0===e?n:Io(u,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=tc(t(r[s],o[s]))}ho(n),a.push(n)}return u=tc(u),this.calculateLosses().forEach((e=>{u=Io(u,e)})),u}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>lo((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new Jy(a),o=eb(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=tc(r(s[e],o[e]));n=0===e?a:Io(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=tc(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t,n={}){return yb(this,e,t,n)}async fitDataset(e,t){return hb(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return co(a),Vf(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=oo().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-oo().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Uf(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>Uf(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=Uf(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Uf(By(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>Uf(By(e))));{const e={};for(const t in this.metrics)e[t]=Uf(By(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=my(Ky(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=Gf(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Gf(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Gf(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>Gf(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=Gf(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=ha(e);if(0===t.length)throw new Of(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Of(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Of("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Qs(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Yy}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await Qs(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=sa([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;Vy(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Vy(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Nb.className="Model",Wi(Nb);class Sb extends Nb{}async function Cb(e,t){"modelTopology"in e||(e={modelTopology:e});let n=(e=e).modelTopology;null!=n.model_config&&(n=n.model_config);const r=my(Ky(n),t);if(null!=e.weightsManifest){const t=await ti(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(const e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),co(t)}return r}async function Eb(e,t){if(null==t&&(t={}),"string"==typeof e){const n=pa(e,t);if(0===n.length)n.push(oi(e,t));else if(n.length>1)throw new Of(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){null==n&&(n={});if(null==e.load)throw new Of("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const a=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&a,o=my(Ky(s),t,i),u=r.trainingConfig;null!=u&&o.loadTrainingConfig(u);null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new Of("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=ea(e,t),r={},s=[];return t.forEach((e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),co(e),co(t.map((e=>e.tensor)))}return o}(e,void 0,t)}Sb.className="Functional",Wi(Sb);class Tb extends Nb{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Bg("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Of(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Tb||e instanceof Nb;let n;if(t){if(n=e,1!==n.outputs.length)throw new Of("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Of("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Of("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=ry({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Of(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Of("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=ty(this.outputs[0])}this.inboundNodes=[],new Zg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:zf(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Ug(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Nb({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Df("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Df("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Df("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Df("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Of("Legacy serialization format not supported yet.");s=t}else Q(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof Tb))throw new Mf(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=my(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new Of("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Of("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function $b(e){return new Nb(e)}function Ab(e){return new Tb(e)}function Rb(e,t){return null==t&&(t={}),Eb(e,t)}function _b(e){return ry(e)}function Fb(e,t){dy.registerCallbackConstructor(e,t)}Tb.className="Sequential",Wi(Tb);class Db extends Pi{getConfig(){return{}}}class Ob extends Db{apply(e,t=1){return function(e,t=1){if(1!==t)throw new Mf(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return hl(e)}(e,t)}}Ob.className="elu",Wi(Ob);class Mb extends Db{apply(e){return Uc(e)}}Mb.className="selu",Wi(Mb);class Lb extends Db{apply(e){return Dc(e)}}Lb.className="relu",Wi(Lb);class zb extends Db{apply(e){return lo((()=>rc(6,Dc(e))))}}zb.className="relu6",Wi(zb);class Bb extends Db{apply(e){return e}}Bb.className="linear",Wi(Bb);class Pb extends Db{apply(e){return $u(e)}}Pb.className="sigmoid",Wi(Pb);class Vb extends Db{apply(e){return function(e){return lo((()=>{const t=Io(.5,Co(.2,e));return Vu(t,0,1)}))}(e)}}Vb.className="hardSigmoid",Wi(Vb);class Wb extends Db{apply(e){return Dl(e)}}Wb.className="softplus",Wi(Wb);class Ub extends Db{apply(e){return function(e){return lo((()=>So(e,jo(e).add(1))))}(e)}}Ub.className="softsign",Wi(Ub);class Gb extends Db{apply(e){return Ru(e)}}Gb.className="tanh",Wi(Gb);class jb extends Db{apply(e,t=-1){return Qc(e,t)}}jb.className="softmax",Wi(jb);class Hb extends Db{apply(e,t=-1){return zl(e,t)}}Hb.className="logSoftmax",Wi(Hb);class qb extends Db{apply(e,t=1){return lo((()=>$u(e.mul(t)).mul(e)))}}function Kb(e){return e.getClassName()}function Xb(e,t={}){return Kf(e,Vi.getMap().classNameMap,t,"activation")}function Yb(e){if(null==e){const e={className:"linear",config:{}};return Xb(e)}if("string"==typeof e){const t={};return t.className=e,t.config={},Xb(t)}return e instanceof Db?e:Xb(e)}function Jb(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}qb.className="swish",Wi(qb);class Zb extends Pi{}class Qb extends Zb{constructor(e){super(),Jb(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return lo((()=>{let t=cc([1]);return this.hasL1&&(t=Io(t,Ll(Co(this.l1,jo(e))))),this.hasL2&&(t=Io(t,Ll(Co(this.l2,Km(e))))),t.asScalar()}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Qb.className="L1L2",Wi(Qb);const ex={l1l2:"L1L2"};function tx(e){return Hf(e)}function nx(e,t={}){return Kf(e,Vi.getMap().classNameMap,t,"regularizer")}function rx(e){if(null==e)return null;if("string"==typeof e){return nx({className:e in ex?ex[e]:e,config:{}})}return e instanceof Zb?e:nx(e)}class sx extends ey{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Wg(e);let n=Dc(e);return null!=this.maxValue&&(n=Vu(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}sx.className="ReLU",Wi(sx);class ax extends ey{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Wg(e);return Cl(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}ax.className="LeakyReLU",Wi(ax);class ix extends ey{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=wg(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=rx(e.alphaRegularizer),this.alphaConstraint=pm(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Of(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=Ug(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Xg({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Wg(e),vc(e,this.alpha.read())}getConfig(){const e={alphaInitializer:xg(this.alphaInitializer),alphaRegularizer:tx(this.alphaRegularizer),alphaConstraint:cm(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}ix.className="PReLU",Wi(ix);class ox extends ey{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Mf(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Wg(e);return hl(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}ox.className="ELU",Wi(ox);class ux extends ey{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Wg(e);return n.mul(Lm(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}ux.className="ThresholdedReLU",Wi(ux);class lx extends ey{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new jb).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=Wg(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function cx(e,t,n){if("number"==typeof e)return zf(e,t);if(e.length!==t)throw new Of(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new Of(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function hx(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function px(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+Om([n-t,0]);else{if("same"!==r)throw new Of(`Unsupport padding mode: ${r}.`);e*=t}return e}function dx(e,t){return lo((()=>(Im(t),"channelsFirst"===t?fi(e,[0,2,3,1]):e)))}function fx(e,t){return lo((()=>(Im(t),"channelsFirst"===t?fi(e,[0,2,3,4,1]):e)))}function mx(e,t,n,r=1,s="valid",a,i=1){return lo((()=>{if(null==a&&(a="channelsLast"),Im(a),3!==e.shape.length)throw new Of(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Of(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Of(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=fi(e,[0,2,1])),"causal"===s)throw new Mf("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=qu(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=Ym(o,n)),o}))}function gx(e,t,n,r=[1,1],s="valid",a,i,o=null){return lo((()=>{if(null==a&&(a="channelsLast"),Im(a),3!==e.rank&&4!==e.rank)throw new Of(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Of(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=dx(e,a);if("causal"===s)throw new Mf("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Ph({x:u,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(u=fi(u,[0,3,1,2])),u}))}function yx(e,t,n,r=[1,1,1],s="valid",a,i){return lo((()=>{if(null==a&&(a="channelsLast"),Im(a),4!==e.rank&&5!==e.rank)throw new Of(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Of(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=fx(e,a);if("causal"===s)throw new Mf("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Yu(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=Ym(o,n)),"channelsFirst"===a&&(o=fi(o,[0,4,1,2,3])),o}))}lx.className="Softmax",Wi(lx);class bx extends ey{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",bx.verifyArgs(t),this.rank=e,em(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Mf(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=cx(t.kernelSize,e,"kernelSize"),this.strides=cx(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Nm(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Im(this.dataFormat),this.activation=Yb(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=wg(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=pm(t.biasConstraint),this.biasRegularizer=rx(t.biasRegularizer),this.activityRegularizer=rx(t.activityRegularizer),this.dilationRate=cx(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Of(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Of(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Of(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Bf("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!Qf(e.kernelSize,"number",1,3))throw new Of(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Kb(this.activation),useBias:this.useBias,biasInitializer:xg(this.biasInitializer),biasRegularizer:tx(this.biasRegularizer),activityRegularizer:tx(this.activityRegularizer),biasConstraint:cm(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class xx extends bx{constructor(e,t){super(e,t),this.kernel=null,xx.verifyArgs(t),this.filters=t.filters,em(this.filters,"filters"),this.kernelInitializer=wg(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=pm(t.kernelConstraint),this.kernelRegularizer=rx(t.kernelRegularizer)}build(e){e=Ug(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Of(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return lo((()=>{let t;e=Wg(e);const n=null==this.bias?null:this.bias.read(),r=nm(this.activation.getClassName());if(null!=r&&2===this.rank)t=gx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=mx(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=gx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Mf("convolutions greater than 3D are not implemented yet.");t=yx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Ug(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=hx(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:xg(this.kernelInitializer),kernelRegularizer:tx(this.kernelRegularizer),kernelConstraint:cm(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new Of(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class wx extends xx{constructor(e){super(2,e),wx.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Qf(e.kernelSize,"number",1,2))throw new Of(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}wx.className="Conv2D",Wi(wx);class vx extends xx{constructor(e){super(3,e),vx.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Of(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}vx.className="Conv3D",Wi(vx);class kx extends wx{constructor(e){if(super(e),this.inputSpec=[new Xg({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Of(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Ug(e)).length)throw new Of("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Of("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Xg({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return lo((()=>{let t=Wg(e);if(4!==t.shape.length)throw new Of(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],u=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1],p=[r,px(i,c,u,this.padding),px(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=fi(t,[0,2,3,1]));let d=Xu(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(d=fi(d,[0,3,1,2])),null!=this.bias&&(d=Ym(d,this.bias.read(),this.dataFormat)),null!=this.activation&&(d=this.activation.apply(d)),d}))}computeOutputShape(e){const t=(e=Ug(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=px(t[r],o,a,this.padding),t[s]=px(t[s],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}kx.className="Conv2DTranspose",Wi(kx);class Ix extends xx{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Of("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Of("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Of(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=wg(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=rx(t.depthwiseRegularizer),this.depthwiseConstraint=pm(t.depthwiseConstraint),this.pointwiseInitializer=wg(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=rx(t.pointwiseRegularizer),this.pointwiseConstraint=pm(t.pointwiseConstraint)}build(e){if((e=Ug(e)).length<this.rank+2)throw new Of(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Of(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Xg({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return lo((()=>{let t;if(e=Wg(e),1===this.rank)throw new Mf("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=fi(e,[0,2,3,1])),t=Gc(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Ym(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=fi(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=xg(this.depthwiseInitializer),e.pointwiseInitializer=xg(this.pointwiseInitializer),e.depthwiseRegularizer=tx(this.depthwiseRegularizer),e.pointwiseRegularizer=tx(this.pointwiseRegularizer),e.depthwiseConstraint=cm(this.depthwiseConstraint),e.pointwiseConstraint=cm(this.pointwiseConstraint),e}}Ix.className="SeparableConv";class Nx extends Ix{constructor(e){super(2,e)}}Nx.className="SeparableConv2D",Wi(Nx);class Sx extends xx{constructor(e){super(1,e),Sx.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Qf(e.kernelSize,"number",1,1))throw new Of(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Sx.className="Conv1D",Wi(Sx);class Cx extends ey{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return lo((()=>{if(e=Wg(e),"channelsLast"===this.dataFormat){const t=Vm(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Vm(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Vm(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Vm(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Cx.className="Cropping2D",Wi(Cx);class Ex extends ey{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Im(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Zf(bm,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return lo((()=>{let t=Wg(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=fi(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r]);return fi(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Ex.className="UpSampling2D",Wi(Ex);class Tx extends bx{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=wg(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=pm(e.depthwiseConstraint),this.depthwiseRegularizer=rx(e.depthwiseRegularizer)}build(e){if((e=Ug(e)).length<4)throw new Of(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Of(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lo((()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return lo((()=>{null==s&&(s="channelsLast"),Im(s);let i=dx(e,s);if(4!==e.rank)throw new Of(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Of(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=sl(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=fi(i,[0,3,1,2])),i}))}(e=Wg(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Ym(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Ug(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=hx(t,this.kernelSize[0],this.padding,this.strides[0]),a=hx(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=xg(this.depthwiseInitializer),e.depthwiseRegularizer=tx(this.depthwiseRegularizer),e.depthwiseConstraint=cm(this.depthwiseRegularizer),e}}function $x(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new Of("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function Ax(e,t,n,r=!1,s,a,i=!1,o=!1){return lo((()=>{const u=t.shape.length;if(u<3)throw new Of(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(Mm(2,u));if(t=fi(t,l),null!=a)throw new Mf("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===u-1&&(s=fl(s,-1)),s=fi(s,l)),r&&(t=Mc(t,0),null!=s&&(s=Mc(s,0)));const c=[];let h,p=n;const d=t.shape[0],f=wh(t);let m,g;null!=s&&(m=wh(s));for(let t=0;t<d;++t){const n=f[t],r=lo((()=>e(n,p)));if(null==s)h=r[0],p=r[1];else{const e=lo((()=>{const e=m[t],n=pc(e).sub(e);return{output:r[0].mul(e).add(p[0].mul(n)),newStates:p.map(((t,s)=>r[1][s].mul(e).add(t.mul(n))))}}));h=e.output,p=e.newStates}o&&c.push(h)}if(o){g=oh(c,1)}return[h,g,p]}))}Tx.className="DepthwiseConv2D",Wi(Tx);class Rx extends ey{constructor(e){let t;if(super(e),null==e.cell)throw new Of("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Bx({cells:e.cell}):e.cell,null==t.stateSize)throw new Of("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Xg({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Mm(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Pg(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return lo((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Mf("Constants support is not implemented in RNN yet.");Pg(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Xg({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ae(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new Of(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new Xg({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){lo((()=>{if(!this.stateful)throw new Ff("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Of("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>cc([n,e]))):this.states_=[cc([n,this.cell.stateSize])];else if(null==e)co(this.states_),null!=this.keptStates&&(co(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>cc([n,e]))):this.states_[0]=cc([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Of(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):co(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!ae(r.shape,a))throw new Of(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>ho(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=$x(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Xg({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof Yg){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return lo((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=Wg(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new Of(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=Ax(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),u=o[0],l=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?l:u;return this.returnState?[h].concat(c):h}))}getInitialState(e){return lo((()=>{let t=cc(e.shape);return t=Ll(t,[1,2]),t=zm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Gm(t,[1,e]):t)):this.cell.stateSize>1?[Gm(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Rx.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const r=my(t.cell,n);return new e(Object.assign(t,{cell:r}))}}Rx.className="RNN",Wi(Rx);class _x extends ey{}class Fx extends _x{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,em(this.units,"units"),this.activation=Yb(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rx(e.kernelRegularizer),this.recurrentRegularizer=rx(e.recurrentRegularizer),this.biasRegularizer=rx(e.biasRegularizer),this.kernelConstraint=pm(e.kernelConstraint),this.recurrentConstraint=pm(e.recurrentConstraint),this.biasConstraint=pm(e.biasConstraint),this.dropout=Dm([1,Om([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Dm([1,Om([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ug(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lo((()=>{if(2!==(e=e).length)throw new Of(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Px({ones:()=>pc(e),rate:this.dropout,training:r})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Px({ones:()=>pc(n),rate:this.recurrentDropout,training:r}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=Hm(null!=a?Co(e,a):e,this.kernel.read()),null!=this.bias&&(s=Ym(s,this.bias.read())),null!=i&&(n=Co(n,i));let o=Io(s,Hm(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Kb(this.activation),useBias:this.useBias,kernelInitializer:xg(this.kernelInitializer),recurrentInitializer:xg(this.recurrentInitializer),biasInitializer:xg(this.biasInitializer),kernelRegularizer:tx(this.kernelRegularizer),recurrentRegularizer:tx(this.recurrentRegularizer),biasRegularizer:tx(this.biasRegularizer),activityRegularizer:tx(this.activityRegularizer),kernelConstraint:cm(this.kernelConstraint),recurrentConstraint:cm(this.recurrentConstraint),biasConstraint:cm(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}Fx.className="SimpleRNNCell",Wi(Fx);class Dx extends Rx{constructor(e){e.cell=new Fx(e),super(e)}call(e,t){return lo((()=>{null!=this.cell.dropoutMask&&(co(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(co(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}Dx.className="SimpleRNN",Wi(Dx);class Ox extends _x{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Of("GRUCell does not support reset_after parameter set to true.");this.units=e.units,em(this.units,"units"),this.activation=Yb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rx(e.kernelRegularizer),this.recurrentRegularizer=rx(e.recurrentRegularizer),this.biasRegularizer=rx(e.biasRegularizer),this.kernelConstraint=pm(e.kernelConstraint),this.recurrentConstraint=pm(e.recurrentConstraint),this.biasConstraint=pm(e.biasConstraint),this.dropout=Dm([1,Om([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Dm([1,Om([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=Ug(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lo((()=>{if(2!==(e=e).length)throw new Of(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Px({ones:()=>pc(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Px({ones:()=>pc(r),rate:this.recurrentDropout,training:n,count:3}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,u;0<this.dropout&&this.dropout<1&&(e=Co(e,s[0]));let l=Hm(e,this.kernel.read());this.useBias&&(l=Ym(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Co(r,a[0]));const c=this.recurrentKernel.read(),[h,p]=rh(c,[2*this.units,this.units],c.rank-1),d=Hm(r,h),[f,m,g]=rh(l,3,l.rank-1),[y,b]=rh(d,2,d.rank-1);i=this.recurrentActivation.apply(Io(f,y)),o=this.recurrentActivation.apply(Io(m,b));const x=Hm(Co(o,r),p);u=this.activation.apply(Io(g,x));const w=Io(Co(i,r),Co(Io(1,Fl(i)),u));return[w,w]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Kb(this.activation),recurrentActivation:Kb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xg(this.kernelInitializer),recurrentInitializer:xg(this.recurrentInitializer),biasInitializer:xg(this.biasInitializer),kernelRegularizer:tx(this.kernelRegularizer),recurrentRegularizer:tx(this.recurrentRegularizer),biasRegularizer:tx(this.biasRegularizer),activityRegularizer:tx(this.activityRegularizer),kernelConstraint:cm(this.kernelConstraint),recurrentConstraint:cm(this.recurrentConstraint),biasConstraint:cm(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}Ox.className="GRUCell",Wi(Ox);class Mx extends Rx{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ox(e),super(e)}call(e,t){return lo((()=>{null!=this.cell.dropoutMask&&(co(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(co(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Mx.className="GRU",Wi(Mx);class Lx extends _x{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,em(this.units,"units"),this.activation=Yb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=rx(e.kernelRegularizer),this.recurrentRegularizer=rx(e.recurrentRegularizer),this.biasRegularizer=rx(e.biasRegularizer),this.kernelConstraint=pm(e.kernelConstraint),this.recurrentConstraint=pm(e.recurrentConstraint),this.biasConstraint=pm(e.biasConstraint),this.dropout=Dm([1,Om([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Dm([1,Om([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=Ug(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends tg{apply(t,r){const s=e.apply([n]),a=(new rg).apply([n]),i=e.apply([2*n]);return Um(Um(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return lo((()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new Of(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Px({ones:()=>pc(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Px({ones:()=>pc(r),rate:this.recurrentDropout,training:n,count:4}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,u,l,c;0<this.dropout&&this.dropout<1&&(e=Co(e,a[0]));let h=Hm(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Co(r,i[0])),h=Io(h,Hm(r,this.recurrentKernel.read())),this.useBias&&(h=Ym(h,this.bias.read()));const[p,d,f,m]=rh(h,4,h.rank-1);o=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(d),l=Io(Co(u,s),Co(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=Co(c,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Kb(this.activation),recurrentActivation:Kb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xg(this.kernelInitializer),recurrentInitializer:xg(this.recurrentInitializer),biasInitializer:xg(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:tx(this.kernelRegularizer),recurrentRegularizer:tx(this.recurrentRegularizer),biasRegularizer:tx(this.biasRegularizer),activityRegularizer:tx(this.activityRegularizer),kernelConstraint:cm(this.kernelConstraint),recurrentConstraint:cm(this.recurrentConstraint),biasConstraint:cm(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}Lx.className="LSTMCell",Wi(Lx);class zx extends Rx{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Lx(e),super(e)}call(e,t){return lo((()=>{null!=this.cell.dropoutMask&&(co(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(co(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}zx.className="LSTM",Wi(zx);class Bx extends _x{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return lo((()=>{let n=(e=e).slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Pg(e)&&(e=e[0]),e=e,this.cells.forEach(((n,r)=>{Em(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign({},e,t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(my(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return qg(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}Kg(t)}}function Px(e){const{ones:t,rate:n,training:r=!1,count:s=1}=e,a=()=>Jm(t(),n),i=()=>Zm(a,t,r);if(!s||s<=1)return ho(i().clone());return Array(s).fill(void 0).map(i).map((e=>ho(e.clone())))}Bx.className="StackedRNNCells",Wi(Bx);var Vx=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class Wx extends Rx{constructor(e){if(e.unroll)throw new Mf("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Mf("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Xg({ndim:5})]}call(e,t){return lo((()=>{if(null!=this.cell.dropoutMask&&(co(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(co(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Of("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return lo((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=cc([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){lo((()=>{if(!this.stateful)throw new Ff("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new Of("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>cc(s))):this.states_=[cc(s)];else if(null==e)co(this.states_),null!=this.keptStates&&(co(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>cc(s))):this.states_[0]=cc(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Of(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):co(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!ae(n.shape,r))throw new Of(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>ho(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,u=e[o?3:2],l=e[o?4:3],c=hx(u,r[0],s,a[0],i[0]),h=hx(l,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}Wx.className="ConvRNN2D";class Ux extends Lx{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,em(this.filters,"filters"),this.kernelSize=cx(n,2,"kernelSize"),this.kernelSize.forEach((e=>em(e,"kernelSize"))),this.strides=cx(r||1,2,"strides"),this.strides.forEach((e=>em(e,"strides"))),this.padding=s||"valid",Nm(this.padding),this.dataFormat=a||"channelsLast",Im(this.dataFormat),this.dilationRate=cx(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>em(e,"dilationRate")))}build(e){var t;e=Ug(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Of(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends tg{apply(e,t){return Wm([n.apply([r]),hc([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return lo((()=>{if(3!==e.length)throw new Of(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Px({ones:()=>pc(r),rate:this.dropout,training:n,count:4}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Co(t[n],e):e;let u=o(r,i,0),l=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Px({ones:()=>pc(s),rate:this.recurrentDropout,training:n,count:4}));const p=this.recurrentDropoutMask;let d=o(s,p,0),f=o(s,p,1),m=o(s,p,2),g=o(s,p,3);const[y,b,x,w]=rh(this.kernel.read(),4,3),[v,k,I,N]=this.useBias?rh(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,y,v,this.padding),l=this.inputConv(l,b,k,this.padding),c=this.inputConv(c,x,I,this.padding),h=this.inputConv(h,w,N,this.padding);const[S,C,E,T]=rh(this.recurrentKernel.read(),4,3);d=this.recurrentConv(d,S),f=this.recurrentConv(f,C),m=this.recurrentConv(m,E),g=this.recurrentConv(g,T);const $=this.recurrentActivation.apply(Io(u,d)),A=this.recurrentActivation.apply(Io(l,f)),R=Io(Co(A,a),Co($,this.activation.apply(Io(c,m)))),_=Co(this.recurrentActivation.apply(Io(h,g)),this.activation.apply(R));return[_,_,R]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=Vx(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){const s=Hu(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Ym(s,n,this.dataFormat):s}recurrentConv(e,t){return Hu(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Ux.className="ConvLSTM2DCell",Wi(Ux);class Gx extends Wx{constructor(e){const t=new Ux(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}Gx.className="ConvLSTM2D",Wi(Gx);class jx extends ey{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Zm((()=>Jm(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}jx.className="Dropout",Wi(jx);class Hx extends jx{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Hx.className="SpatialDropout1D",Wi(Hx);class qx extends ey{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,em(this.units,"units"),this.activation=Yb(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=wg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=wg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=pm(e.kernelConstraint),this.biasConstraint=pm(e.biasConstraint),this.kernelRegularizer=rx(e.kernelRegularizer),this.biasRegularizer=rx(e.biasRegularizer),this.activityRegularizer=rx(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=Ug(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=Ug(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e),r=nm(this.activation.getClassName());let s;return null!=r?s=Hm(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Hm(n,this.kernel.read()),null!=this.bias&&(s=Ym(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:Kb(this.activation),useBias:this.useBias,kernelInitializer:xg(this.kernelInitializer),biasInitializer:xg(this.biasInitializer),kernelRegularizer:tx(this.kernelRegularizer),biasRegularizer:tx(this.biasRegularizer),activityRegularizer:tx(this.activityRegularizer),kernelConstraint:cm(this.kernelConstraint),biasConstraint:cm(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}qx.className="Dense",Wi(qx);class Kx extends ey{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ug(e);for(const t of e.slice(1))if(null==t)throw new Of(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],_m(e,1)]}call(e,t){return lo((()=>{this.invokeCallHook(e,t);let n=Wg(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=n.transpose(e)}return function(e){if(e.rank<=1)throw new Of(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],_m(e.shape,1)];return e.reshape(t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Kx.className="Flatten",Wi(Kx);class Xx extends ey{constructor(e){super(e),this.supportsMasking=!0,this.activation=Yb(e.activation)}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e);return this.activation.apply(n)}))}getConfig(){const e={activation:Kb(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Xx.className="Activation",Wi(Xx);class Yx extends ey{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return lo((()=>{return e=Wg(e),t=e,n=this.n,lo((()=>{if(2!==t.shape.length)throw new Of(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return Gm(zm(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Yx.className="RepeatVector",Wi(Yx);class Jx extends ey{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new Of("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=_m(e);if(null!==a){if(0===s||i%s!=0)throw new Of(n);r[a]=i/s}else if(i!==s)throw new Of(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Jx.className="Reshape",Wi(Jx);class Zx extends ey{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Mm(1,e.dims.length+1);if(!ae(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Xg({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=Ug(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return fi(Wg(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Zx.className="Permute",Wi(Zx);class Qx extends ey{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Wg(e);return su(lc(n,this.maskValue),-1)}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e),r=su(lc(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))}))}}Qx.className="Masking",Wi(Qx);class ew extends ey{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Wf(e.inputLength))}this.inputDim=e.inputDim,em(this.inputDim,"inputDim"),this.outputDim=e.outputDim,em(this.outputDim,"outputDim"),this.embeddingsInitializer=wg(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=rx(e.embeddingsRegularizer),this.activityRegularizer=rx(e.activityRegularizer),this.embeddingsConstraint=pm(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return lo((()=>this.maskZero?(e=Wg(e),lc(e,$o(e))):null))}computeOutputShape(e){if(e=Ug(e),null==this.inputLength)return[...e,this.outputDim];const t=Wf(this.inputLength);if(t.length!==e.length-1)throw new Of(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new Of(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return lo((()=>{this.invokeCallHook(e,t);let n=Wg(e);"int32"!==n.dtype&&(n=Lm(n,"int32"));return qm(this.embeddings.read(),n.as1D()).reshape(Ug(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:xg(this.embeddingsInitializer),embeddingsRegularizer:tx(this.embeddingsRegularizer),activityRegularizer:tx(this.activityRegularizer),embeddingsConstraint:cm(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}ew.className="Embedding",Wi(ew);class tw extends ey{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Mf}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new Of("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ug(e)]),(e=e).length<2)throw new Of(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=Yf(t),t.length>1)throw new Of(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Yf(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return lo((()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=Om(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=zm(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=r.reshape([s].concat(_m(e.slice(1))));i=fi(i,[1,0]),i=i.reshape(a),t.push(i),n=!0}else if(e>1){const s=Mm(1,e).concat([0]);t.push(fi(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=fi(r.reshape([-1,t]),[1,0]).reshape(n)}else if(s>1){const e=[s-1].concat(Mm(0,s-1));r=fi(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=Yf(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return lo((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Of("`mask` should be an Array");if(!Array.isArray(e))throw new Of("`inputs` should be an Array");if(t.length!==e.length)throw new Of(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:fl(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Kl(n,t[e]);return n}))}}class nw extends tw{constructor(e){super(e)}mergeFunction(e){return lo((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Io(t,e[n]);return t}))}}nw.className="Add",Wi(nw);class rw extends tw{constructor(e){super(e)}mergeFunction(e){return lo((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Co(t,e[n]);return t}))}}rw.className="Multiply",Wi(rw);class sw extends tw{constructor(e){super(e)}mergeFunction(e){return lo((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Io(t,e[n]);return Co(1/e.length,t)}))}}sw.className="Average",Wi(sw);class aw extends tw{constructor(e){super(e)}mergeFunction(e){return lo((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Xo(t,e[n]);return t}))}}aw.className="Maximum",Wi(aw);class iw extends tw{constructor(e){super(e)}mergeFunction(e){return lo((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=rc(t,e[n]);return t}))}}iw.className="Minimum",Wi(iw);class ow extends tw{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Of("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(ae(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new Of("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return lo((()=>Wm(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Of("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Of("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Of("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Of(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return lo((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(pc(e[n]).asType("bool")):t[n].rank<e[n].rank?r.push(fl(t[n],-1)):r.push(t[n]);const s=Tu(r,this.axis);return ru(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function uw(e,t){for(;e<0;)e+=t;return e}ow.className="Concatenate",Wi(ow);class lw extends tw{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Q(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Mf("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Of(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Of(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>uw(t,e[n].shape.length))):[uw(this.axes,n.shape.length),uw(this.axes,r.shape.length)],this.normalize&&(n=gy(n,t[0]),r=gy(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Mf("batchDot is not implemented for tensors of 4D or higher rank yet");if(Q(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Q(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Mf("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return lo((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?e.mul(t).sum(a[0]):e.transpose([1,0]).mul(t).sum(a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=e.matMul(t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=i.squeeze(t)}return 1===i.shape.length&&(i=i.expandDims(1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[uw(this.axes,e.length),uw(this.axes,t.length)],n}computeOutputShape(e){Q(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Mf("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}lw.className="Dot",Wi(lw);class cw extends ey{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e);return Zm((()=>jm(n.shape,0,this.stddev).add(n)),(()=>n),t.training||!1)}))}}cw.className="GaussianNoise",Wi(cw);class hw extends ey{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return lo((()=>{this.invokeCallHook(e,t);const n=Wg(e);if(this.rate>0&&this.rate<1){return Zm((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return n.mul(jm(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}hw.className="GaussianDropout",Wi(hw);class pw extends ey{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Wg(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return lo((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return Zm((()=>{const t=Wg(e),r=-1.7580993408473766;let s=vl(Ac(n),this.rate);s=Lm(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate;return t.mul(s).add(s.add(-1).mul(r)).mul(a).add(i)}),(()=>Wg(e)),t.training||!1)}return e}))}}function dw(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=Ou(e,t,n,r,s,a);else if(3===e.rank)i=Mu(e,t,n,r,s,a);else{if(4!==e.rank)throw new Mf(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=Lu(e,t,n,r,s,a)}return i}function fw(e,t,n,r,s=.001){return ae(r.slice().sort(),Mm(0,e.rank-1))?function(e,t,n,r,s=.001){return lo((()=>{const a=ic(e,r),i=a.mean,o=a.variance;return[dw(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r,s=.001){return lo((()=>{const a=ic(e,r),i=a.mean,o=a.variance,u=[];for(const t of Mm(0,e.rank))-1!==r.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=i.reshape(u),c=o.reshape(u),h=null==t?null:t.reshape(u),p=null==n?null:n.reshape(u);return[dw(e,l,c,p,h,s),i,o]}))}(e,t,n,r,s)}pw.className="AlphaDropout",Wi(pw);class mw extends ey{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=wg(e.betaInitializer||"zeros"),this.gammaInitializer=wg(e.gammaInitializer||"ones"),this.movingMeanInitializer=wg(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=wg(e.movingVarianceInitializer||"ones"),this.betaConstraint=pm(e.betaConstraint),this.gammaConstraint=pm(e.gammaConstraint),this.betaRegularizer=rx(e.betaRegularizer),this.gammaRegularizer=rx(e.gammaRegularizer)}build(e){e=Ug(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Of(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Xg({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return lo((()=>{const n=null!=t.training&&t.training,r=Wg(e),s=r.shape,a=s.length,i=Mm(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const u=zf(1,a);u[o]=s[o];const l=i.slice();l.sort();const c=!ae(l,Mm(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=this.movingMean.read().reshape(u),t=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,s=this.scale?this.gamma.read().reshape(u):null;return dw(r,e,t,n,s,this.epsilon)}return dw(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,p,d]=fw(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{lo((()=>{const r=1-n,s=e.read(),a=s.sub(t).mul(r);e.write(s.sub(a))}))};return(()=>{f(this.movingMean,p,this.momentum),f(this.movingVariance,d,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xg(this.betaInitializer),gammaInitializer:xg(this.gammaInitializer),movingMeanInitializer:xg(this.movingMeanInitializer),movingVarianceInitializer:xg(this.movingVarianceInitializer),betaRegularizer:tx(this.betaRegularizer),gammaRegularizer:tx(this.gammaRegularizer),betaConstraint:cm(this.betaConstraint),gammaConstraint:cm(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}mw.className="BatchNormalization",Wi(mw);class gw extends ey{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=wg(e.betaInitializer||"zeros"),this.gammaInitializer=wg(e.gammaInitializer||"ones"),this.betaRegularizer=rx(e.betaRegularizer),this.gammaRegularizer=rx(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=Ug(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==Yf(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(e,t){const n=Wg(e),r=n.shape,s=r.length;return lo((()=>{let{mean:e,variance:t}=ic(n,this.axis,!0);const a=zf(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s&&this.axis!==[s-1]?e.reshape(a):e;let o=i(this.gamma.read()),u=i(this.beta.read());const l=[],c=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(l.push(r[e]),c.push(1)):(l.push(1),c.push(r[e]));return e=e.tile(l),t=t.tile(l),o=o.tile(c),u=u.tile(c),dw(n,e,t,u,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xg(this.betaInitializer),gammaInitializer:xg(this.gammaInitializer),betaRegularizer:tx(this.betaRegularizer),gammaRegularizer:tx(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}gw.className="LayerNormalization",Wi(gw);class yw extends ey{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Of(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Of(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Of(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Xg({ndim:4})]}computeOutputShape(e){let t,n;return e=Ug(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return lo((()=>{return t=Wg(e),n=this.padding,r=this.dataFormat,lo((()=>{if(4!==t.rank)throw new Of(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Of("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new Of(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],fc(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function bw(e,t,n,r,s,a){return lo((()=>{let i;Im(s),Sm(a),Nm(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=dx(e,s);const o="same"===r?"same":"valid";return i="max"===a?Zl(e,t,n,o):Cu(e,t,n,o),"channelsFirst"===s&&(i=fi(i,[0,3,1,2])),i}))}function xw(e,t,n,r,s,a){return lo((()=>{let i;Im(s),Sm(a),Nm(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=fx(e,s);const o="same"===r?"same":"valid";return i="max"===a?Ql(e,t,n,o):Eu(e,t,n,o),"channelsFirst"===s&&(i=fi(i,[0,4,1,2,3])),i}))}yw.className="ZeroPadding2D",Wi(yw);class ww extends ey{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Of(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(em(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Of(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}em(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Nm(this.padding),this.inputSpec=[new Xg({ndim:3})]}computeOutputShape(e){const t=hx((e=Ug(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return lo((()=>{this.invokeCallHook(e,t),e=zm(Wg(e),2);const n=this.poolingFunction(Wg(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ih(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class vw extends ww{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),bw(e,t,n,r,s,"max")}}vw.className="MaxPooling1D",Wi(vw);class kw extends ww{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),bw(e,t,n,r,s,"avg")}}kw.className="AveragePooling1D",Wi(kw);class Iw extends ey{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Of(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];em(this.poolSize,"poolSize"),em(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Im(this.dataFormat),Nm(this.padding),this.inputSpec=[new Xg({ndim:4})]}computeOutputShape(e){e=Ug(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=hx(t,this.poolSize[0],this.padding,this.strides[0]),n=hx(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return lo((()=>(this.invokeCallHook(e,t),this.poolingFunction(Wg(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Nw extends Iw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),bw(e,t,n,r,s,"max")}}Nw.className="MaxPooling2D",Wi(Nw);class Sw extends Iw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),bw(e,t,n,r,s,"avg")}}Sw.className="AveragePooling2D",Wi(Sw);class Cw extends ey{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Of(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];em(this.poolSize,"poolSize"),em(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Im(this.dataFormat),Nm(this.padding),this.inputSpec=[new Xg({ndim:5})]}computeOutputShape(e){e=Ug(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=hx(t,this.poolSize[0],this.padding,this.strides[0]),n=hx(n,this.poolSize[1],this.padding,this.strides[1]),r=hx(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return lo((()=>(this.invokeCallHook(e,t),this.poolingFunction(Wg(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ew extends Cw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),xw(e,t,n,r,s,"max")}}Ew.className="MaxPooling3D",Wi(Ew);class Tw extends Cw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Im(s),Nm(r),xw(e,t,n,r,s,"avg")}}Tw.className="AveragePooling3D",Wi(Tw);class $w extends ey{constructor(e){super(e),this.inputSpec=[new Xg({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Mf}}class Aw extends $w{constructor(e){super(e||{})}call(e,t){return lo((()=>{const t=Wg(e);return tc(t,1)}))}}Aw.className="GlobalAveragePooling1D",Wi(Aw);class Rw extends $w{constructor(e){super(e||{})}call(e,t){return lo((()=>{const t=Wg(e);return Ml(t,1)}))}}Rw.className="GlobalMaxPooling1D",Wi(Rw);class _w extends ey{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Im(this.dataFormat),this.inputSpec=[new Xg({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Mf}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Fw extends _w{call(e,t){return lo((()=>{const t=Wg(e);return"channelsLast"===this.dataFormat?tc(t,[1,2]):tc(t,[2,3])}))}}Fw.className="GlobalAveragePooling2D",Wi(Fw);class Dw extends _w{call(e,t){return lo((()=>{const t=Wg(e);return"channelsLast"===this.dataFormat?Ml(t,[1,2]):Ml(t,[2,3])}))}}Dw.className="GlobalMaxPooling2D",Wi(Dw);class Ow extends ey{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=my(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class Mw extends Ow{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Ug(e)).length<3)throw new Of(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=Ug(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return lo((()=>Ax(((e,n)=>[Wg(this.layer.call(e,t)),[]]),e=Wg(e),[],!1,null,null,!1,!0)[1]))}}Mw.className="TimeDistributed",Wi(Mw);class Lw extends Ow{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=my(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=my(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,Zf(vm,"BidirectionalMergeMode",s),e.weights)throw new Mf("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState?(r=s.slice(1),t=s[0]):t=s[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):Vf(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=$x(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new Of("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new Xg({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new Mf("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof Yg;for(const e of a)if(e instanceof Yg!==o)throw new Of("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return lo((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Mc(s,1)),"concat"===this.mergeMode?i=Wm([r,s]):"sum"===this.mergeMode?i=Io(r,s):"ave"===this.mergeMode?i=Co(.5,Io(r,s)):"mul"===this.mergeMode?i=Co(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Em(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Em(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=my(t.layer);if(delete t.layer,null!=t.numConstants)throw new Mf("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}function zw(e){return new ny(e)}function Bw(e){return new ox(e)}function Pw(e){return new sx(e)}function Vw(e){return new ax(e)}function Ww(e){return new ix(e)}function Uw(e){return new lx(e)}function Gw(e){return new ux(e)}function jw(e){return new Sx(e)}function Hw(e){return new wx(e)}function qw(e){return new kx(e)}function Kw(e){return new vx(e)}function Xw(e){return new Nx(e)}function Yw(e){return new Cx(e)}function Jw(e){return new Ex(e)}function Zw(e){return new Tx(e)}function Qw(e){return new Xx(e)}function ev(e){return new qx(e)}function tv(e){return new jx(e)}function nv(e){return new Hx(e)}function rv(e){return new Kx(e)}function sv(e){return new Yx(e)}function av(e){return new Jx(e)}function iv(e){return new Zx(e)}function ov(e){return new ew(e)}function uv(e){return new nw(e)}function lv(e){return new sw(e)}function cv(e){return new ow(e)}function hv(e){return new aw(e)}function pv(e){return new iw(e)}function dv(e){return new rw(e)}function fv(e){return new lw(e)}function mv(e){return new mw(e)}function gv(e){return new gw(e)}function yv(e){return new yw(e)}function bv(e){return new kw(e)}function xv(e){return bv(e)}function wv(e){return bv(e)}function vv(e){return new Sw(e)}function kv(e){return vv(e)}function Iv(e){return vv(e)}function Nv(e){return new Tw(e)}function Sv(e){return Nv(e)}function Cv(e){return Nv(e)}function Ev(e){return new Aw(e)}function Tv(e){return new Fw(e)}function $v(e){return new Rw(e)}function Av(e){return new Dw(e)}function Rv(e){return new vw(e)}function _v(e){return new Nw(e)}function Fv(e){return new Ew(e)}function Dv(e){return new Mx(e)}function Ov(e){return new Ox(e)}function Mv(e){return new zx(e)}function Lv(e){return new Lx(e)}function zv(e){return new Dx(e)}function Bv(e){return new Fx(e)}function Pv(e){return new Gx(e)}function Vv(e){return new Ux(e)}function Wv(e){return new Rx(e)}function Uv(e){return new Bx(e)}function Gv(e){return new Lw(e)}function jv(e){return new Mw(e)}Lw.className="Bidirectional",Wi(Lw);const Hv=$v,qv=Av,Kv=Rv,Xv=_v;function Yv(e){return new cw(e)}function Jv(e){return new hw(e)}function Zv(e){return new pw(e)}function Qv(e){return new Qx(e)}function ek(e,t){return Ty(e,t)}function tk(e,t){return Fy(e,t)}function nk(e,t){return Dy(e,t)}function rk(e,t){return $y(e,t)}function sk(e,t){return Oy(e,t)}function ak(e,t){return Ry(e,t)}function ik(e,t){return _y(e,t)}function ok(e,t){return Sy(e,t)}function uk(e,t){return by(e,t)}function lk(e,t){return xy(e,t)}function ck(e,t){return xy(e,t)}function hk(e,t){return xy(e,t)}function pk(e,t){return yy(e,t)}function dk(e,t){return yy(e,t)}function fk(e,t){return yy(e,t)}function mk(e){return new Qb(e)}function gk(e){return Jb(t=e),new Qb({l1:null!=t?t.l1:null,l2:0});var t}function yk(e){return Jb(t=e),new Qb({l2:null!=t?t.l2:null,l1:0});var t}class bk extends oy{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Nb))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function xk(e,t){return e<t}function wk(e,t){return e>t}class vk extends bk{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new Mf("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=xk:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=wk:this.monitorFunc=xk,this.monitorFunc===xk&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===xk?1/0:-1/0}async onEpochEnd(e,t){await sy(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}const kk={earlyStopping:function(e){return new vk(e)}};var Ik,Nk;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(Ik||(Ik={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Nk||(Nk={}));const Sk={};function Ck(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Sk[e]=n}function Ek(e){return Sk[e]}function Tk(e){delete Sk[e]}function $k(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd;if("tensor"===a.type)return Ak(t.inputNames[a.inputIndexStart],n,r,s);if("tensors"===a.type){return t.inputNames.slice(e,i).map((e=>Ak(e,n,r,s)))}const o=Ak(t.inputNames.slice(e)[0],n,r,s),u=o.dataSync();return"number"===a.type?u[0]:Re(o.shape,u)}const i=t.attrParams[e];return i&&i.value}function Ak(e,t,n,r){const[s,a]=Fk(e);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[_k(s,e)]));return void 0!==i?t[_k(s,i)][a]:void 0}function Rk(e,t){const[n,r]=Fk(e);return[_k(n,t&&t.currentContextId),r]}function _k(e,t){return t?`${e}-${t}`:e}function Fk(e){const t=e.split(":");if(1===t.length)return[e,0];return[t[0],Number(t[t.length-1])]}function Dk(e,t,n){let r=$k("pad",e,t,n);if("explicit"===r){r=$k("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function Ok(e){return e.kept?e:qa(e)}const Mk=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Lk=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zk=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],Bk=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Pk=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Vk=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Wk=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Uk=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Gk=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}],jk=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Hk=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],qk=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Kk=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Xk=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Yk=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Jk=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Zk=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class Qk{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[N,S,C,E,T,$,A,D,F,R,O,M,L,z,B,P,_].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const u=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach((e=>{const t=i[e];t.inputNames.forEach((e=>{const[n]=Rk(e);t.inputs.push(i[n]),i[n].children.push(t)}))})),0===Object.keys(c).length?h.forEach((e=>{const t=i[e];0===t.children.length&&u.push(t)})):Object.keys(c).forEach((e=>{const[t]=Rk(e),n=i[t];null!=n&&(n.signatureKey=c[e],u.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=Rk(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))})):o=r;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const d={nodes:i,inputs:o,outputs:u,weights:s,placeholders:r,signature:t,functions:p};return a.length>0&&(d.initNodes=a),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=Ek(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=tI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=tI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=hI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=hI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=rI(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=rI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=cI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=cI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=nI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=nI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=dI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=dI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=lI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=lI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=pI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=pI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=iI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=oI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=oI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=aI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=Rk(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sI(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach((e=>{const[n]=Rk(e);t.inputs.push(r[n]),r[n].children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Rk(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function eI(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=Ve().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function tI(e,t,n,r=!1){const s=e[t];return null!=s?eI(s.s,r):n}function nI(e,t,n){const r=e[t];return r?r.b:n}function rI(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function sI(e){switch("string"==typeof e&&(e=Ik[e]),e){case Ik.DT_FLOAT:return"float32";case Ik.DT_INT32:case Ik.DT_INT64:case Ik.DT_INT8:case Ik.DT_UINT8:return"int32";case Ik.DT_BOOL:return"bool";case Ik.DT_DOUBLE:return"float32";case Ik.DT_STRING:return"string";default:return null}}function aI(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function iI(e,t,n){const r=e[t];return r&&r.type?sI(r.type):n}function oI(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>sI(e))):n}function uI(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function lI(e,t,n){const r=e[t];return r&&r.shape?uI(r.shape):n}function cI(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function hI(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>eI(e,r))):n}function pI(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>uI(e))):n}function dI(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class fI{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Ak(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Ak(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return rI(this.node.rawAttrs,e,t);if(null!=n.s)return tI(this.node.rawAttrs,e,t);if(null!=n.b)return nI(this.node.rawAttrs,e,t);if(null!=n.shape)return lI(this.node.rawAttrs,e,t);if(null!=n.type)return iI(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return cI(this.node.rawAttrs,e,t);if(null!=n.list.s)return hI(this.node.rawAttrs,e,t);if(null!=n.list.shape)return pI(this.node.rawAttrs,e,t);if(null!=n.list.b)return dI(this.node.rawAttrs,e,t);if(null!=n.list.type)return oI(this.node.rawAttrs,e,t)}return t}}function mI(e,t,n=""){Q(function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(-1!==e[n]&&-1!==t[n]&&e[n]!==t[n])return!1;return!0}(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}class gI{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Lo(0),ho(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),mI(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ho(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Js([],[0].concat(this.elementShape));const n=this.readMany(e);return mI(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),oh(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Js([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return mI(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Tu(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,wh(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];lo((()=>{t=Su(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Su(Au(t,i,o),this.elementShape)}return a}));const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,a)}}class yI{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);mI(t,e.shape,"TensorList shape mismatch: "),ho(e)})),this.idTensor=Lo(0),this.maxNumElements=r,ho(this.idTensor)}get id(){return this.idTensor.id}copy(){return new yI([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);return mI(e,this.elementShape,"TensorList shape mismatch: "),lo((()=>{const t=this.tensors.map((t=>Su(t,e)));return oh(t,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=this.tensors.pop();return mI(n.shape,e,"TensorList shape mismatch: "),Su(n,e)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(mI(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ho(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);return mI(this.tensors[e].shape,t,"TensorList shape mismatch: "),this.tensors[e]}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);mI(this.elementShape,t.shape,"TensorList shape mismatch: "),ho(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);return mI(this.elementShape,n,"TensorList shape mismatch: "),0===(e=e.slice(0,this.size())).length?Js([],[0].concat(this.elementShape)):lo((()=>{const t=e.map((e=>Su(this.tensors[e],n)));return oh(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);return mI(this.elementShape,t,"TensorList shape mismatch: "),0===this.size()?Js([],[0].concat(this.elementShape)):lo((()=>{const e=this.tensors.map((e=>Su(e,t)));return Tu(e,0)}))}}const bI=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=$k("thenBranch",e,t,n),s=$k("elseBranch",e,t,n),a=$k("cond",e,t,n),i=$k("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=$k("body",e,t,n),s=$k("cond",e,t,n),a=$k("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let u=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let l=a;for(;u[0];){const e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[Ok($k("pred",e,t,n))];case"Switch":{const r=$k("pred",e,t,n);let s=$k("data",e,t,n);return s.kept||(s=Ok(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==Ak(e,t,n)));if(r){return[Ok(Ak(r,t,n))]}return}case"Enter":{const r=$k("frameName",e,t,n),s=$k("tensor",e,t,n);return n.enterFrame(r),[Ok(s)]}case"Exit":{const r=$k("tensor",e,t,n);return n.exitFrame(),[Ok(r)]}case"NextIteration":{const r=$k("tensor",e,t,n);return n.nextIteration(),[Ok(r)]}case"TensorArrayV3":{const r=$k("size",e,t,n),s=$k("dtype",e,t,n),a=$k("elementShape",e,t,n),i=$k("dynamicSize",e,t,n),o=$k("clearAfterRead",e,t,n),u=$k("identicalElementShapes",e,t,n),l=$k("name",e,t,n),c=new gI(l,s,r,a,u,i,o);return n.addTensorArray(c),[c.idTensor,Lo(1)]}case"TensorArrayWriteV3":{const r=$k("tensorArrayId",e,t,n),s=$k("index",e,t,n),a=$k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=$k("tensorArrayId",e,t,n),s=$k("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=$k("tensorArrayId",e,t,n),s=$k("indices",e,t,n),a=$k("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=$k("tensorArrayId",e,t,n),s=$k("indices",e,t,n),a=$k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=$k("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=$k("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=$k("tensorArrayId",e,t,n),s=$k("tensor",e,t,n),a=$k("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=$k("tensorArrayId",e,t,n);return[Lo(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=$k("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=$k("tensorListId",e,t,n),s=$k("index",e,t,n),a=$k("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=$k("tensorListId",e,t,n),s=$k("index",e,t,n),a=$k("elementShape",e,t,n),i=$k("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=$k("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new yI([],n,e.dtype,r),i=wh(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}($k("tensor",e,t,n),r,$k("elementShape",e,t,n),$k("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=$k("elementShape",e,t,n),s=$k("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=function(e,t,n){return new yI([],e,t,n)}(r,s,$k(a,e,t,n));return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=$k("tensorListId",e,t,n),s=$k("indices",e,t,n),a=$k("elementShape",e,t,n),i=$k("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=$k("tensorListId",e,t,n),s=$k("elementShape",e,t,n),a=$k("elementDType",e,t,n),i=$k("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);mI(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=wh(e);return new yI(s,t,r)}($k("tensor",e,t,n),$k("elementShape",e,t,n),$k("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=$k("tensorListId",e,t,n),s=n.getTensorList(r.id),a=$k("dtype",e,t,n),i=$k("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=$k("tensorListId",e,t,n),s=$k("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=$k("tensorListId",e,t,n),s=$k("elementShape",e,t,n),a=$k("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=$k("tensor",e,t,n),s=$k("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=0===r?0:e.size/r,i=lo((()=>{const i=[];e=Su(e,[1,r,a]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],u=[1,t[r],a];i[r]=Su(Au(e,o,u),n)}return e.dispose(),i})),o=new yI([],n,e.dtype,t.length);for(let e=0;e<i.length;e++)o.setItem(e,i[e]);return o}(r,$k("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function xI(e,t,n){const[r,s]=$k("fusedOps",e,t,n),a="biasadd"===r,i="prelu"===s,o="fusedbatchnorm"===r,u=$k("numArgs",e,t,n);if(a){if(i&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(o)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const l=$k("strides",e,t,n),c=Dk(e,t,n),h=$k("dataFormat",e,t,n).toUpperCase(),p=$k("dilations",e,t,n),[d,f]=$k("args",e,t,n);return{stride:l,pad:c,dataFormat:h,dilations:p,biasArg:d,preluArg:f,activationFunc:s,leakyreluAlpha:$k("leakyreluAlpha",e,t,n)}}function wI(e,t,n){return{boxes:$k("boxes",e,t,n),scores:$k("scores",e,t,n),maxOutputSize:$k("maxOutputSize",e,t,n),iouThreshold:$k("iouThreshold",e,t,n),scoreThreshold:$k("scoreThreshold",e,t,n),softNmsSigma:$k("softNmsSigma",e,t,n)}}class vI{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Lo(0),this.tensorMap=new Map,ho(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),lo((()=>{const e=wh(t),r=n.length,s=e.length;Q(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];ho(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return lo((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return oh(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function kI(e,t,n,r){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return lo((()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Io($k("a",e,t,n),$k("b",e,t,n))];case"AddN":return[nu($k("tensors",e,t,n))];case"FloorMod":case"Mod":return[ac($k("a",e,t,n),$k("b",e,t,n))];case"Mul":return[Co($k("a",e,t,n),$k("b",e,t,n))];case"RealDiv":case"Div":return[So($k("a",e,t,n),$k("b",e,t,n))];case"DivNoNan":return[ll($k("a",e,t,n),$k("b",e,t,n))];case"FloorDiv":return[No($k("a",e,t,n),$k("b",e,t,n))];case"Sub":return[Uo($k("a",e,t,n),$k("b",e,t,n))];case"Minimum":return[rc($k("a",e,t,n),$k("b",e,t,n))];case"Maximum":return[Xo($k("a",e,t,n),$k("b",e,t,n))];case"Pow":return[Wo($k("a",e,t,n),$k("b",e,t,n))];case"SquaredDifference":return[ah($k("a",e,t,n),$k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return lo((()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[jo($k("x",e,t,n))];case"Acos":return[eu($k("x",e,t,n))];case"Acosh":return[tu($k("x",e,t,n))];case"Asin":return[ou($k("x",e,t,n))];case"Asinh":return[uu($k("x",e,t,n))];case"Atan":return[lu($k("x",e,t,n))];case"Atan2":return[cu($k("x",e,t,n),$k("y",e,t,n))];case"Atanh":return[hu($k("x",e,t,n))];case"Ceil":return[Pu($k("x",e,t,n))];case"Complex":return[Xs($k("real",e,t,n),$k("imag",e,t,n))];case"Cos":return[Qu($k("x",e,t,n))];case"Cosh":return[el($k("x",e,t,n))];case"Elu":return[hl($k("x",e,t,n))];case"Erf":return[pl($k("x",e,t,n))];case"Exp":return[dl($k("x",e,t,n))];case"Expm1":return[ml($k("x",e,t,n))];case"Floor":return[bl($k("x",e,t,n))];case"Log":return[Rl($k("x",e,t,n))];case"Log1p":return[_l($k("x",e,t,n))];case"Imag":return[kl($k("x",e,t,n))];case"Neg":return[Fl($k("x",e,t,n))];case"Reciprocal":return[Fc($k("x",e,t,n))];case"Real":return[_c($k("x",e,t,n))];case"Relu":return[Dc($k("x",e,t,n))];case"Round":return[Vc($k("x",e,t,n))];case"Selu":return[Uc($k("x",e,t,n))];case"Sigmoid":return[$u($k("x",e,t,n))];case"Sin":return[qc($k("x",e,t,n))];case"Sign":return[Hc($k("x",e,t,n))];case"Sinh":return[Kc($k("x",e,t,n))];case"Softplus":return[Dl($k("x",e,t,n))];case"Sqrt":return[Eo($k("x",e,t,n))];case"Square":return[To($k("x",e,t,n))];case"Tanh":return[Ru($k("x",e,t,n))];case"Tan":return[ch($k("x",e,t,n))];case"ClipByValue":return[Vu($k("x",e,t,n),$k("clipValueMin",e,t,n),$k("clipValueMax",e,t,n))];case"Relu6":return[Oc($k("x",e,t,n))];case"Rsqrt":return[Wc(Ak(e.inputNames[0],t,n))];case"Prod":return[kc($k("x",e,t,n),$k("axes",e,t,n))];case"LeakyRelu":return[Cl($k("x",e,t,n),$k("alpha",e,t,n))];case"Prelu":return[vc($k("x",e,t,n),$k("alpha",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return bI(e,t,n);case"convolution":return lo((()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const r=$k("stride",e,t,n),s=$k("pad",e,t,n),a=$k("dataFormat",e,t,n).toUpperCase(),i=$k("dilation",e,t,n);return[qu($k("x",e,t,n),$k("filter",e,t,n),r,s,a,i)]}case"Conv2D":{const r=$k("strides",e,t,n),s=Dk(e,t,n),a=$k("dataFormat",e,t,n).toUpperCase(),i=$k("dilations",e,t,n);return[Hu($k("x",e,t,n),$k("filter",e,t,n),[r[1],r[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:a,dilations:i,biasArg:o,preluArg:u,activationFunc:l,leakyreluAlpha:c}=xI(e,t,n);return[Ph({x:$k("x",e,t,n),filter:$k("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:o,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:a,dilations:i,biasArg:o,preluArg:u,activationFunc:l,leakyreluAlpha:c}=xI(e,t,n);return[Uh({x:$k("x",e,t,n),filter:$k("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:o,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=$k("outputShape",e,t,n),s=$k("strides",e,t,n),a=Dk(e,t,n);return[Xu($k("x",e,t,n),$k("filter",e,t,n),r,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=$k("strides",e,t,n),s=Dk(e,t,n),a=$k("dilations",e,t,n),i=$k("dataFormat",e,t,n).toUpperCase();return[sl($k("input",e,t,n),$k("filter",e,t,n),[r[1],r[2]],s,i,[a[1],a[2]])]}case"Conv3D":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("dataFormat",e,t,n).toUpperCase(),i=$k("dilations",e,t,n);return[Yu($k("x",e,t,n),$k("filter",e,t,n),[r[1],r[2],r[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("kernelSize",e,t,n);return[Cu($k("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("kernelSize",e,t,n);return[Zl($k("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("kernelSize",e,t,n),i=$k("includeBatchInIndex",e,t,n),{result:o,indexes:u}=ec($k("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s,i);return[o,u]}case"AvgPool3D":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("kernelSize",e,t,n);return[Eu($k("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("kernelSize",e,t,n);return[Ql($k("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=$k("strides",e,t,n),s=$k("pad",e,t,n),a=$k("dilations",e,t,n),i=r[1],o=r[2],u=a[1],l=a[2];return[il($k("x",e,t,n),$k("filter",e,t,n),[i,o],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return lo((()=>((e,t,n)=>{switch(e.op){case"Fill":{const r=$k("shape",e,t,n),s=$k("dtype",e,t,n);return[Po(r,$k("value",e,t,n),s)]}case"LinSpace":return[$l($k("start",e,t,n),$k("stop",e,t,n),$k("num",e,t,n))];case"Multinomial":{const r=$k("logits",e,t,n),s=$k("numSamples",e,t,n),a=$k("seed",e,t,n);return[uc(r,s,a)]}case"OneHot":{const r=$k("indices",e,t,n),s=$k("depth",e,t,n),a=$k("onValue",e,t,n),i=$k("offValue",e,t,n);return[di(r,s,a,i)]}case"Ones":return[hc($k("shape",e,t,n),$k("dtype",e,t,n))];case"OnesLike":return[pc($k("x",e,t,n))];case"RandomUniform":return[Ac($k("shape",e,t,n),$k("minval",e,t,n),$k("maxval",e,t,n),$k("dtype",e,t,n))];case"Range":return[Rc($k("start",e,t,n),$k("stop",e,t,n),$k("step",e,t,n),$k("dtype",e,t,n))];case"TruncatedNormal":{const r=$k("shape",e,t,n),s=$k("mean",e,t,n),a=$k("stdDev",e,t,n),i=$k("seed",e,t,n);return[yh(r,s,a,$k("dtype",e,t,n),i)]}case"Zeros":return[cc($k("shape",e,t,n),$k("dtype",e,t,n))];case"ZerosLike":return[$o($k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}=wI(e,t,n),l=await _p.nonMaxSuppressionWithScoreAsync(r,s,a,i,o,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o}=wI(e,t,n),u=$k("padToMaxOutputSize",e,t,n),l=await _p.nonMaxSuppressionPaddedAsync(r,s,a,i,o,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o}=wI(e,t,n);return[await _p.nonMaxSuppressionAsync(r,s,a,i,o)]}case"Where":{const r=Ha($k("condition",e,t,n),"bool"),s=[await Ih(r)];return r.dispose(),s}case"ListDiff":return jc($k("x",e,t,n),$k("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return lo((()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const r=$k("x",e,t,n),s=$k("k",e,t,n),a=$k("sorted",e,t,n),i=gh(r,s,a);return[i.values,i.indices]}case"Unique":{const r=$k("x",e,t,n),s=bh(r);return[s.values,s.indices]}case"UniqueV2":{const r=$k("x",e,t,n),s=$k("axis",e,t,n),a=bh(r,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return lo((()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=$k("images",e,t,n),s=$k("size",e,t,n),a=$k("alignCorners",e,t,n),i=$k("halfPixelCenters",e,t,n);return[_p.resizeBilinear(r,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{const r=$k("images",e,t,n),s=$k("size",e,t,n),a=$k("alignCorners",e,t,n),i=$k("halfPixelCenters",e,t,n);return[_p.resizeNearestNeighbor(r,[s[0],s[1]],a,i)]}case"CropAndResize":{const r=$k("image",e,t,n),s=$k("boxes",e,t,n),a=$k("boxInd",e,t,n),i=$k("cropSize",e,t,n),o=$k("method",e,t,n),u=$k("extrapolationValue",e,t,n);return[_p.cropAndResize(r,s,a,i,o,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return lo((()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=$k("default",e,t,n);return[Ak(e.name,t,n)||r];case"Placeholder":return[Ak(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[Ok($k("x",e,t,n))];case"IdentityN":return $k("x",e,t,n).map((e=>Ok(e)));case"Snapshot":return[Ok($k("x",e,t,n))];case"Shape":return[hh($k("x",e,t,n).shape,"int32")];case"ShapeN":return $k("x",e,t,n).map((e=>hh(e.shape)));case"Size":return[Lo($k("x",e,t,n).size,"int32")];case"Rank":return[Lo($k("x",e,t,n).rank,"int32")];case"NoOp":return[Lo(1)];case"Print":const s=$k("x",e,t,n),a=$k("data",e,t,n),i=$k("message",e,t,n),o=$k("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<a.length;e++)console.log(Array.prototype.slice.call(a[e].dataSync()).slice(0,o));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return lo((()=>((e,t,n)=>{switch(e.op){case"Equal":return[ol($k("a",e,t,n),$k("b",e,t,n))];case"NotEqual":return[lc($k("a",e,t,n),$k("b",e,t,n))];case"Greater":return[wl($k("a",e,t,n),$k("b",e,t,n))];case"GreaterEqual":return[vl($k("a",e,t,n),$k("b",e,t,n))];case"Less":return[El($k("a",e,t,n),$k("b",e,t,n))];case"LessEqual":return[Tl($k("a",e,t,n),$k("b",e,t,n))];case"LogicalAnd":return[Kl($k("a",e,t,n),$k("b",e,t,n))];case"LogicalNot":return[Xl($k("a",e,t,n))];case"LogicalOr":return[Yl($k("a",e,t,n),$k("b",e,t,n))];case"Select":case"SelectV2":return[ul($k("condition",e,t,n),$k("a",e,t,n),$k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return lo((()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[pi($k("a",e,t,n),$k("b",e,t,n),$k("transposeA",e,t,n),$k("transposeB",e,t,n))];case"Transpose":return[fi($k("x",e,t,n),$k("perm",e,t,n))];case"_FusedMatMul":const[r,s]=$k("fusedOps",e,t,n),a="biasadd"===r,i="prelu"===s,o=$k("numArgs",e,t,n),u=$k("leakyreluAlpha",e,t,n);if(a){if(i&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=$k("args",e,t,n);return[Gh({a:$k("a",e,t,n),b:$k("b",e,t,n),transposeA:$k("transposeA",e,t,n),transposeB:$k("transposeB",e,t,n),bias:l,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return lo((()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Du($k("x",e,t,n),$k("mean",e,t,n),$k("variance",e,t,n),$k("offset",e,t,n),$k("scale",e,t,n),$k("epsilon",e,t,n))];case"LRN":return[Al($k("x",e,t,n),$k("radius",e,t,n),$k("bias",e,t,n),$k("alpha",e,t,n),$k("beta",e,t,n))];case"Softmax":return[Qc($k("x",e,t,n))];case"LogSoftmax":return[zl($k("x",e,t,n))];case"SparseToDense":return[$h($k("sparseIndices",e,t,n),$k("outputShape",e,t,n),$k("sparseValues",e,t,n),$k("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return lo((()=>((e,t,n)=>{switch(e.op){case"Max":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[Ml($k("x",e,t,n),r,s)]}case"Mean":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[tc($k("x",e,t,n),r,s)]}case"Min":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[nc($k("x",e,t,n),r,s)]}case"Sum":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[Ll($k("x",e,t,n),r,s)]}case"All":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[ru($k("x",e,t,n),r,s)]}case"Any":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[su($k("x",e,t,n),r,s)]}case"ArgMax":{const r=$k("axis",e,t,n);return[au($k("x",e,t,n),r)]}case"ArgMin":{const r=$k("axis",e,t,n);return[iu($k("x",e,t,n),r)]}case"Prod":{const r=$k("axis",e,t,n),s=$k("keepDims",e,t,n);return[kc($k("x",e,t,n),r,s)]}case"Cumsum":{const r=$k("axis",e,t,n),s=$k("exclusive",e,t,n),a=$k("reverse",e,t,n);return[tl($k("x",e,t,n),r,s,a)]}case"Bincount":const r=$k("x",e,t,n),s=$k("weights",e,t,n),a=$k("size",e,t,n);return[zu(r,s,a)];case"DenseBincount":{const r=$k("x",e,t,n),s=$k("weights",e,t,n),a=$k("size",e,t,n),i=$k("binaryOutput",e,t,n);return[nl(r,s,a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return lo((()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=$k("n",e,t,n),s=$k("axis",e,t,n);let a=$k("tensors",e,t,n);return a=a.slice(0,r),[Tu(a,s)]}case"Gather":{const r=$k("x",e,t,n),s=$k("indices",e,t,n);return[xl(r,Ha(s,"int32"),0)]}case"GatherV2":{const r=$k("axis",e,t,n),s=$k("batchDims",e,t,n),a=$k("x",e,t,n),i=$k("indices",e,t,n);return[xl(a,Ha(i,"int32"),r,s)]}case"Reverse":{const r=$k("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const a=$k("x",e,t,n);return[Mc(a,s)]}case"ReverseV2":{const r=$k("axis",e,t,n),s=$k("x",e,t,n);return[Mc(s,r)]}case"Slice":{const r=$k("begin",e,t,n),s=$k("size",e,t,n);return[Au($k("x",e,t,n),r,s)]}case"StridedSlice":{const r=$k("begin",e,t,n),s=$k("end",e,t,n),a=$k("strides",e,t,n),i=$k("beginMask",e,t,n),o=$k("endMask",e,t,n),u=$k("ellipsisMask",e,t,n),l=$k("newAxisMask",e,t,n),c=$k("shrinkAxisMask",e,t,n),h=$k("x",e,t,n);return[lh(h,r,s,a,i,o,u,l,c)]}case"Pack":return lo((()=>{const r=$k("axis",e,t,n),s=$k("tensors",e,t,n),a=s[0].shape,i=ih(s[0]).shape,o=s.map((e=>{const t=ae(e.shape,a);if(!t&&!ae(ih(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:Su(e,a)}));return[oh(o,r)]}));case"Unpack":{const r=$k("axis",e,t,n),s=$k("tensor",e,t,n);return wh(s,r)}case"Tile":{const r=$k("reps",e,t,n);return[gl($k("x",e,t,n),r)]}case"Split":case"SplitV":{const r=$k("axis",e,t,n),s=$k("numOrSizeSplits",e,t,n),a=$k("x",e,t,n);return rh(a,s,r)}case"ScatterNd":{const r=$k("indices",e,t,n),s=$k("values",e,t,n),a=$k("shape",e,t,n);return[Th(r,s,a)]}case"GatherNd":{const r=$k("x",e,t,n),s=$k("indices",e,t,n);return[Ah(r,s)]}case"SparseToDense":{const r=$k("sparseIndices",e,t,n),s=$k("outputShape",e,t,n),a=$k("sparseValues",e,t,n),i=$k("defaultValue",e,t,n);return[$h(r,a,s,a.dtype===i.dtype?i:Ha(i,a.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return lo((()=>((e,t,n)=>{switch(e.op){case"FFT":return[eh($k("x",e,t,n))];case"IFFT":return[th($k("x",e,t,n))];case"RFFT":return[sh($k("x",e,t,n))];case"IRFFT":return[nh($k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return lo((()=>((e,t,n)=>{switch(e.op){case"Cast":return[Ha($k("x",e,t,n),$k("dtype",e,t,n))];case"ExpandDims":{const r=$k("axis",e,t,n);return[fl($k("x",e,t,n),r)]}case"Squeeze":{const r=$k("axis",e,t,n);return[ih($k("x",e,t,n),r)]}case"Reshape":return[Su($k("x",e,t,n),$k("shape",e,t,n))];case"MirrorPad":return[sc($k("x",e,t,n),$k("padding",e,t,n),$k("mode",e,t,n))];case"PadV2":case"Pad":return[fc($k("x",e,t,n),$k("padding",e,t,n),$k("constantValue",e,t,n))];case"SpaceToBatchND":{const r=$k("blockShape",e,t,n),s=$k("paddings",e,t,n);return[xc($k("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=$k("blockShape",e,t,n),s=$k("crops",e,t,n);return[Fu($k("x",e,t,n),r,s)]}case"DepthToSpace":{const r=$k("blockSize",e,t,n),s=$k("dataFormat",e,t,n).toUpperCase();return[rl($k("x",e,t,n),r,s)]}case"BroadcastTo":return[Bu($k("x",e,t,n),$k("shape",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=$k("keyDType",e,t,n),a=$k("valueDType",e,t,n),i=new vI(s,a);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=$k("tableHandle",e,t,n,r),a=$k("keys",e,t,n),i=$k("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=$k("tableHandle",e,t,n,r),a=$k("keys",e,t,n),i=$k("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const s=Ek(e.op);if(s&&s.customExecutor)return s.customExecutor(new fI(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return ze(s)?s.then((e=>[].concat(e))):[].concat(s)}class II{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function NI(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const u=new Set,l=Object.keys(e).map((e=>Fk(e)[0]));let c=[];null!=r&&(c=r.map((e=>Fk(e.name)[0])));const h=[...t];for(;h.length>0;){const e=h.pop();(TI(e)||$I(e)||AI(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(-1===l.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{u.has(e.name)||(u.add(e.name),h.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}const SI=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],CI=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],EI=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function TI(e){return SI.indexOf(e.op)>=0}function $I(e){return CI.indexOf(e.op)>=0}function AI(e){return EI.indexOf(e.op)>=0}class RI{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new RI(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=NI(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:s}=n,a=[],i=Object.keys(s).map((e=>Fk(e)[0])).map((t=>e.nodes[t])),o=e.initNodes;i.forEach((e=>{r.has(e.name)&&a.push(e)})),e.weights.forEach((e=>{r.has(e.name)&&a.push(e)})),null!=o&&o.forEach((e=>{r.has(e.name)&&a.push(e)}));const u=new Set,l=[];for(;a.length>0;){const e=a.pop();u.add(e.name),t[e.name]||l.push(e),e.children.forEach((e=>{!u.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>u.has(e.name)))&&a.push(e)}))}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[Fk(e)[0]])),s=t.map((e=>Fk(e)[0]));let a=s.map((e=>this.graph.nodes[e]));0===a.length&&(a=this._outputs);const i=this.getCompilationKey(r,a);let o=this.compiledMap.get(i);null==o&&(o=this.compile(e,a),this.compiledMap.set(i,o));const u={},l={};return lo((()=>{const n=new II(this.weightMap,u,l,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,s]=Fk(t),a=[];a[s]=e[t],r[n]=a}));const a=this.getFrozenTensorIds(r),i={};for(let e=0;e<o.length;e++){const t=o[e];if(!r[t.name]){const e=kI(t,r,n,this._resourceManager);if(ze(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,a,s,i)}}return null==this.parent&&n.dispose(a),t.map((e=>Ak(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){"control"!==t.category&&-1===a.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,n){return t[_k(e,n.currentContextId)]}(e.name,n,r);null!=t&&t.forEach((e=>{if(e&&!s.has(e.id)){const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,r={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const a=new II(this.weightMap,r,s,this.functionExecutorMap),i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>Ak(e,i,a))),u=o.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),c=new Set([...u,...l,...this.weightIds]);return Object.keys(i).forEach((e=>{i[e].forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[Fk(e)[0]])),i=n.map((e=>Fk(e)[0]));let o=i.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);const{usedNodes:u,missingInputs:l,dynamicNode:c,syncInputs:h}=NI(e,o,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),d=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=Fk(t),s=[];s[r]=e[t],d[n]=s}));const f={},m=this.getFrozenTensorIds(d),g={};for(;p.length>0;){const e=this.processStack(a,p,t,d,g,m,i,f,u);await Promise.all(e)}null!=c||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=o.filter((e=>!TI(e)&&!Ak(e.name,d,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${e}`)}return d}processStack(e,t,n,r,s,a,i,o,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&$k("isConstant",e.node,r,n)&&([c]=Rk(e.node.name,n)),null==r[e.node.name]){const h=kI(e.node,r,n,this._resourceManager);c||([c]=Rk(e.node.name,n));const p=n.currentContext;ze(h)?l.push(h.then((l=>(r[c]=l,n.currentContext=p,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u),l)))):(r[c]=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=Rk(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Ak(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Ak(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=Fk(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Q(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&Q(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Fk(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Fk(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class _I{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class FI{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new _I}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=oi(e,this.loadOptions);else{const t=pa(e,this.loadOptions);if(0===t.length)t.push(oi(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=ea(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new RI(Qk.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Qk.Instance.transformGraph(e.modelInitializer);this.initializer=new RI(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=ha(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ys||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,r)=>(t[n]=e[r],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function DI(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new FI(e,t);return await n.load(),n}const OI="3.0.0";function MI(e,t,n=new Map,r=new Set){if(null==e)return null;if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(VI(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=MI(e[a],t,n,r);s[a]=i}return r.delete(e),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function LI(e,t=BI){return zI(e,t)}function zI(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(VI(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=zI(e.map((e=>e[a])),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function BI(e){return null===e?null:VI(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function PI(e,t){const n=new Map;MI(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(ze(t)){const r=await t;n.set(e,r)}}return MI(e,t,n)}function VI(e){return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof ys))}function WI(e){return function(e,t){return MI(e,t)}(e,UI)}function UI(e){return e instanceof ys?{value:e.clone(),recurse:!1}:VI(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class GI{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class jI extends GI{constructor(){super(jI.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function HI(e){return new YI(e)}function qI(e){return new JI(e)}function KI(e,t){return new uN(e,t)}jI.INITIAL_CAPACITY=32;class XI{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new sN(this,e)}filter(e){return new nN(this,e)}map(e){return new rN(this,e)}mapAsync(e){return new aN(this,e)}serialMapAsync(e){return new aN(this,e).serial()}flatmap(e){return new oN(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new tN(this,e,t)}columnMajorBatch(e,t=!0,n=BI){return this.rowMajorBatch(e,t).map((e=>LI(e,n)))}concatenate(e,t){return new uN(HI([this,e]),t)}take(e){return e<0||null==e?this:new eN(this,e)}skip(e){return e<0||null==e?this:new QI(this,e)}prefetch(e){return new hN(this,e)}shuffle(e,t){return new pN(this,e,t)}serial(){return new ZI(this)}}class YI extends XI{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:WI(e),done:!1}}}class JI extends XI{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class ZI extends XI{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class QI extends XI{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;co(e.value)}return this.upstream.next()}}class eN extends XI{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class tN extends XI{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class nN extends XI{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;co(e.value)}}}class rN extends XI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rs(e.value),n=this.transform(e.value),r=Rs(n);for(const e of t)As(e,r)||e.dispose();return{value:n,done:!1}}}class sN extends XI{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class aN extends XI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rs(e.value),n=await this.transform(e.value),r=Rs(n);for(const e of t)As(e,r)||e.dispose();return{value:n,done:!1}}}class iN extends XI{constructor(){super(),this.outputQueue=new jI,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class oN extends iN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Rs(e.value),n=this.transform(e.value),r=Rs(n);this.outputQueue.pushAll(n);for(const e of t)As(e,r)||e.dispose();return!0}}class uN extends XI{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var lN;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(lN||(lN={}));class cN extends XI{constructor(e,t=lN.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const r=await PI(this.iterators,(function(e){if(e instanceof XI){return{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}}return{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case lN.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case lN.SHORTEST:return{value:null,done:!0};case lN.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class hN extends XI{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new GI(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class pN extends hN{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Nc.alea(n||ls().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class dN{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return Q(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),fN((async()=>(await n.iterator()).columnMajorBatch(e,t,yN)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,fN((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,fN((async()=>(await t.iterator()).filter((t=>lo((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return fN((async()=>(await t.iterator()).map((t=>lo((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return fN((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return fN((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,fN((async()=>KI(qI((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,fN((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=Nc.alea(t||ls().toString());return fN((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,fN((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function fN(e,t=null){return new class extends dN{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function mN(e){return fN((async()=>HI(e)),e.length)}function gN(e){if(!VI(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return fN((async()=>function(e,t=lN.FAIL){return new cN(e,t)}(await PI(e,(e=>{if(e instanceof dN)return{value:e.iterator(),recurse:!1};if(VI(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),lN.SHORTEST)),t)}function yN(e){if(null===e)return null;const t=e[0];if(null==(n=t)||null===(r=n)||"object"!=typeof r&&"function"!=typeof r||Array.isArray(n)||"object"==typeof n&&n instanceof ys||we(n)){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ys?oh(e):Js(e)}(e),recurse:!1}}var n,r;return{value:null,recurse:!0}}dN.MAX_BUFFER_SIZE=1e4;class bN extends dN{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}}const xN='"',wN=Symbol("out"),vN=Symbol("field"),kN=Symbol("quote"),IN=Symbol("quoteafterquote"),NN=Symbol("quoteinquote");class SN extends dN{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new bN(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Q(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Q(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(Q(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const e of Object.keys(this.columnConfigs)){if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){const a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||i){const o=t[s];let u=null;if(""===o)if(i&&void 0!==i.default)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{const e=Number(o);if(isNaN(e))u=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":u=e;break;case"int32":u=Math.floor(e);break;case"bool":u=this.getBoolean(o);break;default:u=e}else u=e}i&&i.isLabel?r[a]=u:n[a]=u}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const s=e.length;let a=wN;for(let t=0;t<s;t++)switch(a){case wN:switch(e.charAt(t)){case xN:r=t+1,a=kN;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),a=wN;break;default:a=vN,r=t}break;case vN:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t)),a=wN,r=t+1}break;case kN:switch(e.charAt(t)){case xN:a=IN}break;case IN:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),a=wN,r=t+1;break;case xN:a=kN;break;default:a=NN}break;case NN:switch(e.charAt(t)){case xN:a=kN}}if(a===IN?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}class CN extends XI{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(Ve().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");const t=new CN(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((r=>{const s=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(re(t));return n.set(e,n.length-e.length),Js(n,t)}}class EN extends XI{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=hh([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,s=n+e,a=t+r;this.cropBox=ph([r,n,a,s],[1,4])}else this.cropBox=ph([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(Ve().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new EN(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Q("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=xi(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return lo((()=>{const t=fl(Ha(e,"float32"),0);let n;n=_p.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return Su(n,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class TN{}class $N extends XI{split(e){return new AN(this,e)}}class AN extends $N{constructor(e,t){super(),this.upstream=e,this.impl=new RN(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class RN extends iN{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class _N extends XI{decodeUTF8(){return new FN(this)}}class FN extends $N{constructor(e){super(),this.upstream=e,this.impl=new DN(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class DN extends iN{constructor(e){if(super(),this.upstream=e,Ve().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=n(589);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=Ve().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}}class ON extends _N{constructor(e,t={}){super(),this.file=e,this.options=t,Q(e instanceof Uint8Array||!!Ve().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let s=r.result;if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),!(s instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(s)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}));return{value:await e,done:!1}}}const MN=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function LN(e){return"string"==typeof e&&"file://"===e.substr(0,7)}class zN extends TN{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(LN(this.input)&&Ve().get("IS_NODE")){const e=n(993);this.input=e.readFileSync(this.input.substr(7))}return new ON(this.input,this.options)}}class BN extends TN{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return LN(this.url)?new zN(this.url,this.fileOptions).iterator():async function(e,t={}){let n,r;"string"==typeof e?n=e:(n=e.url,r=MN(e));const s=await cs(n,r);if(s.ok){const e=new Uint8Array(await s.arrayBuffer());return new ON(e,t)}throw new Error(s.statusText)}(this.url,this.fileOptions)}}function PN(e,t={}){return new SN(new BN(e),t)}function VN(e){const t=qI(e);return fN((async()=>t))}function WN(e){return fN((async()=>{const t=await e();return qI((()=>t.next()))}))}async function UN(e,t){return EN.create(e,t)}async function GN(e){return CN.create(e)}const jN="3.0.0";function HN(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Q("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const qN=kh;class KN extends G{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new U(this,io())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Ve().get("IS_NODE")&&rd("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ie(n[0])){const s=n.map((e=>hs(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r){this.data.set(e,{values:t,dtype:r,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return ad(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>ps(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return ja(e.shape,e.dtype,n)}makeOutput(e,t,n){const r=this.write(e,t,n);return io().makeTensorFromDataId(r,t,n,this)}disposeData(e){if(this.data.has(e)){const{complexTensorInfos:t}=this.data.get(e);null!=t&&(this.disposeData(t.real.dataId),this.disposeData(t.imag.dataId)),this.data.delete(e)}}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.data.has(t)){const e=this.data.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}async time(e){const t=ls();e();return{kernelMs:ls()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){HN([e],"where");const t=this.readSync(e.dataId);return qN(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function XN(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;if(HN(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,u=o.data.get(i.dataId).values,l=re(i.shape),c=n||i.dtype,h=ge(c,l);for(let e=0;e<l;++e)h[e]=t(u[e],s);return o.makeTensorInfo(i.shape,c,h)}}function YN(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;if(HN(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,u=o.data.get(i.dataId).values,l=n||i.dtype,c=t(u,l,s);return o.makeTensorInfo(i.shape,l,c)}}wo("cpu",(()=>new KN),1);const JN=XN(Pt,(e=>e>=0?e:Math.exp(e)-1)),ZN={kernelName:Pt,backendName:"cpu",kernelFunc:JN};function QN(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const eS={kernelName:rn,backendName:"cpu",kernelFunc:QN};function tS(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;HN([s],"leakyRelu");const i=re(s.shape),o=n.data.get(s.dataId).values,u=me("float32",i);for(let e=0;e<o.length;e++)u[e]=o[e]<0?a*o[e]:o[e];return n.makeTensorInfo(s.shape,"float32",u)}const nS={kernelName:cn,backendName:"cpu",kernelFunc:tS};function rS(e){return(t,n,r,s,a)=>{const i=Ko(t,n),o=i.length,u=$e(i),l=me(a,re(i)),c=t.length,h=n.length,p=$e(t),d=$e(n),f=Ho(t,i),m=Ho(n,i);if(f.length+m.length===0)for(let t=0;t<l.length;++t)l[t]=e(r[t%r.length],s[t%s.length]);else for(let t=0;t<l.length;++t){const n=Le(t,o,u),a=n.slice(-c);f.forEach((e=>a[e]=0));const i=Me(a,c,p),g=n.slice(-h);m.forEach((e=>g[e]=0));const y=Me(g,h,d);l[t]=e(r[i],s[y])}return[l,i]}}const sS=rS(((e,t)=>e<0?t*e:e));function aS(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;HN([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,u]=sS(r.shape,s.shape,a,i,r.dtype);return n.makeTensorInfo(u,r.dtype,o)}const iS={kernelName:qn,backendName:"cpu",kernelFunc:aS},oS=XN(Zn,(e=>Math.max(0,e))),uS={kernelName:Zn,backendName:"cpu",kernelFunc:oS},lS=XN(sr,(e=>Math.min(Math.max(0,e),6))),cS={kernelName:sr,backendName:"cpu",kernelFunc:lS};function hS(e,t,n,r,s){if("linear"===n)return QN({inputs:{x:t},backend:e});if("relu"===n)return oS({inputs:{x:t},backend:e});if("elu"===n)return JN({inputs:{x:t},backend:e});if("relu6"===n)return lS({inputs:{x:t},backend:e});if("prelu"===n)return aS({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return tS({inputs:{x:t},backend:e,attrs:{alpha:s}});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function pS(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const dS={kernelName:yt,backendName:"cpu",kernelFunc:pS};function fS(e,t,n="float32"){if("complex64"===n){return pS({inputs:{real:fS(e,t,"float32"),imag:fS(e,t,"float32")},backend:e})}const r=Fe(re(t),n);return e.makeTensorInfo(t,n,r)}function mS(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const gS={kernelName:Yn,backendName:"cpu",kernelFunc:mS};function yS(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return QN({inputs:{x:s},backend:n});const e=fS(n,s.shape,s.dtype),t=yS({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=pS({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=mS({inputs:{input:s},backend:n}),t=yS({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!xe(s.dtype,a)){const e=QN({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a){const e=n.data.get(s.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(s.shape,"int32",t)}if("bool"===a){const e=n.data.get(s.dataId).values,t=us([0],s.dtype),[r,a]=rS(((e,t)=>e!==t?1:0))(s.shape,[],e,t,"bool");return n.makeTensorInfo(a,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const bS={kernelName:ft,backendName:"cpu",kernelFunc:yS};function xS(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:a,b:i}=n,o=s;HN([a,i],e);const u=o.data.get(a.dataId).values,l=o.data.get(i.dataId).values,c=r||a.dtype,[h,p]=t(a.shape,i.shape,u,l,c);return o.makeTensorInfo(p,c,h)}:({inputs:e,backend:s})=>{const{a:a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=yS({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,u=o.data.get(r.dataId).values,l=o.data.get(s.dataId).values,c=yS({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),p=h.complexTensorInfos.real,d=h.complexTensorInfos.imag,f=o.data.get(p.dataId).values,m=o.data.get(d.dataId).values,[g,y,b]=n(a.shape,i.shape,u,l,f,m),x=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",y),v=pS({inputs:{real:x,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(w),v}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[u,l]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(l,s,u)}}}function wS(e){return(t,n,r,s,a,i)=>{const o=Ko(t,n),u=re(o),l=o.length,c=$e(o),h=me("float32",u),p=me("float32",u),d=Ho(t,o),f=Ho(n,o),m=ad(r,s),g=ad(a,i),y=t.length,b=$e(t),x=n.length,w=$e(n);if(d.length+f.length===0)for(let t=0;t<h.length;t++){const n=t%m.length,r=t%g.length,s=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);h[t]=s.real,p[t]=s.imag}else for(let t=0;t<h.length;t++){const n=Le(t,l,c),r=n.slice(-y);d.forEach((e=>r[e]=0));const s=Me(r,y,b),a=n.slice(-x);f.forEach((e=>a[e]=0));const i=Me(a,x,w),o=e(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);h[t]=o.real,p[t]=o.imag}return[h,p,o]}}const vS=rS(((e,t)=>e+t)),kS=wS(((e,t,n,r)=>({real:e+n,imag:t+r}))),IS=xS(Xe,vS,kS),NS={kernelName:Xe,backendName:"cpu",kernelFunc:IS};function SS(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=re(s.shape),o=pe(a,i),u=re(o);Q(i===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const CS={kernelName:Qn,backendName:"cpu",kernelFunc:SS};function ES(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;HN([s,a],"matMul");const u=s.shape.length,l=a.shape.length,c=i?s.shape[u-2]:s.shape[u-1],h=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[u-1]:s.shape[u-2],d=o?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=re(f),y=re(m);Q(u>=2&&l>=2&&(g===y||1===g||1===y),(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`));const b=(g>y?s.shape.slice(0,-2):a.shape.slice(0,-2)).concat([p,d]);Q(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const x=o?[y,d,h]:[y,h,d],w=SS({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,p]:[g,p,c]}}),v=SS({inputs:{x:a},backend:n,attrs:{shape:x}}),k=i?w.shape[1]:w.shape[2],I=i?w.shape[2]:w.shape[1],N=o?v.shape[1]:v.shape[2],S=Math.max(g,y),C=n.data.get(w.dataId).values,E=n.data.get(v.dataId).values,T=$e(w.shape),$=$e(v.shape),[A,R,_]=i?[T[0],1,T[1]]:[T[0],T[1],1],[F,D,O]=o?[1,$[1],$[0]]:[$[1],1,$[0]],M=I*N,L=ja([S,I,N],w.dtype),z=L.values,B=n.blockSize;for(let e=0;e<S;e++)for(let t=0;t<I;t+=B)for(let n=0;n<N;n+=B)for(let r=0;r<k;r+=B){const s=Math.min(t+B,I),a=Math.min(n+B,N),i=Math.min(r+B,k);for(let o=t;o<s;o++)for(let t=n;t<a;t++){let n=0;for(let s=r;s<i;s++){const r=Math.min(e,g-1)*A,a=Math.min(e,y-1)*O;n+=C[r+o*R+s*_]*E[s*F+t*D+a]}z[e*M+(o*N+t)]+=n}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(b,L.dtype,L.values)}const TS={kernelName:ct,backendName:"cpu",kernelFunc:ES};const $S={kernelName:Br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;let p,d,f;const m=[];p=ES({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),i&&(d=IS({inputs:{a:p,b:i},backend:n}),m.push(p),p=d),c&&(f=hS(n,p,c,o,h),m.push(p),p=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return p}};function AS(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const RS={kernelName:He,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;HN(t,"abs");let r=new Float32Array(re(t.shape));return r=AS(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,"float32")}},_S=XN(qe,(e=>Math.acos(e))),FS={kernelName:qe,backendName:"cpu",kernelFunc:_S},DS=XN(Ke,(e=>Math.acosh(e))),OS={kernelName:Ke,backendName:"cpu",kernelFunc:DS};const MS={kernelName:Ye,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;HN(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=ja(r[0].shape,r[0].dtype),i=a.values;for(let e=0;e<r.length;e++){const t=s[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function LS(e,t,n,r,s){const a=t.length,i=re(t),o=$e(t),u=$e(s),l=me(n,re(s));for(let t=0;t<i;++t){const n=Le(t,a,o),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[r[e]];l[Me(s,a,u)]=e[t]}return l}function zS(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;HN(s,"transpose");const i=s.shape.length,o=new Array(i);for(let e=0;e<o.length;e++)o[e]=s.shape[a[e]];const u=LS(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const BS={kernelName:Rr,backendName:"cpu",kernelFunc:zS};const PS={kernelName:Je,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;HN(s,"all");const o=de(a,s.shape);let u=o;const l=Gl(u,s.shape.length);let c=s;null!=l&&(c=zS({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Hl(u.length,s.shape.length)),Ul("all",u,c.shape.length);const[h,p]=Vl(c.shape,u),d=re(p),f=Fe(re(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*d;let n=m[t];for(let e=0;e<d;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=SS({inputs:{x:g},backend:n,attrs:{shape:Wl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const VS={kernelName:Ze,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;HN(s,"any");const o=de(a,s.shape);let u=o;const l=Gl(u,s.shape.length);let c=s;null!=l&&(c=zS({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Hl(u.length,s.shape.length)),Ul("any",u,c.shape.length);const[h,p]=Vl(c.shape,u),d=re(p),f=Fe(re(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*d;let n=m[t];for(let e=0;e<d;++e){const r=m[t+e];n=n||r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=SS({inputs:{x:g},backend:n,attrs:{shape:Wl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const WS={kernelName:Qe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;HN(s,"argMax");let i=de(a,s.shape);const o=Gl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=zS({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Hl(i.length,u.shape.length)),i=[i[0]],Ul("argMax",i,u.shape.length);const[c,h]=Vl(u.shape,i),p=Fe(re(c),"int32"),d=re(h),f=n.data.get(u.dataId).values;for(let e=0;e<p.length;++e){const t=e*d;let n=f[t],r=0;for(let e=0;e<d;++e){const s=f[t+e];s>n&&(n=s,r=e)}p[e]=r}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};const US={kernelName:et,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;HN(s,"argMin");let i=de(a,s.shape);const o=Gl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=zS({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Hl(i.length,u.shape.length)),i=[i[0]],Ul("argMin",i,u.shape.length);const[c,h]=Vl(u.shape,i),p=Fe(re(c),"int32"),d=re(h),f=n.data.get(u.dataId).values;for(let e=0;e<p.length;++e){const t=e*d;let n=f[t],r=0;for(let e=0;e<d;++e){const s=f[t+e];s<n&&(n=s,r=e)}p[e]=r}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},GS=XN(tt,(e=>Math.asin(e))),jS={kernelName:tt,backendName:"cpu",kernelFunc:GS},HS=XN(nt,(e=>Math.asinh(e))),qS={kernelName:nt,backendName:"cpu",kernelFunc:HS},KS=XN(rt,(e=>Math.atan(e))),XS={kernelName:rt,backendName:"cpu",kernelFunc:KS},YS=rS(((e,t)=>Math.atan2(e,t))),JS=xS(at,YS),ZS={kernelName:at,backendName:"cpu",kernelFunc:JS},QS=XN(st,(e=>Math.atanh(e))),eC={kernelName:st,backendName:"cpu",kernelFunc:QS};function tC(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,p=s.padInfo.top,d=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ja(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let t=0;t<s.batchSize;++t){const n=t*y,m=t*r[0];for(let t=0;t<s.inChannels;++t)for(let y=0;y<s.outHeight;++y){const w=y*i-p,v=Math.max(0,w),k=Math.min(s.inHeight,c+w),I=n+y*b;for(let n=0;n<s.outWidth;++n){const i=n*o-d,c=Math.max(0,i),p=Math.min(s.inWidth,h+i);let y=f,b=0,w=0;for(let n=v;n<k;n+=u){const s=m+n*r[1];for(let n=c;n<p;n+=l){const i=e[s+n*r[2]+t];"max"===a&&i>y?y=i:"avg"===a&&(b+=i,w++)}if(isNaN(y))break}g[I+n*x+t]="avg"===a?b/w:y}}}return m}function nC(e,t,n,r,s=!1,a=!1){const i=ja(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,p=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,m=ja(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*o-d;let y=g;for(;y<0;)y+=l;const b=Math.min(r.inHeight,h+g);for(let o=0;o<r.outWidth;++o){const h=o*u-f;let d=h;for(;d<0;)d+=c;const x=Math.min(r.inWidth,p+h);let w=Number.NEGATIVE_INFINITY,v=-1;for(let n=y;n<b;n+=l){const i=n-g;for(let o=d;o<x;o+=c){const u=o-h,l=m.get(e,n,o,t);l>w&&(w=l,v=s?a?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*p+u)}}i.set(v,e,n,o,t)}}return i}function rC(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,u=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,p=s.effectiveFilterDepth,d=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ja(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],N=s.outShape[4];for(let t=0;t<s.batchSize;++t){const n=t*v,x=t*r[0];for(let t=0;t<s.inChannels;++t)for(let v=0;v<s.outDepth;++v){const S=v*i-m;let C=S;for(;C<0;)C+=l;const E=Math.min(s.inDepth,p+S),T=n+v*k;for(let n=0;n<s.outHeight;++n){const i=n*o-g;let p=i;for(;p<0;)p+=c;const m=Math.min(s.inHeight,d+i),v=T+n*I;for(let n=0;n<s.outWidth;++n){const i=n*u-y;let o=i;for(;o<0;)o+=h;const d=Math.min(s.inWidth,f+i),g=v+n*N;let k=b,I=0,S=0;for(let n=C;n<E;n+=l){const s=x+n*r[1];for(let n=p;n<m;n+=c){const i=s+n*r[2];for(let n=o;n<d;n+=h){const s=e[i+n*r[3]+t];if("max"===a&&s>k?k=s:"avg"===a&&(I+=s,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[g+t]="avg"===a?I/S:k}}}}return x}const sC={kernelName:it,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;HN(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;Q(Iu(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=du(s.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&ae(l.inShape,l.outShape))c=QN({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=$e(s.shape),r=tC(e,s.shape,s.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}};const aC={kernelName:ut,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;HN(s,"avgPool3d");const c=fu(s.shape,a,i,1,o,u,l),h=rC(n.data.get(s.dataId).values,s.shape,s.dtype,$e(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const iC={kernelName:lt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;HN([s,a],"avgPool3DGrad");const c=fu(a.shape,i,o,1,u,l),h=c.strideDepth,p=c.strideHeight,d=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=w-1-c.padInfo.front,N=k-1-c.padInfo.left,S=v-1-c.padInfo.top,C=ja(a.shape,"float32"),E=1/(f*m*g),T=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-I,i=r-S,o=s-N;let u=0;for(let n=0;n<w;n+=y){const r=(a+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<v;n+=b){const s=(i+n)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let n=0;n<k;n+=x){const a=(o+n)/d;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;u+=T.get(e,r,s,a,t)}}}C.set(u*E,e,n,r,s,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const oC={kernelName:ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;HN([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=du(i.shape,o,u,1,l),h=c.strideHeight,p=c.strideWidth,d=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,w=y-1-c.padInfo.top,v=ja(i.shape,"float32"),k=1/(d*f),I=n.data.get(s.dataId).values,N=ja(s.shape,"float32",I);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=n-w,a=r-x;let i=0;for(let n=0;n<y;n+=m){const r=(s+n)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<b;n+=g){const s=(a+n)/p;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;i+=N.get(e,r,s,t)}}v.set(i*k,e,n,r,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const uC={kernelName:Zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:u}=t;Q(o.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Q(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Q(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),HN([s,o,u,a,i],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,p=n.data.get(u.dataId).values,d=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=d.length,b=p.length,x=h.length;let w=0,v=0,k=0,I=0;for(let e=0;e<c.length;++e)m[e]=f[w++]+(c[e]-h[v++])*d[k++]/Math.sqrt(p[I++]+l),w>=g&&(w=0),v>=x&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function lC(e,t,n,r,s){const a=Mi(r,t,n),i=re(n),o=$e(r);if(a){const n=Li(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u=ja(r,s,"string"===s?yd(e):e),l=ja(n,s);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));l.set(u.get(...r),...n)}return"string"===s?bd(l.values):l.values}function cC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;HN(s,"slice");const[o,u]=zi(s,a,i);Ni(s,o,u);const l=lC(n.data.get(s.dataId).values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}const hC={kernelName:hr,backendName:"cpu",kernelFunc:cC};const pC={kernelName:ht,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;HN([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),u=Gp(s.shape,a,o),l=jp(u.length,a.length),c=Hp(s.shape,a,o),h=qp(i,a.length),p=Kp(c,i,a.length),d=SS({inputs:{x:s},backend:n,attrs:{shape:u}}),f=zS({inputs:{x:d},backend:n,attrs:{perm:l}}),m=SS({inputs:{x:f},backend:n,attrs:{shape:c}}),g=cC({inputs:{x:m},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function dC(e,t,n,r,s){const a=re(r),i=Fe(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(i[r]+=a>0?t[n]:1)}return i}function fC(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=ja([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const mC={kernelName:pt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=dC(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}};function gC(e){return(t,n,r)=>{const s=me(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],r);return s}}const yC=gC((e=>Math.ceil(e))),bC=YN(mt,yC),xC={kernelName:mt,backendName:"cpu",kernelFunc:bC},wC=XN(gt,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),vC={kernelName:gt,backendName:"cpu",kernelFunc:wC},kC={kernelName:bt,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(re(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],n=u[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function IC(e,t,n,r){const s=ge(n,re(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=re(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?yd(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}function NC(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const SC={kernelName:an,backendName:"cpu",kernelFunc:NC};function CC(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=de(s,t[0].shape)[0];let i=Pp(t.map((e=>e.shape)),a);if(0===re(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>re(e.shape)>0));if(1===o.length)return QN({inputs:{x:o[0]},backend:n});if(Bp(o.map((e=>e.shape)),a),"complex64"===o[0].dtype){const e=o.map((e=>mS({inputs:{input:e},backend:n}))),t=o.map((e=>NC({inputs:{input:e},backend:n}))),r=CC({inputs:e,backend:n,attrs:{axis:a}}),s=CC({inputs:t,backend:n,attrs:{axis:a}}),i=pS({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const u=o.map((e=>{const t=re(e.shape.slice(a));return SS({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),l=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Pp(u.map((e=>e.shape)),1);const c=1===u[0].shape[0],h=IC(l,i,t[0].dtype,c),p=Pp(o.map((e=>e.shape)),a),d=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}const EC={kernelName:xt,backendName:"cpu",kernelFunc:CC};function TC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r;HN([s,a],"conv2d");const h=Nu(u),p=mu(s.shape,a.shape,i,l,o,c,!1,h),d=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,b=p.padInfo.top,x="channelsLast"===p.dataFormat,w=new ds(p.outShape,s.dtype),v=$e(s.shape),k=$e(a.shape),I=v[0],N=x?v[1]:v[2],S=x?v[2]:1,C=x?1:v[1],E=w.strides[0],T=x?w.strides[1]:w.strides[2],$=x?w.strides[2]:1,A=x?1:w.strides[1],R=n.data.get(s.dataId).values,_=n.data.get(a.dataId).values,F=w.values;for(let e=0;e<p.batchSize;++e){const t=e*I,n=e*E;for(let e=0;e<p.outHeight;++e){const r=n+e*T,s=e*p.strideHeight-b;for(let e=0;e<d;++e){const n=s+e*m;if(n<0||n>=p.inHeight)continue;const a=e*k[0],i=t+n*N;for(let e=0;e<p.outWidth;++e){const t=r+e*$,n=e*p.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=p.inWidth)continue;const s=i+r*S;let o=a+e*k[1];for(let e=0;e<p.inChannels;++e){const n=R[s+e*C];for(let e=0;e<p.outChannels;++e)F[t+e*A]+=n*_[o+e];o+=p.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,F)}const $C={kernelName:wt,backendName:"cpu",kernelFunc:TC};const AC={kernelName:vt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r;HN([s,a],"conv2dBackpropFilter");const h=Nu(u),p=mu(s.shape,c,i,1,o,l,!1,h),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:g}=p,y="channelsLast"===p.dataFormat,b=new ds(p.filterShape,"float32"),x=p.padInfo.left,w=p.padInfo.top,v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=new ds(s.shape,s.dtype,v),N=new ds(a.shape,a.dtype,k);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((w-e)/d)),n=Math.min(p.outHeight,(p.inHeight+w-e)/d);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((x-r)/f)),a=Math.min(p.outWidth,(p.inWidth+x-r)/f);for(let i=0;i<p.inChannels;++i)for(let o=0;o<p.outChannels;++o){let u=0;for(let l=0;l<p.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*d-w;for(let e=s;e<a;++e){const n=r+e*f-x;u+=y?I.get(l,t,n,i)*N.get(l,c,e,o):I.get(l,i,t,n)*N.get(l,o,c,e)}}b.set(u,e,r,i,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const RC={kernelName:kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r;HN([s,a],"conv2dBackpropInput");const h=$e(a.shape),p=$e(s.shape);let d=Nu(l);const f=mu(i,a.shape,o,1,u,c,!1,d),m=new ds(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,w,v]=h,{batchSize:k,filterHeight:I,filterWidth:N,inChannels:S,inHeight:C,inWidth:E,outChannels:T,outHeight:$,outWidth:A,strideHeight:R,strideWidth:_}=f;d=f.dataFormat;const F=I-1-f.padInfo.top,D=N-1-f.padInfo.left,O="channelsLast"===d,M=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,B=O?1:m.strides[1],P=p[0],V=O?p[1]:p[2],W=O?p[2]:1,U=O?1:p[1];for(let e=0;e<k;++e)for(let t=0;t<S;++t)for(let n=0;n<C;++n){const r=n-F,s=Math.max(0,Math.ceil(r/R)),a=Math.min($,(I+r)/R);for(let i=0;i<E;++i){const o=i-D,u=Math.max(0,Math.ceil(o/_)),l=Math.min(A,(N+o)/_);let c=0;for(let n=s;n<a;++n){const s=n*R-r;for(let r=u;r<l;++r){const a=P*e+V*n+W*r,i=x*(I-1-s)+w*(N-1-(r*_-o))+v*t;for(let e=0;e<T;++e){c+=y[a+U*e]*b[i+e]}}}g[M*e+L*n+z*i+B*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const _C={kernelName:It,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;HN([s,a],"conv3d");const l=gu(s.shape,a.shape,i,u,o),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:d,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,x=g.top,w=new ds(l.outShape,s.dtype),v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=w.values,N=$e(s.shape),S=$e(a.shape);for(let e=0;e<l.batchSize;++e){const t=e*N[0],n=e*w.strides[0];for(let e=0;e<l.outDepth;++e){const r=n+e*w.strides[1],s=e*l.strideDepth-y;for(let e=0;e<c;++e){const n=s+e*d;if(n<0||n>=l.inDepth)continue;const a=e*S[0],i=t+n*N[1];for(let e=0;e<l.outHeight;++e){const t=r+e*w.strides[2],n=e*l.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const s=a+e*S[1],o=i+r*N[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-b;for(let e=0;e<p;++e){const t=r+e*m;if(t<0||t>=l.inWidth)continue;const a=s+e*S[2],i=o+t*l.inChannels;let u=a;for(let e=0;e<l.inChannels;++e){const t=v[i+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[u+e];u+=l.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const FC={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;HN([s,a],"conv3dBackpropFilterV2");const l=$e(s.shape),c=$e(a.shape),h=gu(s.shape,u,i,1,o),p=h.strideDepth,d=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new ds(h.filterShape,"float32"),x=b.values,[w,v,k,I]=b.strides,N=n.data.get(a.dataId).values,[S,C,E,T]=c,$=n.data.get(s.dataId).values,[A,R,_,F]=l,D=h.padInfo.front,O=h.padInfo.left,M=h.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((D-e)/p)),n=Math.min(h.outDepth,(h.inDepth+D-e)/p),r=e*w;for(let s=0;s<g;++s){const a=Math.max(0,Math.ceil((M-s)/d)),i=Math.min(h.outHeight,(h.inHeight+M-s)/d),o=s*v+r;for(let r=0;r<y;++r){const u=Math.max(0,Math.ceil((O-r)/f)),l=Math.min(h.outWidth,(h.inWidth+O-r)/f),c=r*k+o;for(let o=0;o<h.inChannels;++o){const m=o*I+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*A,y=m*S;for(let m=t;m<n;++m){const t=(e+m*p-D)*R+h,n=m*C+y;for(let e=a;e<i;++e){const a=(s+e*d-M)*_+t,i=e*E+n;for(let e=u;e<l;++e){const t=e*T+i;g+=$[(r+e*f-O)*F+a+o]*N[t+c]}}}}x[m+c]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const DC={kernelName:St,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;HN([s],"conv3dBackpropInputV2");const l=$e(s.shape),c=$e(a.shape),h=gu(u,a.shape,o,1,i),p=new ds(h.inShape,"float32"),d=p.values,[f,m,g,y]=p.strides,b=n.data.get(s.dataId).values,[x,w,v,k]=l,I=n.data.get(a.dataId).values,[N,S,C,E]=c,{batchSize:T,filterDepth:$,filterHeight:A,filterWidth:R,inChannels:_,inDepth:F,inHeight:D,inWidth:O,outChannels:M,outDepth:L,outHeight:z,outWidth:B,strideDepth:P,strideHeight:V,strideWidth:W}=h,U=$-1-h.padInfo.front,G=A-1-h.padInfo.top,j=R-1-h.padInfo.left;for(let e=0;e<T;++e)for(let t=0;t<_;++t)for(let n=0;n<F;++n){const r=n-U,s=Math.max(0,Math.ceil(r/P)),a=Math.min(L,($+r)/P);for(let i=0;i<D;++i){const o=i-G,u=Math.max(0,Math.ceil(o/V)),l=Math.min(z,(A+o)/V);for(let c=0;c<O;++c){const h=c-j,p=Math.max(0,Math.ceil(h/W)),T=Math.min(B,(R+h)/W);let _=0;for(let n=s;n<a;++n){const s=n*P-r;for(let r=u;r<l;++r){const a=r*V-o;for(let i=p;i<T;++i){const o=x*e+w*n+v*r+k*i,u=N*($-1-s)+S*(A-1-a)+C*(R-1-(i*W-h))+E*t;for(let e=0;e<M;++e){_+=b[o+e]*I[u+e]}}}}d[f*e+m*n+g*i+y*c+t]=_}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},OC=XN(Ct,(e=>Math.cos(e))),MC={kernelName:Ct,backendName:"cpu",kernelFunc:OC},LC=XN(Et,(e=>Math.cosh(e))),zC={kernelName:Et,backendName:"cpu",kernelFunc:LC};const BC={kernelName:$t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,[c,h,p,d]=s.shape,f=a.shape[0],[m,g]=o,y=ja([f,m,g,d],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=$e(s.shape),k=$e(y.shape);for(let e=0;e<f;e++){const t=4*e,n=b[t],r=b[t+1],s=b[t+2],a=b[t+3],i=x[e];if(i>=c)continue;const o=m>1?(s-n)*(h-1)/(m-1):0,f=g>1?(a-r)*(p-1)/(g-1):0;for(let t=0;t<m;t++){const c=m>1?n*(h-1)+t*o:.5*(n+s)*(h-1);if(c<0||c>h-1)for(let n=0;n<g;n++)for(let r=0;r<d;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=l}else if("bilinear"===u){const n=Math.floor(c),s=Math.ceil(c),o=c-n;for(let u=0;u<g;u++){const c=g>1?r*(p-1)+u*f:.5*(r+a)*(p-1);if(c<0||c>p-1){for(let n=0;n<d;n++){const r=n+u*k[2]+t*k[1]+e*k[0];y.values[r]=l}continue}const h=Math.floor(c),m=Math.ceil(c),b=c-h;for(let r=0;r<d;r++){let a=r+h*v[2]+n*v[1]+i*v[0];const l=w[a];a=r+m*v[2]+n*v[1]+i*v[0];const c=w[a];a=r+h*v[2]+s*v[1]+i*v[0];const p=w[a];a=r+m*v[2]+s*v[1]+i*v[0];const d=l+(c-l)*b,f=p+(w[a]-p)*b;a=r+u*k[2]+t*k[1]+e*k[0],y.values[a]=d+(f-d)*o}}}else for(let n=0;n<g;++n){const s=g>1?r*(p-1)+n*f:.5*(r+a)*(p-1);if(s<0||s>p-1){for(let r=0;r<d;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=l}continue}const o=Math.round(s),u=Math.round(c);for(let r=0;r<d;r++){const s=r+o*v[2]+u*v[1]+i*v[0],a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=w[s]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const PC={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;HN(s,"cumsum");const u=Gl([a],s.shape.length);let l=s;null!=u&&(l=zS({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=Hl(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=Cs(l.dtype,"int32"),p=Fe(re(l.shape),h),d=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<d.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)p[n]=i?0:d[n];else{const r=m(e,t-1);p[n]=i?d[r]+p[r]:d[n]+p[r]}}const g=n.makeTensorInfo(l.shape,h,p);if(null!=u){const e=zS({inputs:{x:g},backend:n,attrs:{perm:jl(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const VC={kernelName:At,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=dC(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=fC(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const WC={kernelName:Rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Q("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`)),Q(a>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`));const o=s.shape[0],u=s.shape[1],l=s.shape[2],c=s.shape[3],h=u*a,p=l*a,d=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*p*d);let g=0;for(let e=0;e<o;++e)for(let t=0;t<h;++t){const n=Math.floor(t/a),r=t%a;for(let t=0;t<p;++t){const s=Math.floor(t/a),i=(r*a+t%a)*d;for(let t=0;t<d;++t){const r=t+i+c*(s+l*(n+u*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,h,p,d],s.dtype,m)}};function UC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;HN([s,a],"depthwiseConv2DNative");const c=$e(s.shape),h=$e(a.shape);let p=u;null==p&&(p=[1,1]),Q(Iu(i,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));const d=mu(s.shape,a.shape,i,p,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,x=b.left,w=b.top,v=d.outChannels/d.inChannels,k=new ds(d.outShape,s.dtype),I=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,S=k.values;for(let e=0;e<d.batchSize;++e){const t=e*c[0],n=e*k.strides[0];for(let e=0;e<d.outHeight;++e){const r=n+e*k.strides[1],s=e*d.strideHeight-x;for(let e=0;e<f;++e){const n=s+e*g;if(n<0||n>=d.inHeight)continue;const a=e*h[0],i=t+n*c[1];for(let e=0;e<d.outWidth;++e){const t=r+e*k.strides[2],n=e*d.strideWidth-w;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=d.inWidth)continue;const s=a+e*h[1],o=i+r*d.inChannels;let u=t,l=s;for(let e=0;e<d.inChannels;++e){const t=I[o+e];for(let e=0;e<v;++e)S[u+e]+=t*N[l+e];u+=v,l+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const GC={kernelName:_t,backendName:"cpu",kernelFunc:UC};const jC={kernelName:Ft,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r;HN([s,a],"depthwiseConv2dNativeBackpropFilter");const h=mu(s.shape,c,i,o,u,l,!0),{strideHeight:p,strideWidth:d,filterHeight:f,filterWidth:m}=h,g=new ds(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,w=n.data.get(s.dataId).values,v=new ds(s.shape,s.dtype,w),k=n.data.get(a.dataId).values,I=new ds(a.shape,a.dtype,k);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((b-e)/p)),n=Math.min(h.outHeight,(h.inHeight+b-e)/p);for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((y-r)/d)),a=Math.min(h.outWidth,(h.inWidth+y-r)/d);for(let i=0;i<h.outChannels;++i){const o=Math.trunc(i/x),u=i%x;let l=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*p-b;for(let e=s;e<a;++e){const n=r+e*d-y;l+=v.get(u,t,n,o)*I.get(u,c,e,i)}}g.set(l,e,r,o,u)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const HC={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r;HN([s,a],"depthwiseConv2DNativeBackpropInput");const h=$e(s.shape),p=$e(a.shape),d=mu(c,a.shape,i,o,u,l,!0),f=new ds(d.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[w,v,k]=h,I=n.data.get(a.dataId).values,[N,S,C]=p,{batchSize:E,filterHeight:T,filterWidth:$,inChannels:A,inHeight:R,inWidth:_,outChannels:F,outHeight:D,outWidth:O,strideHeight:M,strideWidth:L}=d,z=T-1-d.padInfo.top,B=$-1-d.padInfo.left,P=F/A;for(let e=0;e<E;++e)for(let t=0;t<A;++t)for(let n=0;n<R;++n){const r=n-z,s=Math.max(0,Math.ceil(r/M)),a=Math.min(D,(T+r)/M);for(let i=0;i<_;++i){const o=i-B,u=Math.max(0,Math.ceil(o/L)),l=Math.min(O,($+o)/L);let c=0;for(let n=s;n<a;++n){const s=n*M-r;for(let r=u;r<l;++r){const a=w*e+v*n+k*r,i=N*(T-1-s)+S*($-1-(r*L-o))+C*t;for(let e=0;e<P;++e){c+=x[a+(t*P+e)]*I[i+e]}}}m[g*e+y*n+b*i+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const qC={kernelName:Ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=re(r.shape),a=n.data.get(r.dataId).values,i=ja([s,s],r.dtype),o=i.values;for(let e=0;e<a.length;e++)o[e*s+e]=a[e];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}},KC={kernelName:Mt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,u=t,l=u.data.get(r.dataId).values,c=r.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:d,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:N,dilationWidth:S,outShape:C}=pu(r.shape,s.shape,a,i,"NHWC",o),E=re(C),T=C.length,$=ge(r.dtype,E);for(let e=0;e<d;++e)for(let t=0;t<y;++t){const n=t*w-x.top;for(let a=0;a<b;++a){const i=a*v-x.left;for(let o=0;o<g;++o){let u=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){const a=n+t*N;if(a>=0&&a<f)for(let n=0;n<I;++n){const d=i+n*S;if(d>=0&&d<m){const i=Me([e,a,d,o],c,$e(r.shape)),f=Me([t,n,o],p,$e(s.shape)),m=l[i]+h[f];m>u&&(u=m)}}}$[Me([e,t,a,o],T,$e(C))]=u}}}return{dataId:u.write(us($,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},XC={kernelName:zt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Re(r.shape,l.data.get(r.dataId).values),h=Re(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:d,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=pu(r.shape,s.shape,i,o,"NHWC",u);Q(a.rank===S.length,(()=>`Error in ${zt}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));const C=Re(S,l.data.get(a.dataId).values),E=De(s.shape,s.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*x-b.top;for(let r=0;r<y;++r){const s=r*w-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=0,u=0;for(let t=0;t<v;++t){const r=n+t*I;if(r>=0&&r<d)for(let n=0;n<k;++n){const l=s+n*N;if(l>=0&&l<f){const s=c[e][r][l][a]+h[t][n][a];s>i&&(i=s,o=t,u=n)}}}E[o][u][a]+=C[e][t][r][a]}}}return{dataId:l.write(us(E,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},YC={kernelName:Lt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Re(r.shape,l.data.get(r.dataId).values),h=Re(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:d,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=pu(r.shape,s.shape,i,o,"NHWC",u);Q(a.rank===S.length,(()=>`Error in ${Lt}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));const C=Re(S,l.data.get(a.dataId).values),E=De(r.shape,r.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*x-b.top;for(let r=0;r<y;++r){const s=r*w-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,u=s<0?0:s;for(let t=0;t<v;++t){const r=n+t*I;if(r>=0&&r<d)for(let n=0;n<k;++n){const l=s+n*N;if(l>=0&&l<f){const s=c[e][r][l][a]+h[t][n][a];s>i&&(i=s,o=r,u=l)}}}E[e][o][u][a]+=C[e][t][r][a]}}}return{dataId:l.write(us(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const JC={kernelName:Vt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;HN([r,s],"eluGrad");const a=new Float32Array(re(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){const t=i[e];a[e]=t>=1?o[e]:o[e]*(t+1)}return n.makeTensorInfo(s.shape,"float32",a)}},ZC=rS(((e,t)=>e===t?1:0)),QC=xS(Ut,ZC,null,"bool"),eE={kernelName:Ut,backendName:"cpu",kernelFunc:QC},tE=Jp,nE=Zp,rE=Qp,sE=ed,aE=td,iE=nd,oE=XN(Wt,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+tE*n);return t*(1-((((iE*r+aE)*r+sE)*r+rE)*r+nE)*r*Math.exp(-n*n))})),uE={kernelName:Wt,backendName:"cpu",kernelFunc:oE},lE=gC((e=>Math.exp(e))),cE=YN(Gt,lE),hE={kernelName:Gt,backendName:"cpu",kernelFunc:cE};function pE(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let u=a;return a<0&&(Q(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+a+1),o.splice(u,0,1),SS({inputs:{x:s},backend:n,attrs:{shape:o}})}const dE={kernelName:jt,backendName:"cpu",kernelFunc:pE},fE=gC((e=>Math.expm1(e))),mE=YN(Ht,fE),gE={kernelName:Ht,backendName:"cpu",kernelFunc:mE},yE=rS(((e,t)=>e*t)),bE=wS(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),xE=xS(On,yE,bE),wE={kernelName:On,backendName:"cpu",kernelFunc:xE},vE=rS(((e,t)=>e/t)),kE=xS(Bt,vE),IE={kernelName:Bt,backendName:"cpu",kernelFunc:kE},NE=rS(((e,t)=>e-t)),SE=wS(((e,t,n,r)=>({real:e-n,imag:t-r}))),CE=xS(Nr,NE,SE),EE={kernelName:Nr,backendName:"cpu",kernelFunc:CE};function TE(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[s,a],c=re(l),h=me("float32",c),p=me("float32",c);for(let e=0;e<s;e++){const r=cC({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,a]}}),s=cC({inputs:{x:u},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=pS({inputs:{real:r,imag:s},backend:n}),{real:l,imag:c}=$E(i,t,n),d=ad(l,c);for(let t=0;t<a;t++){const n=ld(d,t);h[e*a+t]=n.real,p[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i)}const d=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",p),m=pS({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}function $E(e,t,n){const r=re(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const s=AE(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",os(r,"float32")),i=QN({inputs:{x:a},backend:n}),u=IE.kernelFunc({inputs:{a:e,b:a},backend:n}),l=IE.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(u.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:h}}return s}return id(function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=pd(s*r,t,n),u=ld(e,r);a+=u.real*o.real-u.imag*o.imag,i+=u.real*o.imag+u.imag*o.real}n&&(a/=t,i/=t),cd(r,a,i,s)}return r}(ad(a,i),r,t));var o}function AE(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=ad(e,t),i=n/2,o=od(a),u=o.real,l=o.imag,c=[u.length],h=s.makeTensorInfo(c,"float32",u),p=s.makeTensorInfo(c,"float32",l),d=pS({inputs:{real:h,imag:p},backend:s}),f=ud(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=pS({inputs:{real:b,imag:x},backend:s}),v=AE(u,l,i,r,s),k=v.real,I=v.imag,N=[k.length],S=s.makeTensorInfo(N,"float32",k),C=s.makeTensorInfo(N,"float32",I),E=pS({inputs:{real:S,imag:C},backend:s}),T=AE(m,g,i,r,s),$=T.real,A=T.imag,R=[$.length],_=s.makeTensorInfo(R,"float32",$),F=s.makeTensorInfo(R,"float32",A),D=pS({inputs:{real:_,imag:F},backend:s}),O=hd(n,r),M=[O.real.length],L=s.makeTensorInfo(M,"float32",O.real),z=s.makeTensorInfo(M,"float32",O.imag),B=pS({inputs:{real:L,imag:z},backend:s}),P=xE({inputs:{a:B,b:D},backend:s}),V=IS({inputs:{a:E,b:P},backend:s}),W=CE({inputs:{a:E,b:P},backend:s}),U=mS({inputs:{input:V},backend:s}),G=mS({inputs:{input:W},backend:s}),j=NC({inputs:{input:V},backend:s}),H=NC({inputs:{input:W},backend:s}),q=CC({inputs:[U,G],backend:s,attrs:{axis:0}}),K=CC({inputs:[j,H],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const RE={kernelName:qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=re(r.shape),a=r.shape[r.shape.length-1],i=SS({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TE(i,!1,n),u=SS({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}};function _E(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Ce(s),o=ge(i,re(r));return function(e,t,n){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const FE={kernelName:Kt,backendName:"cpu",kernelFunc:_E};const DE={kernelName:Xt,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=me(r.dtype,re(r.shape)),[i,o,u,l]=r.shape,c=s.data.get(r.dataId).values;for(let e=0;e<i;e++){const t=e*u*o*l;for(let e=0;e<o;e++){const n=e*(u*l);for(let r=0;r<u;r++){const s=r*l;for(let o=0;o<l;o++){const h=[i,e,r,o][2],p=Math.round(u-h),d=t+n+s+o;let f=c[d];if(p>=0&&p<u){f=c[t+n+p*l+o]}a[d]=f}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},OE=gC((e=>Math.floor(e))),ME=YN(Yt,OE),LE={kernelName:Yt,backendName:"cpu",kernelFunc:ME},zE=rS(((e,t)=>Math.floor(e/t))),BE=xS(Jt,zE,null,"int32"),PE={kernelName:Jt,backendName:"cpu",kernelFunc:BE};const VE={kernelName:Pr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r;let m=TC({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const e=m;m=IS({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(d){const e=m;m=hS(n,m,d,o,f),n.disposeIntermediateTensorInfo(e)}return m}};const WE={kernelName:Vr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r;let m=UC({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const e=m;m=IS({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(d){const e=m;m=hS(n,m,d,o,f),n.disposeIntermediateTensorInfo(e)}return m}};const UE={kernelName:en,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=re(r.shape),i=s.shape,o=i[i.length-1],[u,l,c,h]=wi(r,s);if(0===l)return n.makeTensorInfo(u,r.dtype,[]);const p=ja([l,c],r.dtype),d=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values;for(let e=0;e<l;e++){const t=[];let n=0;for(let r=0;r<o;r++){const s=d[e*o+r];n+=s*h[r],t.push(s)}if(n<0||n>=a/c)throw new Error(`Invalid indices: ${t} does not index into ${r.shape}`);for(let t=0;t<c;t++)p.values[e*c+t]=f[n*c+t]}return n.makeTensorInfo(u,p.dtype,p.values)}};function GE(e,t,n){const r=ja(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],o=t.locToIndex([a,i]);s[2]=t.values[o];const u=e.locToIndex(s);r.values[n]=e.values[u]}return r}const jE={kernelName:Qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;HN([s,a],"gatherV2");let u=o;null==o&&(u=0);const l=re(a.shape),c=gd(s,a,de(i,s.shape)[0],u),h=SS({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=SS({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}}),d=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],f=n.bufferSync(p),m=GE(n.bufferSync(h),f,d);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},HE=rS(((e,t)=>e>t?1:0)),qE=xS(tn,HE,null,"bool"),KE={kernelName:tn,backendName:"cpu",kernelFunc:qE},XE=rS(((e,t)=>e>=t?1:0)),YE=xS(nn,XE,null,"bool"),JE={kernelName:nn,backendName:"cpu",kernelFunc:YE};const ZE={kernelName:sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=re(r.shape),a=r.shape[r.shape.length-1],i=SS({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TE(i,!0,n),u=SS({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}},QE=XN(on,(e=>Number.isFinite(e)?1:0),"bool"),eT={kernelName:on,backendName:"cpu",kernelFunc:QE},tT=XN(un,(e=>Math.abs(e)===1/0?1:0),"bool"),nT={kernelName:un,backendName:"cpu",kernelFunc:tT},rT=XN(ln,(e=>Number.isNaN(e)?1:0),"bool"),sT={kernelName:ln,backendName:"cpu",kernelFunc:rT},aT=rS(((e,t)=>e<t?1:0)),iT=xS(hn,aT,null,"bool"),oT={kernelName:hn,backendName:"cpu",kernelFunc:iT},uT=rS(((e,t)=>e<=t?1:0)),lT=xS(pn,uT,null,"bool"),cT={kernelName:pn,backendName:"cpu",kernelFunc:lT};function hT(e,t,n){const r=(t-e)/(n-1),s=Fe(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return s}const pT={kernelName:dn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=hT(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},dT=gC((e=>Math.log(e))),fT=YN(fn,dT),mT={kernelName:fn,backendName:"cpu",kernelFunc:fT},gT=XN(mn,(e=>Math.log1p(e))),yT={kernelName:mn,backendName:"cpu",kernelFunc:gT},bT=rS(((e,t)=>e&&t)),xT=xS(gn,bT,null,"bool"),wT={kernelName:gn,backendName:"cpu",kernelFunc:xT},vT=XN(yn,(e=>e?0:1),"bool"),kT={kernelName:yn,backendName:"cpu",kernelFunc:vT},IT=rS(((e,t)=>e||t)),NT=xS(bn,IT,null,"bool"),ST={kernelName:bn,backendName:"cpu",kernelFunc:NT};const CT={kernelName:wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;HN(s,"LRN");const l=s.shape[3],c=l-1,h=n.data.get(s.dataId).values,p=re(s.shape),d=new Float32Array(p);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let e=0;e<p;e++){const t=f(e),n=h[e]*Math.pow(i+o*t,-u);d[e]=n}return n.makeTensorInfo(s.shape,s.dtype,d)}};const ET={kernelName:vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r;HN(i,"LRNGrad");const h=re(i.shape),p=i.shape[3],d=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),y=h;for(let e=0;e<y;e++){const t=e%p,n=e-t+Math.max(0,t-o),r=e-t+Math.min(p,t+o+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(f[e],2);s=l*s+u;for(let t=n;t<r;t++){let n=-2*l*c*f[t]*m[e]/s;e===t&&(n+=Math.pow(s,-c)),n*=d[e],g[t]+=n}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function TT(e,t,n,r){const s=me(r,re(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];t>a&&(a=t)}s[n]=a}return s}function $T(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let u=s.shape;const l=u.length,c=de(a,u);let h=c;const p=Gl(h,l);let d=o.data.get(s.dataId).values;if(null!=p){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[p[t]];d=LS(d,u,s.dtype,p,e),h=Hl(h.length,l),u=e}HN(s,"max"),Ul("max",h,l);const[f,m]=Vl(u,h),g=TT(d,re(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=Wl(f,c)}return{dataId:y,shape:b,dtype:s.dtype}}const AT={kernelName:kn,backendName:"cpu",kernelFunc:$T},RT=rS(((e,t)=>Math.max(e,t))),_T=xS(In,RT),FT={kernelName:In,backendName:"cpu",kernelFunc:_T};const DT={kernelName:Nn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;HN(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;Q(Iu(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=du(s.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&ae(l.inShape,l.outShape))c=QN({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=$e(s.shape),r=tC(e,s.shape,s.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}};const OT={kernelName:Cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;HN(s,"maxPool3d");const c=fu(s.shape,a,i,1,o,u,l),h=rC(n.data.get(s.dataId).values,s.shape,s.dtype,$e(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const MT={kernelName:En,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;HN([s,a],"maxPool3DGrad");const c=fu(a.shape,i,o,1,u,l),h=function(e,t){const n=ja(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,d=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-p;let x=b;for(;x<0;)x+=i;const w=Math.min(t.inDepth,l+b);for(let r=0;r<t.outHeight;++r){const l=r*s-d;let p=l;for(;p<0;)p+=o;const v=Math.min(t.inHeight,c+l);for(let s=0;s<t.outWidth;++s){const d=s*a-f;let k=d;for(;k<0;)k+=u;const I=Math.min(t.inWidth,h+d);let N=Number.NEGATIVE_INFINITY,S=-1;for(let t=x;t<w;t+=i){const n=t-b;for(let r=p;r<v;r+=o){const s=r-l;for(let a=k;a<I;a+=u){const i=a-d,o=e.get(m,t,r,a,g);o>=N&&(N=o,S=n*c*h+s*c+i)}}}n.set(S,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),p=c.strideDepth,d=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,v=b-1-c.padInfo.front,k=w-1-c.padInfo.left,I=x-1-c.padInfo.top,N=ja(a.shape,"float32"),S=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-v,i=r-I,o=s-k;let u=0;for(let n=0;n<b;n+=m){const r=(a+n)/p;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let s=0;s<x;s+=g){const a=(i+s)/d;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let i=0;i<w;i+=y){const l=(o+i)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const p=b*x*w-1-h.get(e,r,a,l,t)===n*x*w+s*w+i?1:0;if(0===p)continue;u+=S.get(e,r,a,l,t)*p}}}N.set(u,e,n,r,s,t)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const LT={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;HN([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,p=du(o.shape,u,l,1,c,h),d=n.data.get(o.dataId).values,f=ja(p.outShape,o.dtype,nC(d,o.shape,o.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,b=p.dilationWidth,x=p.effectiveFilterHeight,w=p.effectiveFilterWidth,v=w-1-p.padInfo.left,k=x-1-p.padInfo.top,I=ja(o.shape,"float32"),N=n.data.get(s.dataId).values,S=ja(s.shape,"float32",N);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){const s=n-k,a=r-v;let i=0;for(let n=0;n<x;n+=y){const r=(s+n)/m;if(!(r<0||r>=p.outHeight||Math.floor(r)!==r))for(let s=0;s<w;s+=b){const o=(a+s)/g;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;const u=x*w-1-f.get(e,r,o,t)===n*w+s?1:0;if(0===u)continue;i+=S.get(e,r,o,t)*u}}I.set(i,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const zT={kernelName:Tn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;HN(r,"MaxPoolWithArgmax");const l=u.data.get(r.dataId).values,c=du(r.shape,s,a,[1,1],i),[h,p]=function(e,t,n,r,s){const a=tC(e,0,n,$e(t),s,"max"),i=nC(e,t,n,s,!0,r);return[a.values,i.values]}(l,r.shape,r.dtype,o,c),d=u.write(h,c.outShape,r.dtype),f=u.write(p,c.outShape,r.dtype);return[{dataId:d,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function BT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;HN(s,"sum"),o="bool"===s.dtype?yS({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):QN({inputs:{x:s},backend:n});const u=o.shape.length,l=de(a,o.shape),c=Gl(l,u);let h=l,p=o;null!=c&&(p=zS({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Hl(h.length,u)),Ul("sum",h,p.shape.length);const[d,f]=Vl(p.shape,h);let m=fS(n,d,Cs(p.dtype,"int32"));const g=re(f),y=n.data.get(m.dataId).values,b=n.data.get(p.dataId).values;for(let e=0;e<y.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=b[t+e];y[e]=n}if(i){const e=m;m=SS({inputs:{x:m},backend:n,attrs:{shape:Wl(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(p),m}const PT={kernelName:br,backendName:"cpu",kernelFunc:BT};const VT={kernelName:$n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=de(a,s.shape),u=re(Vl(s.shape,o)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const h=yS({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);const p=kE({inputs:{a:h,b:c},backend:n});l.push(p);const d=BT({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:i}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const WT={kernelName:An,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;HN(s,"min");const o=de(a,s.shape);let u=o;const l=Gl(u,s.shape.length);let c=s;null!=l&&(c=zS({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Hl(u.length,s.shape.length)),Ul("min",u,c.shape.length);const[h,p]=Vl(c.shape,u),d=re(p),f=Fe(re(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*d;let n=m[t];for(let e=0;e<d;++e){const r=m[t+e];r<n&&(n=r)}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=SS({inputs:{x:g},backend:n,attrs:{shape:Wl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},UT=rS(((e,t)=>Math.min(e,t))),GT=xS(Rn,UT),jT={kernelName:Rn,backendName:"cpu",kernelFunc:GT};const HT={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;HN(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),u=a.map((e=>e[0])),l=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,p=s.shape.length,d=$e(s.shape),f=re(o),m=o.length,g=$e(o),y=me(s.dtype,f);for(let e=0;e<f;e++){let t=Le(e,m,g);for(let e=0;e<m;e++)t[e]<u[e]?t[e]=2*u[e]-t[e]-c:t[e]>=l[e]&&(t[e]=2*(l[e]-1)-t[e]+c);t=t.map(((e,t)=>e-u[t]));const n=Me(t,p,d);y[e]=h[n]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},qT=rS(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),KT=xS(Fn,qT),XT={kernelName:Fn,backendName:"cpu",kernelFunc:KT};function YT(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=de([o],s.shape),l=$T({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=Wl(l.shape,u),h=SS({inputs:{x:l},backend:n,attrs:{shape:c}}),p=CE({inputs:{a:s,b:h},backend:n}),d=cE({inputs:{x:p},backend:n}),f=BT({inputs:{x:d},backend:n,attrs:{axis:u,keepDims:!1}}),m=SS({inputs:{x:f},backend:n,attrs:{shape:c}}),g=kE({inputs:{a:d,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const JT={kernelName:vr,backendName:"cpu",kernelFunc:YT};const ZT={kernelName:Dn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;HN(s,"multinomial");const u=o?s:YT({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,p=[l,a],d=Fe(re(p),"int32");for(let e=0;e<l;++e){const t=e*c,n=new Float32Array(c-1);n[0]=h[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+h[t+e];const r=Nc.alea(i.toString()),s=e*a;for(let e=0;e<a;++e){const t=r();d[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){d[s+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",d)}};function QT(e,t,n){const r=os(-1,n);return yE([],t,r,e,n)}const e$={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;HN(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=QT(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},t$=np;const n$={kernelName:zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r;HN(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=t$(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},r$=rp;const s$={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r;HN(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:d}=r$(c,h,i,o,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([d]))]}},a$=sp;const i$={kernelName:Pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r;HN(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,p=i,d=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=a$(c,h,p,d,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},o$=rS(((e,t)=>e!==t?1:0)),u$=xS(Ln,o$,null,"bool"),l$={kernelName:Ln,backendName:"cpu",kernelFunc:u$};const c$={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:i,offValue:o}=r;HN(s,"oneHot");const u=re(s.shape),l=new Float32Array(u*a);l.fill(o);const c=n.data.get(s.dataId).values;for(let e=0;e<u;++e)c[e]>=0&&c[e]<a&&(l[e*a+c[e]]=i);return n.makeTensorInfo([...s.shape,a],"int32",l)}};function h$(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=mS({inputs:{input:r},backend:n}),t=h$({inputs:{x:e},backend:n}),s=NC({inputs:{input:r},backend:n}),a=h$({inputs:{x:s},backend:n}),i=pS({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return _E({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const p$={kernelName:Or,backendName:"cpu",kernelFunc:h$};const d$={kernelName:Vn,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=mS({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=NC({inputs:{input:s},backend:r}),i=h$({inputs:{x:a},backend:r}),o=pS({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return _E({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function f$(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return pE({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{ee(a,e.shape,"All tensors passed to stack must have matching shapes"),Q(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],u=CC({inputs:t.map((e=>{const t=pE({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const m$={kernelName:Un,backendName:"cpu",kernelFunc:f$};const g$={kernelName:Gn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;HN(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),u=a.map((e=>e[0])),l=n.data.get(s.dataId).values,c=re(s.shape),h=s.shape.length,p=$e(s.shape),d=re(o),f=o.length,m=$e(o),g=me(s.dtype,d);0!==i&&g.fill(i);for(let e=0;e<c;e++){g[Me(Le(e,h,p).map(((e,t)=>e+u[t])),f,m)]=l[e]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},y$=rS(((e,t)=>Math.pow(e,t))),b$=xS(Hn,y$),x$={kernelName:Hn,backendName:"cpu",kernelFunc:b$};function w$(e,t,n,r){const[s,a]=Vl(e,r),i=Cs(t,"int32"),o=Fe(re(s),i),u=re(a);for(let e=0;e<o.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:s,outDtype:i}}const v$={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;HN(s,"prod");const o=s.shape.length,u=de(a,s.shape),l=Gl(u,o);let c=u,h=s;const p=[];null!=l&&(h=zS({inputs:{x:s},backend:n,attrs:{perm:l}}),p.push(h),c=Hl(c.length,o));const d=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=w$(h.shape,h.dtype,d,c);let y=m;return i&&(y=Wl(m,u)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function k$(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Fe(0,r);const s=Fe(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const I$={kernelName:Xn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=k$(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},N$=XN(Jn,(e=>1/e)),S$={kernelName:Jn,backendName:"cpu",kernelFunc:N$};const C$={kernelName:nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;HN(s,"resizeBilinear");const u=$e(s.shape),[l,c]=o,[h,p,d,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(re([h,l,c,f])),y=[a&&l>1?p-1:p,a&&c>1?d-1:d],b=[a&&l>1?l-1:l,a&&c>1?c-1:c];let x=0;const w=y[0]/b[0],v=y[1]/b[1];for(let e=0;e<h;e++)for(let t=0;t<l;t++){let n;n=i?w*(t+.5)-.5:w*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(p-1,Math.ceil(n)),o=e*u[0]+r*u[1],l=e*u[0]+a*u[1];for(let e=0;e<c;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(d-1,Math.ceil(t)),c=o+n*u[2],h=l+n*u[2],p=o+a*u[2],y=l+a*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[p+e]-t)*r,i=a+(n+(m[y+e]-n)*r-a)*s;g[x++]=i}}}return n.makeTensorInfo([h,l,c,f],"float32",g)}};const E$={kernelName:rr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;HN([a,s],"resizeBilinearGrad");const o=$e(s.shape),[u,l,c,h]=s.shape,[,p,d]=a.shape,f=new Float32Array(u*l*c*h),m=[i&&p>1?l-1:l,i&&d>1?c-1:c],g=[i&&p>1?p-1:p,i&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values;let w=0;for(let e=0;e<u;e++){const t=e*o[0];for(let e=0;e<p;e++){const n=e*y,r=Math.floor(n),s=Math.min(Math.ceil(n),l-1),a=t+r*o[1],i=t+s*o[1],u=n-r,p=1-u;for(let e=0;e<d;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,l=1-s,d=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],v=p*l,k=p*s,I=u*l,N=u*s;for(let e=0;e<h;e++){const t=x[w++];f[d+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*N}}}}return n.makeTensorInfo([u,c,l,h],"float32",f)}};const T$={kernelName:er,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;HN(s,"resizeNearestNeighbor");const u=$e(s.shape),[l,c]=o,[h,p,d,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*c*f),y=[a&&l>1?p-1:p,a&&c>1?d-1:d],b=[a&&l>1?l-1:l,a&&c>1?c-1:c],x=y[0]/b[0],w=y[1]/b[1];let v=0;for(let e=0;e<h;e++){const t=e*u[0];for(let e=0;e<l;e++){const n=i?x*(e+.5):x*e;let r=Math.min(p-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=t+r*u[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(d-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*u[2];for(let e=0;e<f;e++){const t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([h,l,c,f],s.dtype,g)}};const $$={kernelName:tr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;HN([a,s],"resizeNearestNeighborGrad");const o=$e(s.shape),u=$e(a.shape),[l,c,h,p]=s.shape,[,d,f]=a.shape,m=new Float32Array(l*c*h*p),g=n.data.get(a.dataId).values,y=[i&&d>1?c-1:c,i&&f>1?h-1:h],b=[i&&d>1?d-1:d,i&&f>1?f-1:f],x=y[0]/b[0],w=y[1]/b[1],v=1/x,k=1/w,I=2*Math.ceil(v)+2,N=2*Math.ceil(k)+2;for(let e=0;e<l;e++){const t=e*o[0];for(let e=0;e<c;e++){const n=t+e*o[1],r=Math.floor(e*v),s=Math.floor(r-I/2);for(let r=0;r<h;r++){const a=n+r*o[2],l=Math.floor(r*k),y=Math.floor(l-N/2);for(let n=0;n<p;n++){let o=0;for(let a=0;a<I;a++){const l=a+s;if(l<0||l>=d)continue;const p=t+l*u[1],m=l*x;if(e===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const s=p+t*u[2],a=t*w;r===Math.min(h-1,i?Math.round(a):Math.floor(a))&&(o+=g[s+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const A$={kernelName:ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;HN(s,"reverse");const i=s.shape.length,o=de(a,s.shape);if(0===i)return QN({inputs:{x:s},backend:n});const u=new ds(s.shape,s.dtype),l=n.bufferSync(s);for(let e=0;e<u.size;e++){const t=u.indexToLoc(e),n=t.slice();o.forEach((e=>n[e]=s.shape[e]-1-n[e])),u.set(l.get(...n),...t)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},R$={kernelName:zr,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=me(r.dtype,re(r.shape)),[l,c,h,p]=r.shape,[d,f]=Up(i,c,h),m=Math.sin(s),g=Math.cos(s),y=o.data.get(r.dataId).values;for(let e=0;e<l;e++){const t=e*h*c*p;for(let e=0;e<c;e++){const n=e*(h*p);for(let r=0;r<h;r++){const s=r*p;for(let i=0;i<p;i++){const o=[l,e,r,i],b=o[2],x=o[1];let w=(b-d)*g-(x-f)*m,v=(b-d)*m+(x-f)*g;w=Math.round(w+d),v=Math.round(v+f);let k=a;if("number"!=typeof a&&(k=3===i?255:a[i]),w>=0&&w<h&&v>=0&&v<c){k=y[t+v*(h*p)+w*p+i]}u[t+n+s+i]=k}}}}return{dataId:o.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_$=XN(ir,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),F$={kernelName:ir,backendName:"cpu",kernelFunc:_$},D$=gC((e=>1/Math.sqrt(e))),O$=YN(or,D$),M$={kernelName:or,backendName:"cpu",kernelFunc:O$};function L$(e,t,n,r,s,a,i,o,u,l){const c=[r/s,s],h=e.values,p=t.values;if(0===r)return ja(n,t.dtype);const d=ja(c,t.dtype);d.values.fill(u);for(let e=0;e<a;e++){const a=[];let u=0;for(let t=0;t<i;t++){const n=h[e*i+t];a.push(n),u+=n*o[t]}if(u<0||u>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)l?d.values[u*s+n]+=p[e*s+n]:d.values[u*s+n]=0===t.rank?p[0]:p[e*s+n]}return d}const z$={kernelName:ur,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ii(0,s,i),p=L$(n.bufferSync(s),n.bufferSync(a),i,h,l,u,o,c,0,!0);return n.makeTensorInfo(i,p.dtype,p.values)}};const B$={kernelName:lr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;HN([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=Cs(s.dtype,a.dtype),h=Fe(re(s.shape),c);let p=0;const d=0===i||i>1||1===s.shape.length?1:re(s.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<d;t++)1===o[e]?h[p++]=u[e]:h[p++]=l[e];return n.makeTensorInfo(s.shape,c,h)}},P$=Xp,V$=Yp,W$=XN(cr,(e=>e>=0?V$*e:P$*(Math.exp(e)-1))),U$={kernelName:cr,backendName:"cpu",kernelFunc:W$},G$=XN(mr,(e=>1/(1+Math.exp(-e)))),j$={kernelName:mr,backendName:"cpu",kernelFunc:G$},H$=XN(fr,(e=>e<0?-1:e>0?1:0)),q$={kernelName:fr,backendName:"cpu",kernelFunc:H$},K$=XN(pr,(e=>Math.sin(e))),X$={kernelName:pr,backendName:"cpu",kernelFunc:K$},Y$=XN(dr,(e=>Math.sinh(e))),J$={kernelName:dr,backendName:"cpu",kernelFunc:Y$},Z$=Math.log(1.1920928955078125e-7)+2,Q$=XN(gr,(e=>{const t=e>-Z$,n=e<Z$,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),eA={kernelName:gr,backendName:"cpu",kernelFunc:Q$};const tA={kernelName:xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;HN([s],"spaceToBatchND");const o=re(a),u=[[0,0]];u.push(...i);for(let e=1+a.length;e<s.shape.length;++e)u.push([0,0]);const l=g$.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=Gp(l.shape,a,o,!1),h=jp(c.length,a.length,!1),p=Hp(l.shape,a,o,!1),d=SS({inputs:{x:l},backend:n,attrs:{shape:c}}),f=zS({inputs:{x:d},backend:n,attrs:{perm:h}}),m=SS({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}};const nA={kernelName:Sr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=Ii(0,s,o),d=L$(n.bufferSync(s),n.bufferSync(a),o,p,c,l,u,h,n.data.get(i.dataId).values[0],!1);return n.makeTensorInfo(o,d.dtype,d.values)}};const rA={kernelName:wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=de(i,s.shape)[0],u=dd(s,a,o),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map((e=>{const t=[...c];t[o]=e;const r=cC({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,r}))}},sA=XN(yr,(e=>Math.sqrt(e))),aA={kernelName:yr,backendName:"cpu",kernelFunc:sA},iA={kernelName:Ir,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;HN(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},oA=rS(((e,t)=>{const n=e-t;return n*n})),uA=xS(kr,oA),lA={kernelName:kr,backendName:"cpu",kernelFunc:uA},cA=XN(Mr,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),hA={kernelName:Mr,backendName:"cpu",kernelFunc:cA};function pA(e,t,n,r){const s=ja(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s}const dA={kernelName:Cr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=r;HN(s,"stridedSlice");const{nonStrided:d,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Bi(s.shape,a,i,o,u,l,c,h,p),x=SS({inputs:{x:s},backend:n,attrs:{shape:y}});let w;if(d){const e=cC({inputs:{x:x},backend:n,attrs:{begin:f,size:g}});w=SS({inputs:{x:e},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(e)}else if(b.some((e=>0===e)))w=n.makeTensorInfo(b,s.dtype,[]);else{const e=pA(b,n.bufferSync(x),m,f);w=n.makeTensorInfo(e.shape,e.dtype,e.values)}const v=SS({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),v}},fA=XN(Er,(e=>Math.tan(e))),mA={kernelName:Er,backendName:"cpu",kernelFunc:fA},gA=XN(Tr,(e=>Math.tanh(e)));function yA(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=ja(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r}function bA(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],u=me(n,i*r),l=me("int32",i*r);for(let t=0;t<i;t++){const n=t*o,s=e.subarray(n,n+o),a=[];for(let e=0;e<s.length;e++)a.push({value:s[e],index:e});a.sort(((e,t)=>t.value-e.value));const i=t*r,c=u.subarray(i,i+r),h=l.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,h[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[ja(c,n,u),ja(c,"int32",l)]}function xA(e,t,n,r){const s=de(t,n)[0],a=[1,n[0],1];for(let e=0;e<s;e++)a[0]*=n[e];a[1]=n[s];for(let e=s+1;e<n.length;e++)a[2]*=n[e];const i={},o=new Int32Array(n[s]),u=new ds(a,r,e),l=[],c=1===a[0]&&1===a[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(u.get(n,t,r));n=e.join(",")}if(void 0!==i[n])o[t]=i[n];else{const e=Object.keys(i).length;i[n]=e,o[t]=e,l.push(t)}}const h=a.slice();h[1]=Object.keys(i).length;const p=new ds(h,r);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(u.get(n,e,r),n,t,r)}));const d=n.slice();return d[s]=h[1],{outputValues:p.values,outputShape:d,indices:o}}const wA=[$S,RS,FS,OS,NS,MS,PS,VS,WS,US,jS,qS,XS,ZS,eC,sC,aC,iC,oC,TS,uC,pC,mC,bS,xC,vC,dS,kC,EC,AC,RC,$C,FC,DC,_C,MC,zC,BC,PC,VC,WC,GC,jC,HC,qC,KC,YC,XC,IE,ZN,JC,eE,uE,hE,dE,gE,RE,FE,DE,LE,PE,VE,WE,UE,jE,KE,JE,eS,ZE,SC,eT,nT,sT,nS,oT,cT,pT,mT,yT,wT,kT,ST,CT,ET,FT,DT,OT,MT,LT,zT,AT,VT,WT,jT,HT,XT,ZT,wE,e$,n$,s$,i$,l$,c$,d$,m$,g$,x$,iS,v$,I$,gS,S$,uS,cS,CS,C$,E$,T$,$$,A$,R$,F$,M$,z$,B$,U$,j$,q$,X$,J$,hC,JT,eA,tA,nA,rA,aA,iA,lA,hA,dA,EE,PT,mA,{kernelName:Tr,backendName:"cpu",kernelFunc:gA},{kernelName:$r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;HN(s,"tile");const i=yA(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:Ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;HN(s,"topk");const o=n.data.get(s.dataId).values,[u,l]=bA(o,s.shape,s.dtype,a);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},BS,{kernelName:_r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;HN(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:l}=xA(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},{kernelName:Fr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],u=new Array(i-1);let l=0;for(let e=0;e<i;e++)e!==a&&(u[l++]=s.shape[e]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const p=new Array(o);for(let e=0;e<p.length;e++){c[a]=e;const t=cC({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});p[e]=SS({inputs:{x:t},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(t)}return p}},{kernelName:Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;HN(s,"unsortedSegmentSum");const o=[],u=[],l=s.shape.length-a.shape.length;let c=a;for(let e=0;e<l;++e){const t=pE({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,u.push(t)}for(let e=0;e<i;++e){const t=os(e,"int32"),r=n.makeTensorInfo([],"int32",t),a=QC({inputs:{a:r,b:c},backend:n}),i=yS({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=xE({inputs:{a:i,b:s},backend:n}),h=BT({inputs:{x:l},backend:n,attrs:{axis:0,keepDims:!1}});o.push(h),u.push(r),u.push(a),u.push(i),u.push(l),u.push(h)}const h=f$({inputs:o,backend:n,attrs:{axis:0}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},p$];for(const e of wA)qr(e);const vA={},kA={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function IA(e){if(!(e in vA)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete vA[e]}),!1),1===e)return t.getContext("webgl",kA)||t.getContext("experimental-webgl",kA);return t.getContext("webgl2",kA)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;vA[e]=t}const t=vA[e];return t.isContextLost()?(delete vA[e],IA(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),vA[e])}var NA,SA,CA;function EA(e,t){return[t,e]}function TA(e){const t=re(e);return ue(Math.ceil(t/4))}function $A(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function AA(e,t){const n=e;let r,s,a,i,o,u,l,c,h,p;return 2===Ve().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,c=1,h=n.HALF_FLOAT,p=n.FLOAT):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT),u=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:p}}function RA(e,t){const n=t();return Ve().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(NA||(NA={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(SA||(SA={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(CA||(CA={}));function _A(e){return!!(Ve().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function FA(e,t){return WA(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function DA(e,t){const n=WA(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(RA(e,(()=>e.shaderSource(n,t))),RA(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=OA.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>ce((t+1).toString(),a)+e));let o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ce(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const OA=/ERROR: [0-9]+:([0-9]+):/g;function MA(e,t){if(RA(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function LA(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(RA(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),RA(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),RA(e,(()=>e.enableVertexAttribArray(o))),!0)}function zA(e,t,n,r){RA(e,(()=>function(e,t,n){UA(e,n),RA(e,(()=>e.activeTexture(e.TEXTURE0+n))),RA(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),RA(e,(()=>e.uniform1i(n,r)))}function BA(e,t,n){RA(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),RA(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function PA(e,t){RA(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),RA(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function VA(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function WA(e,t,n){const r=RA(e,(()=>t()));if(null==r)throw new Error(n);return r}function UA(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function GA(e,t=2){return re(e.slice(0,e.length-t))}function jA(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function HA(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[GA(e),...jA(e)]),t}function qA(e){return e%2==0}function KA(e,t){if(ae(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(qA(n)&&qA(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&qA(e[0])&&qA(t[0])}let XA,YA;function JA(e,t){return null!=e.getExtension(t)}function ZA(e){try{if(null!=IA(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function QA(e){if(0===e)return!1;const t=IA(e);if(1!==e){if(JA(t,"EXT_color_buffer_float"))return eR(t);const e="EXT_color_buffer_half_float";if(JA(t,e)){const n=t.getExtension(e);return function(e,t){const n=AA(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!JA(t,"OES_texture_float"))return!1;if(!JA(t,"WEBGL_color_buffer_float"))return!1;return eR(t)}function eR(e){const t=AA(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function tR(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Q("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const nR=Ve();function rR(){let e,t,n,r,s,a,i,o,u,l;return 2===Ve().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}function sR(e,t,n="index"){const r=$e(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function aR(e){const t=$e(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}nR.registerFlag("HAS_WEBGL",(()=>nR.getNumber("WEBGL_VERSION")>0)),nR.registerFlag("WEBGL_VERSION",(()=>ZA(2)?2:ZA(1)?1:0)),nR.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),nR.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===nR.get("WEBGL_VERSION"))),nR.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),nR.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),nR.registerFlag("WEBGL_PACK",(()=>nR.getBool("HAS_WEBGL"))),nR.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_CLIP",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),nR.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_PACK_REDUCE",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_LAZILY_UNPACK",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_CONV_IM2COL",(()=>nR.getBool("WEBGL_PACK"))),nR.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==XA){const t=IA(e);XA=t.getParameter(t.MAX_TEXTURE_SIZE)}return XA}(nR.getNumber("WEBGL_VERSION")))),nR.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==YA){const t=IA(e);YA=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,YA)}(nR.getNumber("WEBGL_VERSION")))),nR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=nR.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=IA(e);return t=JA(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:JA(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),nR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>nR.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Bs())),nR.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=IA(e);if(1===e){if(!JA(t,"OES_texture_float"))return!1}else if(!JA(t,"EXT_color_buffer_float"))return!1;return eR(t)}(nR.getNumber("WEBGL_VERSION")))),nR.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!nR.getBool("WEBGL_FORCE_F16_TEXTURES")&&nR.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),nR.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>QA(nR.getNumber("WEBGL_VERSION")))),nR.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=nR.getNumber("WEBGL_VERSION"))&&null!=IA(e).fenceSync;var e})),nR.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>nR.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),nR.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}));const iR="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class oR{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=NA.DENSE;const t=TA(e),n=rR();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${sR(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class uR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=NA.DENSE;const t=TA(e),n=rR();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${sR(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class lR{constructor(e){this.variableNames=["A"],this.outTexUsage=SA.DOWNLOAD;const t=rR();this.outputShape=e,this.userCode=`\n      ${iR}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class cR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=SA.DOWNLOAD;const t=rR();this.outputShape=e,this.userCode=`\n      ${iR}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class hR{constructor(e,t,n=!1){this.variableNames=["A"];const r=rR(),[s,a]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`\n      ${aR(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class pR{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=rR(),[s,a]=t;this.outputShape=e;let i="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const o=2*t+n;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${o}] = values[0];\n              } else if(offset == 1) {\n                result[${o}] = values[1];\n              } else if(offset == 2) {\n                result[${o}] = values[2];\n              } else {\n                result[${o}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${aR(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${i}\n\n        ${r.output} = ${o};\n      }\n    `}}function dR(e){const t=rR();return function(e,t){const n=WA(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(RA(e,(()=>e.shaderSource(n,t))),RA(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function fR(e){return function(e,t){const n=WA(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return RA(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),RA(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function mR(e){return function(e,t){const n=WA(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return RA(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),RA(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function gR(e,t,n,r,s,a){!function(e,t){const n=Ve().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return WA(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return RA(e,(()=>e.bindTexture(o,i))),RA(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),RA(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),RA(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),RA(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),RA(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))),RA(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),i}function yR(e){return e.internalFormatFloat}function bR(e){return e.internalFormatHalfFloat}function xR(e){return e.downloadTextureFormat}function wR(e){return e.internalFormatPackedFloat}function vR(e){return e.internalFormatPackedHalfFloat}function kR(e,t,n,r,s,a,i,o){const u=e,l=new Float32Array(function(e,t){const[n,r]=$A(e,t);return n*r*4}(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}class IR{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Ve().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){vA[e]=t}(t,e)):this.gl=IA(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===Ve().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=FA(this.gl,e),JA(this.gl,t))this.textureHalfFloatExtension=FA(this.gl,t);else if(Ve().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),JA(this.gl,r))this.colorBufferHalfFloatExtension=FA(this.gl,r);else if(Ve().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",JA(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!JA(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=fR(this.gl),this.indexBuffer=mR(this.gl),this.framebuffer=function(e){return WA(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=AA(this.gl,this.textureHalfFloatExtension)}get debug(){return Ve().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;RA(e,(()=>e.finish())),RA(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),RA(e,(()=>e.deleteFramebuffer(this.framebuffer))),RA(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),RA(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),RA(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=EA(t,n);return gR(e,s,a,yR(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=EA(t,n);return gR(e,s,a,bR(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=EA(t,n);return gR(e,s,a,xR(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){RA(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?RA(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):RA(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),RA(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,u;RA(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(s),RA(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,i))),RA(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$A(t,n);return gR(e,s,a,vR(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$A(t,n);return gR(e,s,a,wR(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(PA(this.gl,this.framebuffer),this.outputTexture=null),RA(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=EA(t,n),i=new Uint8Array(t*n*4);return RA(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return kR(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const s=e.createBuffer();RA(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const a=16*t*n;return RA(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),RA(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),RA(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Ve().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return RA(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=DA(t,e),r=dR(t),s=function(e){return WA(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return RA(t,(()=>t.attachShader(s,r))),RA(t,(()=>t.attachShader(s,n))),function(e,t){if(RA(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,s),this.debug&&MA(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(e,t,n){return RA(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),LA(e,t,"clipSpacePos",n,3,20,0)&&LA(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&RA(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&MA(this.gl,this.program),RA(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return WA(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),RA(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),zA(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=$A(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&MA(this.gl,this.program),VA(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),RA(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),RA(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=FA(this.gl,2===Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await he((()=>this.disposed||this.isQueryAvailable(e,Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||he((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),BA(this.gl,e,this.framebuffer),this.debug&&VA(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(BA(this.gl,this.outputTexture,this.framebuffer),this.debug&&VA(this.gl)):PA(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;BA(r,e,this.framebuffer),this.debug&&VA(r),this.outputTexture=e,RA(r,(()=>r.viewport(0,0,t,n))),RA(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),RA(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:NR}=g;function SR(e,t,n,r){const s=[];e.forEach((e=>{const t=re(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))}));const a=s.join("\n"),i=e.map((e=>function(e,t,n=!1){let r="";r+=n?ER(e):CR(e);const s=e.shapeInfo.logicalShape,a=t.logicalShape;s.length<=a.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=NR(e.shapeInfo.logicalShape,t.logicalShape),u=OR(i),l=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+l]} = 0;`)).join("\n");let p="";p=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+l]}`)).join(", ");let d="return outputValue;";const f=1===re(e.shapeInfo.logicalShape),m=1===re(t.logicalShape);if(1!==a||f||m){if(f&&!m)d=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?d="return vec4(outputValue.x);":o.indexOf(e)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${p});\n      ${d}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&null==e.shapeInfo.flatOffset&&ae(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=OR(u),c=NR(e.shapeInfo.logicalShape,t.logicalShape),h=u-o;let p;const d=["x","y","z","w","u","v"];p=0===o?"":u<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${d[e+h]} = 0;`)).join("\n");let f="";f=u<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+h]}`)).join(", ");return`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      return get${r}(${f});\n    }\n  `}(e,t));return r}(e,t,r))).join("\n"),o=t.texShape,u=rR(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,h,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${TR}\n    ${$R}\n    ${AR}\n  `}(u);t.isPacked?(c=function(e,t){switch(e.length){case 0:return _R();case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ae(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let a=s,i="",o="b, r, c";for(let t=2;t<e.length-1;t++)a*=e[e.length-t-1],i=`\n      int b${t} = index / ${a};\n      index -= b${t} * ${a};\n    `+i,o=`b${t}, `+o;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${o});\n    }\n  `}(e,t)}}(t.logicalShape,o),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return _R();case 1:return function(e,t){if(1===t[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t);case 2:return function(e,t){if(ae(e,t))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=sR(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=sR(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=sR(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=sR(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,o),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(p+=RR);return[p,l,h,a,c,i,n].join("\n")}function CR(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[a,i]=e.shapeInfo.texShape,o=FR(t);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${i}, ${o});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${DR(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],a=r[1];if(1===a&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=FR(t);if(1===a)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===s)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&ae(t,s)){const e=s[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:a,keptDims:i}=fe(t),o=a;if(o.length<t.length){const t=["row","col"];return`\n      ${CR(MR(e,o))}\n      float ${r}(int row, int col) {\n        return ${r}(${LR(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${DR(e)}\n      }\n    `;const u=s[0],l=s[1],c=FR(n);if(1===l)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;if(1===u)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:o}=fe(t),u=i;if(u.length<t.length){const t=["row","col","depth"];return`\n        ${CR(MR(e,u))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${LR(t,o)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${DR(e)}\n      }\n    `;const l=e.shapeInfo.texShape,c=l[0],h=l[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(h===a&&null==p)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const d=FR(n);return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${d};\n        vec2 uv = uvFromFlat(${c}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:o,keptDims:u}=fe(t);if(o.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${CR(MR(e,o))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${LR(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${a}, ${s}, 1)));\n        ${DR(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],p=c[1];if(p===i&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const d=FR(n);return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${d});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:l}=fe(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${CR(MR(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${LR(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${DR(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],d=h[1];if(d===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(d===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=FR(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${p}, ${d}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=fe(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${CR(MR(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${LR(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,u=t[3]*o,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${DR(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=FR(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${d}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function ER(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=rR();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=rR();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=s[0],i=s[1],o=rR();if(null!=s&&ae(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);\n\n        return ${o.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=Math.ceil(t[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${ER(MR(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${LR(s,n)});\n        }\n      `}const i=a[0],o=a[1],u=Math.ceil(t[2]/2),l=u*Math.ceil(t[1]/2),c=rR();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${o}, ${l}, ${u}, b, row, col);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],o=i[0],u=i[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),h="int b, int row, int col",p=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let e=2;e<n-1;e++)h=`int b${e}, `+h,c*=t[n-e-1],p=`b${e} * ${c} + `+p;const d=rR();return`\n    vec4 ${s}(${h}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${o});\n      return ${d.texture2D}(${r}, uv);\n    }\n  `}(e)}}const TR="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$R="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",AR="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RR="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function _R(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function FR(e){return`offset${e}`}function DR(e){const t=e.name,n=re(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function OR(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function MR(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function LR(e,t){return t.map((t=>e[t])).join(", ")}function zR(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!ae(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!ae(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}const{addImpl:BR,bincountImpl:PR,bincountReduceImpl:VR,ceilImpl:WR,concatImpl:UR,expImpl:GR,expm1Impl:jR,floorImpl:HR,gatherV2Impl:qR,greaterImpl:KR,lessImpl:XR,linSpaceImpl:YR,logImpl:JR,maxImpl:ZR,maximumImpl:QR,minimumImpl:e_,multiplyImpl:t_,negImpl:n_,prodImpl:r_,rangeImpl:s_,rsqrtImpl:a_,simpleAbsImpl:i_,sliceImpl:o_,stridedSliceImpl:u_,subImpl:l_,tileImpl:c_,topKImpl:h_,transposeImpl:p_,uniqueImpl:d_}=W;function f_(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function m_(e,t){return 1===t?[e]:f_(e,t)}class g_{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=m_("rc",t),r=OR(t),s=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),a=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),i=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)a=`${t[t.length-1-n]},`+a;n.push(a)}return n}(n,t);if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}}class y_{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${sR(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${aR(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class b_{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=w_(t,n),s=v_(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=x_(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let i;return r===CA.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===CA.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===CA.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===CA.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===CA.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=w_(n,r),a=v_(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=x_(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Ve().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function x_(e,t,n,r,s){const a=function(e,t){switch(e){case CA.PACKED_2X2_FLOAT32:return wR(t);case CA.PACKED_2X2_FLOAT16:return vR(t);case CA.UNPACKED_FLOAT32:return yR(t);case CA.UNPACKED_FLOAT16:return bR(t);case CA.PACKED_4X1_UNSIGNED_BYTE:return xR(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=$A(e[0],e[1]);i=t*n}else{const[t,n]=EA(e[0],e[1]);i=t*n}return i*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,a)}function w_(e,t){if(e===SA.UPLOAD)return CA.PACKED_2X2_FLOAT32;if(e===SA.RENDER||null==e)return function(e){return Ve().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?CA.PACKED_2X2_FLOAT32:CA.UNPACKED_FLOAT32:e?CA.PACKED_2X2_FLOAT16:CA.UNPACKED_FLOAT16}(t);if(e===SA.DOWNLOAD||e===SA.PIXELS)return CA.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function v_(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class k_{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const I_="return abs(x);";const N_="return x;";class S_{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class C_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=m_("rc",t),r=OR(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const E_=kh,T_={};class $_ extends G{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Ve().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=IA(Ve().getNumber("WEBGL_VERSION"));this.binaryCache=((t=Ve().getNumber("WEBGL_VERSION"))in T_||(T_[t]={}),T_[t]),this.gpgpu=new IR(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new b_(this.gpgpu),this.numMBBeforeWarning=null==Ve().global.screen?1024:Ve().global.screen.height*Ve().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new U(this,io())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,t,n){if((Ve().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ve().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:SA.UPLOAD,refCount:1,complexParentRefCount:0}),r}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}decComplexRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.complexParentRefCount>0&&t.refCount--}}move(e,t,n,r){if(Ve().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:SA.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new S_(i,N_):new k_(i,N_);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;if(u&&(l=ls()),"complex64"===r){c=ad(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=ls()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new S_(r,N_):new k_(r,N_);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(!Ve().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ve().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,c=null;if("complex64"!==a&&Ve().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture,...TA(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=ad(e[0],e[1])}else if(null==c)l=this.getValuesFromTexture(e);else{const e=re(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}null!=u&&this.disposeIntermediateTensorInfo(u);const h=this.convertAndCacheOnCPU(e,l),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),h}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>ps(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return ja(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!_A(n)){if(Ve().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=re(t);if(Ve().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...TA(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=Ve().getBool("WEBGL_PACK")&&!0===r,i=a?HA(t):t,o=a?new cR(i):new lR(i),u=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}async time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=ne(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=ne(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=Y(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ls(),endMs:null}}endTimer(e){return Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ls(),e)}async getQueryTime(e){if(Ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){if(this.pendingDisposal.has(e))return;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(!this.texData.has(e))return;if(this.texData.get(e).complexParentRefCount>0)return void this.texData.get(e).refCount--;this.releaseGPUData(e);const{complexTensorInfos:t}=this.texData.get(e);null!=t&&(this.texData.get(t.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(t.real),this.texData.get(t.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(t.imag)),this.texData.delete(e)}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return Ve().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=io().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,t=128){const n=this.getCPUBackend();return Ve().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&e.every((e=>null==this.texData.get(e.dataId).texture&&re(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){rd("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return E_(e.shape,t)}packedUnaryOp(e,t,n){const r=new S_(e.shape,t);return this.compileAndRun(r,[e],n)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=i_(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Ve().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,I_,e.dtype);const t=new k_(e.shape,I_);return this.compileAndRun(t,[e])}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ie(n[0])){const s=n.map((e=>hs(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return io().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new C_(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new g_(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[GA(e.shape),...jA(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[GA(t),...jA(t)],a=new y_(s,n),i=this.runWebGLProgram(a,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,a=HA(r);let i;i=n?new uR(a):new oR(a);return{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:a,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===NA.DENSE){const t=TA(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===re(a.shape))return i.values=me(a.dtype,0),a;const o=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&re(t.shape)<=Ve().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),o.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!KA(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),o.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const l={shape:a.shape,texData:i,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach((e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${n}_${t}`}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s,a}(e,u,l),h=this.getAndSaveBinary(c,(()=>function(e,t,n,r){const s=t.userCode,a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=a.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=SR(a,o,s,t.packedInputs),l=e.createProgram(u);let c=null;const h=e.getUniformLocation(l,"NAN",!1);1===Ve().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const p={};for(let n=0;n<t.variableNames.length;n++){const r=t.variableNames[n],s=!1;p[r]=e.getUniformLocation(l,r,s),p[`offset${r}`]=e.getUniformLocation(l,`offset${r}`,s)}return{program:t,source:u,webGLProgram:l,uniformLocations:p,inShapeInfos:i,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,e,u,l))),p=null!=this.activeTimers;let d;if(p&&(d=this.startTimer()),function(e,t,n,r,s){zR(t.inShapeInfos,n),zR([t.outShapeInfo],[r]);const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a,i[0],i[1]):e.setOutputMatrixTexture(a,i[0],i[1]),e.setProgram(t.webGLProgram),1===Ve().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{const s=t.program.variableNames[r],a=t.uniformLocations[s],i=t.uniformLocations[`offset${s}`];if(null!=a)if(n.isUniform)if(re(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,r)})),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,u,l,r),o.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)})),!Ve().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,r,s=!1){n=n||t[0].dtype;const a=this.runWebGLProgram(e,t,n,r,s);return io().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Ve().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=lo((()=>{if(!Ve().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ve().getBool("DEBUG");Ve().set("DEBUG",!1);const t=this.abs(Lo(1e-8)).dataSync()[0];if(Ve().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const u=null!=this.activeTimers;let l;u&&(l=ls());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=Ve().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?X(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=fe(e);e=t.newShape}let r=re(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=GA(e);let n=2,s=2;return e.length&&([n,s]=jA(e)),r=t*(n/2)*(s/2),ue(r).map((e=>2*e))}return ue(r)}(n,o),t.texShape=c),null!=s){const e=HA(n);let a,i=c[1],h=c[0];const p=s instanceof Uint8Array;o?([i,h]=$A(c[0],c[1]),a=new pR(e,[h,i],p)):a=new hR(e,[h,i],p);const d=this.makeTensorInfo([h,i],r);this.texData.get(d.dataId).usage=p?SA.PIXELS:SA.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(d.dataId),i,h,s);const f=!0,m=this.runWebGLProgram(a,[d],r,null,f),g=this.texData.get(m.dataId);t.texture=g.texture,t.texShape=g.texShape,t.isPacked=g.isPacked,t.usage=g.usage,this.disposeIntermediateTensorInfo(d),this.texData.delete(m.dataId),t.values=null,u&&(this.uploadWaitMs+=ls()-l)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ve(t)}}Ps()&&wo("webgl",(()=>new $_),2);class A_{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Ko(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class R_{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ko(t,n);const s=this.outputShape.length;let a="";if(r)if(0===s||1===re(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${OR(s)} coords = getOutputCoords();\n        `,1===s)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=m_("coords",s);a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function __(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const F_={kernelName:rn,backendName:"webgl",kernelFunc:__};function D_(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=__({inputs:{x:r},backend:n});n.texData.get(o.dataId).complexParentRefCount++;const u=__({inputs:{x:s},backend:n});return n.texData.get(u.dataId).complexParentRefCount++,i.complexTensorInfos={real:o,imag:u},a}const O_={kernelName:yt,backendName:"webgl",kernelFunc:D_},M_="return (a < 0.) ? b * a : a;",L_="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const z_={kernelName:cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",os(a,"float32")),o=Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new R_(L_,s.shape,i.shape):new A_(M_,s.shape,i.shape),u=n.runWebGLProgram(o,[s,i],s.dtype);return n.disposeIntermediateTensorInfo(i),u}},B_="return (a < 0.) ? b * a : a;",P_="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const V_={kernelName:qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new R_(P_,r.shape,s.shape):new A_(B_,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}};function W_({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,u);return o.makeTensorInfo(i.shape,u,t)}let l;return l=Ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new S_(i.shape,t):new k_(i.shape,e),o.runWebGLProgram(l,[i],u)}}function U_({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,c=o;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new A_(e,u.shape,l.shape);return c.runWebGLProgram(i,[s,a],Cs(n.dtype,r.dtype))})),a=D_({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const h=a||Cs(u.dtype,l.dtype);if(c.shouldExecuteOnCPU([u,l])&&null!=s){const e=c.texData.get(u.dataId),t=c.texData.get(l.dataId),[n,r]=s(u.shape,l.shape,e.values,t.values,h),a=c.makeTensorInfo(r,h);return c.texData.get(a.dataId).values=n,a}let p;return p=Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new R_(t,u.shape,l.shape,n):new A_(e,u.shape,l.shape),c.runWebGLProgram(p,[u,l],h)}}function G_(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?P_:B_;if("leakyrelu"===e)return t?L_:M_;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class j_{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=r?e[1]:e[2],c=Math.ceil(l/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${f[0]});\n          result += (${d[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const H_="return areal * breal - aimag * bimag;",q_="return areal * bimag + aimag * breal;";class K_{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ko(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const X_="return a * b;";function Y_(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Cs(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new K_(H_,r.shape,s.shape),i=new K_(q_,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(a,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),c=D_({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=t_(r.shape,s.shape,e.values,t.values,a),u=n.makeTensorInfo(o,a);return n.texData.get(u.dataId).values=i,u}let i;return i=Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new R_(X_,r.shape,s.shape):new A_(X_,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const J_={kernelName:On,backendName:"webgl",kernelFunc:Y_};function Z_(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=re(s.shape),u=pe(a,o),l=re(u);Q(o===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||KA(s.shape,u)||null!==c.texture&&KA(c.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[GA(e.shape),...jA(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[GA(t),...jA(t)],i=new y_(a,r),o=n.runWebGLProgram(i,[s],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}(s,u,i)}const Q_={kernelName:Qn,backendName:"webgl",kernelFunc:Z_};class eF{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${ie(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class tF{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,p="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function nF(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Wp(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:u,outSize:l}=s[i];let c,h;c="mean"===n?0===i?new eF({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new eF({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new tF({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class rF{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=OR(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class sF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=OR(this.rank),s=f_("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function aF(e,t,n){const r=Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sF(e.shape,t):new rF(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function iF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=de(s,e.shape);let o=i;const u=Gl(o,a),l=null!=u;let c=e;l&&(c=aF(e,u,r),o=Hl(o.length,a)),Ul("sum",o,a);const[h,p]=Vl(c.shape,o);let d=h;n&&(d=Wl(h,i));const f=re(p),m=Z_({inputs:{x:c},attrs:{shape:[re(e.shape)/f,f]},backend:r}),g=nF(m,Es(e.dtype),"sum",r),y=Z_({inputs:{x:g},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),l&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const oF={kernelName:br,backendName:"webgl",kernelFunc:iF};function uF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let e=0;e<u.length;e++)u[e]=s.shape[a[e]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=p_(e,s.shape,s.dtype,a,u);l=i.makeTensorInfo(u,s.dtype);i.texData.get(l.dataId).values=t}else l=aF(s,a,i);return l}const lF={kernelName:Rr,backendName:"webgl",kernelFunc:uF};function cF({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],p=r?t.shape[c-1]:t.shape[c-2],d=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=re(m),b=re(g);Q(l>=2&&c>=2&&(y===b||1===y||1===b),(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`));const x=(y>b?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([d,f]);Q(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const w=n?[y,h,d]:[y,d,h],v=r?[b,f,p]:[b,p,f],k=Z_({inputs:{x:e},backend:s,attrs:{shape:w}}),I=Z_({inputs:{x:t},backend:s,attrs:{shape:v}}),N=[k,I],S=Math.max(y,b),C=n?k.shape[1]:k.shape[2],E=null!=a,T=null!=i,$="leakyrelu"===u,A=null!=u?G_(u,!0):null;let R;if((1===d||1===f)&&C>1e3&&!1===(E||T||$||null!=A)){let e=k,t=I;n&&(e=uF({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=uF({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));const a=1===f;let i=e;1!==f&&(i=Z_({inputs:{x:e},backend:s,attrs:{shape:[S,C,1]}}),N.push(i));const o=1===f?2:1;let u=t;a&&(u=Z_({inputs:{x:t},backend:s,attrs:{shape:[S,1,C]}}),N.push(u));const l=Y_({inputs:{a:i,b:u},backend:s});R=iF({inputs:{x:l},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(l)}else{const u=Cs(e.dtype,t.dtype),l=new j_(w,v,[S,d,f],n,r,E,A,T,$),c=[k,I];if(null!=a&&c.push(a),T&&c.push(i),$){const e=s.makeTensorInfo([],"float32",os(o,"float32"));c.push(e),N.push(e)}R=s.runWebGLProgram(l,c,u)}const _=Z_({inputs:{x:R},backend:s,attrs:{shape:x}});N.push(R);for(const e of N)s.disposeIntermediateTensorInfo(e);return _}const hF={kernelName:Br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return cF({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},pF="return abs(x);";const dF={kernelName:He,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=i_(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=Ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new S_(r.shape,pF):new k_(r.shape,pF),n.runWebGLProgram(s,[r],r.dtype)}},fF=W_({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),mF={kernelName:qe,backendName:"webgl",kernelFunc:fF},gF=W_({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),yF={kernelName:Ke,backendName:"webgl",kernelFunc:gF},bF="return a + b;",xF=U_({opSnippet:bF,packedOpSnippet:bF,supportsComplex:!0,cpuKernelImpl:BR}),wF={kernelName:Xe,backendName:"webgl",kernelFunc:xF};class vF{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class kF{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const IF={kernelName:Ye,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return __({inputs:{x:s[0]},backend:r});if(s.length>Ve().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>Cs(e,t))),i=s.map((e=>e.shape)),o=Ve().getBool("WEBGL_PACK")?new kF(s[0].shape,i):new vF(s[0].shape,i);return r.runWebGLProgram(o,s,a)}};const NF={kernelName:Je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=de(a,s.shape);let l=u;const c=Gl(l,o);let h=s;null!=c&&(h=uF({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Hl(l.length,o)),Ul("all",l,o);const[p,d]=Vl(h.shape,l),f=Z_({inputs:{x:h},backend:n,attrs:{shape:[-1,re(d)]}}),m=nF(f,f.dtype,"all",n);let g;if(i){g=Z_({inputs:{x:m},backend:n,attrs:{shape:Wl(p,u)}})}else g=Z_({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};const SF={kernelName:Ze,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=de(a,s.shape);let l=u;const c=Gl(l,o);let h=s;null!=c&&(h=uF({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Hl(l.length,o)),Ul("any",l,o);const[p,d]=Vl(h.shape,l),f=Z_({inputs:{x:h},backend:n,attrs:{shape:[-1,re(d)]}}),m=nF(f,f.dtype,"any",n);let g;if(i){g=Z_({inputs:{x:m},backend:n,attrs:{shape:Wl(p,u)}})}else g=Z_({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class CF{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class EF{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Q(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,u=OR(o),l=m_("coords",o);let c,h;if(1===a){h=o+1;const e=OR(h);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[o-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[o-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[o-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[o-2]};`}else h=o,c=`\n        ${u} sourceLocR = coords;\n        ++${l[o-1]};\n        ${u} sourceLocG = coords;\n        ++${l[o-2]};\n        ${u} sourceLocA = coords;\n        --${l[o-1]};\n        ${u} sourceLocB = coords;\n        --${l[o-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),d="."+p[h-1],f=p.map((e=>"int "+e)),m=m_("sourceLocR",h-1).concat("inIdx.r"),g=m_("sourceLocG",h-1).concat("inIdx.g"),y=m_("sourceLocB",h-1).concat("inIdx.b"),b=m_("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${l[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function TF(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=Wp(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},u=new CF(o,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=TF(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function $F(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=Wp(s[s.length-1]),i=new EF(s,a,n,null==r),o=null==r?[t]:[t,r],u=e.runWebGLProgram(i,o,"int32");if(u.shape.length===t.shape.length){const r=$F(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function AF(e,t,n,r){const s=[n];if(Ul("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!Ve().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[a,i]=Vl(t.shape,s),o=re(i),u=Z_({inputs:{x:t},backend:e,attrs:{shape:[-1,o]}});n.push(u);const l=TF(e,u,r);n.push(l);const c=Z_({inputs:{x:l},backend:e,attrs:{shape:a}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),c}return $F(e,t,r)}const RF={kernelName:Qe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=de(a,s.shape);const o=Gl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=uF({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Hl(i.length,u.shape.length)),Ul("argMax",[i[0]],u.shape.length);const c=AF(n,u,i[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const _F={kernelName:et,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=de(a,s.shape);const o=Gl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=uF({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Hl(i.length,u.shape.length)),Ul("argMin",[i[0]],u.shape.length);const c=AF(n,u,i[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},FF=W_({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),DF={kernelName:tt,backendName:"webgl",kernelFunc:FF},OF=W_({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),MF={kernelName:nt,backendName:"webgl",kernelFunc:OF},LF=W_({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),zF={kernelName:rt,backendName:"webgl",kernelFunc:LF},BF=U_({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),PF={kernelName:at,backendName:"webgl",kernelFunc:BF},VF=W_({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),WF={kernelName:st,backendName:"webgl",kernelFunc:VF};class UF{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${p}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const x=4*Math.floor(a/4),w=a%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class GF{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / count");const v=4*Math.floor(a/4),k=a%4,I=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const jF={kernelName:it,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tR(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;Q(Iu(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=du(s.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&ae(l.inShape,l.outShape))return __({inputs:{x:s},backend:n});const c=new UF(l,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};const HF={kernelName:ut,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r,c=fu(s.shape,a,i,[1,1,1],o,u,l),h=new GF(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class qF{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=o-1-e.padInfo.top,c=u-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class KF{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=c-1-e.padInfo.front,f=h-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const XF={kernelName:lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=fu(i.shape,o,u,[1,1,1],l,c),p=new KF(h);return n.runWebGLProgram(p,[s],i.dtype)}};const YF={kernelName:ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;tR([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=du(i.shape,o,u,1,l),h=new qF(c);return n.runWebGLProgram(h,[s],i.dtype)}};const JF={kernelName:ct,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return cF({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class ZF{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ko(e,t),Ko(e,n);let i="0.0";null!=r&&(Ko(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Ko(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class QF{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ko(e,t),Ko(e,n);let i="vec4(0.0)";null!=r&&(Ko(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Ko(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const eD={kernelName:Zt,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Q(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Q(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Q(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,a];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=o&&(h=o.shape,l.push(o));const p=Ve().getBool("WEBGL_PACK_NORMALIZATION")?new QF(r.shape,s.shape,a.shape,c,h,u):new ZF(r.shape,s.shape,a.shape,c,h,u);return t.runWebGLProgram(p,l,l[0].dtype)}};class tD{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=OR(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return nD.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${nD[t]} = start[${t}] + coords.${nD[t]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const nD=["x","y","z","w","u","v"];class rD{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=OR(this.rank),n=m_("coords",this.rank),r=m_("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function sD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=zi(s,a,i);if(Ni(s,o,u),0===re(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=o_(e.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=Mi(s.shape,o,u);if(l||!c){const e=Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rD(u):new tD(u),t=e.getCustomSetupFunc(o);return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.complexParentRefCount=0,i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Li(t,$e(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),a}(s,o,u,n)}const aD={kernelName:hr,backendName:"webgl",kernelFunc:sD},iD={kernelName:ht,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Q(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=Gp(s.shape,a,o),l=jp(u.length,a.length),c=Hp(s.shape,a,o),h=qp(i,a.length),p=Kp(c,i,a.length),d=[],f=Z_({inputs:{x:s},backend:n,attrs:{shape:u}}),m=uF({inputs:{x:f},backend:n,attrs:{perm:l}}),g=Z_({inputs:{x:m},backend:n,attrs:{shape:c}}),y=sD({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return d.push(f),d.push(m),d.push(g),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const oD={kernelName:pt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),u=n.readSync(a.dataId),l=PR(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}},uD=U_({opSnippet:"return float(a != b);",dtype:"bool"}),lD={kernelName:Ln,backendName:"webgl",kernelFunc:uD};function cD(e){const{inputs:t,backend:n}=e,{input:r}=t;return __({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const hD={kernelName:Yn,backendName:"webgl",kernelFunc:cD};const pD={kernelName:ft,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return __({inputs:{x:a},backend:r});const t=cc(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=D_({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=cD({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!xe(a.dtype,i)){const e=__({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new k_(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",me("bool",1)),t=uD({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},dD="return ceil(x);",fD=W_({opSnippet:dD,packedOpSnippet:dD,cpuKernelImpl:WR}),mD={kernelName:mt,backendName:"webgl",kernelFunc:fD};class gD{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class yD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const bD={kernelName:gt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=Ve().getBool("WEBGL_PACK_CLIP")?new yD(s.shape):new gD(s.shape);const u=o.getCustomSetupFunc(a,i);return n.runWebGLProgram(o,[s],s.dtype,u)}};class xD{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function wD(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const vD={kernelName:bt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new xD(r.shape),i=[wD(r,s.complexTensorInfos.real),wD(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class kD{constructor(e){this.outputShape=[],this.outputShape=Pp(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ID{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Pp(e,t);const n=this.outputShape,r=n.length,s=OR(r),a=m_("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<o.length;e++){const t=o[e-1];h+=`\n        if (${u} < ${o[e]}  && ${u} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${ND(i,u,t)}),\n            vec2(${ND(l,u,t)}));\n        }`}const p=o.length,d=o[o.length-1];h+=`\n        return getChannel(\n          getT${p}(${ND(i,u,d)}),\n          vec2(${ND(l,u,d)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function ND(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function SD(e){const{inputs:t,backend:n}=e,{input:r}=t;return __({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const CD={kernelName:an,backendName:"webgl",kernelFunc:SD};function ED(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>cD({inputs:{input:e},backend:n}))),s=e.map((e=>SD({inputs:{input:e},backend:n}))),a=ED(r,t,n),i=ED(s,t,n),o=D_({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}if("string"===r){const{tensors2D:s,outShape:a}=TD(e,t,n),i=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=1===s[0].shape[0],u=UR(i,a,r,o),l=Pp(e.map((e=>e.shape)),t),c=n.makeTensorInfo(l,r,u);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}if(e.length>Ve().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),s=ED(e.slice(0,r),t,n),a=ED(e.slice(r),t,n),i=ED([s,a],t,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}if(Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new ID(e.map((e=>e.shape)),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:s,outShape:a}=TD(e,t,n),i=new kD(s.map((e=>e.shape))),o=n.runWebGLProgram(i,s,r);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));const u=Z_({inputs:{x:o},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(o),u}function TD(e,t,n){const r=Pp(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Z_({inputs:{x:e},attrs:{shape:[-1,re(e.shape.slice(t))]},backend:n}))),outShape:r}}function $D(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=de(s,t[0].shape)[0],i=Pp(t.map((e=>e.shape)),a);if(0===re(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>re(e.shape)>0));if(1===o.length)return __({inputs:{x:o[0]},backend:n});return Bp(o.map((e=>e.shape)),a),ED(o,a,n)}const AD={kernelName:xt,backendName:"webgl",kernelFunc:$D};class RD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,d=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",w="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class _D{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,p=e.filterWidth,d=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${d}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${d}) *\n                  getW(wF, wR, wC, ${d}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1),\n                  getX(batch, xF, xR, xC, ${d} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2),\n                  getW(wF, wR, wC, ${d} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FD{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:a,strideHeight:i,padInfo:o,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:h}=n,{left:p,top:d}=o,f=s*r,m=rR(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let x="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)x+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${i} - ${d};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${a}. - ${p}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${m.output} = result;\n      }\n    `}}function DD({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=e.shape,l=r.texData.get(e.dataId),c=n.inChannels,h=u[0]*u[1]*u[2],p=n.outChannels,d="channelsLast"===n.dataFormat;let f;const m=[],g=(1===h||1===p)&&c>1e3,y=u[2]%2!=0&&!!l.isPacked;if(!g&&Ve().getBool("WEBGL_LAZILY_UNPACK")&&Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&y){const c=d?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),h={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},p=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Q(KA(l.shape,h.shape),(()=>`packed reshape ${l.shape} to ${h.shape} isn't free`));const g=Z_({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(g);const y=cF({a:h,b:g,backend:r,transposeA:false,transposeB:false,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),b=r.texData.get(y.dataId);Q(b.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=p,b.shape=n.outShape,f=__({inputs:{x:y},backend:r}),f.shape=n.outShape,m.push(y)}else{const l=Z_({inputs:{x:e},backend:r,attrs:{shape:[1,d?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),c=Z_({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=cF({a:l,b:c,transposeA:false,transposeB:false,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});f=Z_({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),m.push(l),m.push(c),m.push(h)}for(const e of m)r.disposeIntermediateTensorInfo(e);return f}function OD({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:p,dataFormat:d}=n,f="channelsLast"===d,m=u*l*c,g=p*h,y=[m,g],b=[],x=Z_({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),w=Z_({inputs:{x:t},backend:r,attrs:{shape:[1,m,re(t.shape)/m]}});b.push(x),b.push(w);const v=new FD(y,x.shape,n),k=r.runWebGLProgram(v,[x],"float32"),I=Z_({inputs:{x:k},backend:r,attrs:{shape:[1,y[0],y[1]]}});b.push(k),b.push(I);const N=null!=s,S=null!=a,C="leakyrelu"===o,E=o?G_(o,!0):null,T=new j_(I.shape,w.shape,[1,g,n.outChannels],!0,!1,N,E,S,C),$=[I,w];if(s&&$.push(s),S&&$.push(a),C){const e=r.makeTensorInfo([],"float32",os(i,"float32"));$.push(e),b.push(e)}const A=r.runWebGLProgram(T,$,"float32"),R=Z_({inputs:{x:A},backend:r,attrs:{shape:f?[1,p,h,n.outChannels]:[1,n.outChannels,p,h]}});b.push(A);for(const e of b)r.disposeIntermediateTensorInfo(e);return R}const MD={kernelName:wt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=Nu(u),p=mu(s.shape,a.shape,i,l,o,c,!1,h);let d;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(Ve().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])d=OD({x:s,filter:a,convInfo:p,backend:n});else{const e=new RD(p);d=n.runWebGLProgram(e,[s,a],"float32")}else d=DD({x:s,filter:a,convInfo:p,backend:n});const f=Z_({inputs:{x:d},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(d),f}};class LD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${a}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class BD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class PD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const VD={kernelName:vt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=Nu(u),p=mu(s.shape,c,i,1,o,l,!1,h),d=new LD(p);return n.runWebGLProgram(d,[s,a],"float32")}};const WD={kernelName:kt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=Nu(l),p=mu(i,a.shape,o,1,u,c,!1,h),d=new zD(p);return n.runWebGLProgram(d,[s,a],"float32")}};const UD={kernelName:It,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=gu(s.shape,a.shape,i,u,o),c=new _D(l);return n.runWebGLProgram(c,[s,a],"float32")}};const GD={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,l=gu(s.shape,u,i,1,o),c=new BD(l);return n.runWebGLProgram(c,[s,a],"float32")}};const jD={kernelName:St,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r,l=gu(u,a.shape,o,1,i),c=new PD(l);return n.runWebGLProgram(c,[s,a],"float32")}},HD=W_({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),qD={kernelName:Ct,backendName:"webgl",kernelFunc:HD},KD=W_({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),XD={kernelName:Et,backendName:"webgl",kernelFunc:KD};class YD{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const p="bilinear"===r?1:0,[d,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[b,x,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const JD={kernelName:$t,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new YD(s.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[s,a,i],"float32")}};class ZD{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${QD(r,"coords")})`,a=e[e.length-1];let i="",o="";t?(i=n?"end != "+(a-1):"end != 0",o=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${a}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${OR(r)} coords = getOutputCoords();\n        int end = ${eO(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${o};\n          ${eO(r,"coords")} = idx;\n          val += getX(${QD(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function QD(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function eO(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const tO={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,u=s.shape.length,l=Gl([a],u);let c=s;null!=l&&(c=uF({inputs:{x:s},backend:n,attrs:{perm:l}}));const h=Hl(1,u)[0];if(h!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${a}`);const p=s.shape[h];let d=__({inputs:{x:c},backend:n});for(let e=0;e<=Math.ceil(Math.log2(p))-1;e++){const t=new ZD(c.shape,!1,o),r=t.getCustomSetupFunc(e),s=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(s)}if(i){const e=new ZD(c.shape,i,o),t=d;d=n.runWebGLProgram(e,[d],d.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=uF({inputs:{x:d},backend:n,attrs:{perm:jl(l)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}};const nO={kernelName:At,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=PR(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=VR(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class rO{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const sO={kernelName:Rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Q(a>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`));const o=s.shape[0],u="NHWC"===i?s.shape[1]:s.shape[2],l="NHWC"===i?s.shape[2]:s.shape[3],c="NHWC"===i?s.shape[3]:s.shape[1],h=u*a,p=l*a,d=c/(a*a),f=new rO("NHWC"===i?[o,h,p,d]:[o,d,h,p],a,i);return n.runWebGLProgram(f,[s],s.dtype)}};class aO{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.inHeight,i=e.inWidth,o=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",y="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${a}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class iO{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const a=e.inHeight,i=e.inWidth,o=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let e=0;e<d;e++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<d;e++)for(let t=0;t<m;t++){const n=2*t;if(g+=`\n          xR = xRCorner + ${e*h};\n          xC = xCCorner + ${n*p};\n        `,1===c){if(n<f&&(g+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${i}) {\n                    xTexelR${e}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${i}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${i}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${n} = vec4(previous.zw, xTexelR${e}C${n}.xy);\n                } else {\n                  xR${e}C${n} = vec4(0, 0, xTexelR${e}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${a} && xC >= 0 && xC < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xR${e}C${n} = xTexelR${e}C${n};\n              `,n+1<f)){const t=u%2==0?X(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(g+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${i}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,p>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${a} &&\n                      xCOffset >= 0 && xCOffset < ${i}) {\n                      xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${n} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${i}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${n+1} = xTexelR${e}C${n+2};\n                `}}else n<f&&(g+=`\n              if(xR >= 0 && xR < ${a}) {\n            `,u%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${i}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n              `,n+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${i}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${n+1} = vec4(xTexelR${e}C${n+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.xy, xTexelR${e}C${n+2}.xy);\n              `,n+1<f&&(g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n                `)),g+="}");n<f&&(g+=`\n            vec4 wTexelR${e}C${n} = getW(${e}, ${n}, d1, q);\n            wR${e}C${n} = vec4(wTexelR${e}C${n}.xz, wTexelR${e}C${n}.xz);\n          `,n+1<f&&(g+=`\n              vec4 wTexelR${e}C${n+1} = getW(${e}, ${n+1}, d1, q);\n              wR${e}C${n+1} =\n                vec4(wTexelR${e}C${n+1}.xz, wTexelR${e}C${n+1}.xz);`))}for(let e=0;e<d;e++)for(let t=0;t<f;t++)g+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let y="",b="";n&&(y=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,b="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${x}\n        ${b}\n        setOutput(result);\n      }\n    `}}const oO={kernelName:_t,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),Q(Iu(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=mu(s.shape,a.shape,i,c,o,l,!0);let p;return p=Ve().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new iO(h):new aO(h),n.runWebGLProgram(p,[s,a],"float32")}};class uO{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lO{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cO={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r,h=mu(s.shape,c,i,o,u,l,!0),p=new uO(h);return n.runWebGLProgram(p,[s,a],"float32")}};const hO={kernelName:Dt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r,h=mu(c,a.shape,i,o,u,l,!0),p=new lO(h);return n.runWebGLProgram(p,[s,a],"float32")}};class pO{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const dO={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=re(r.shape),i=Z_({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new pO(a),u=n.runWebGLProgram(o,[i],i.dtype),l=Z_({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class fO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const mO={kernelName:Mt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=pu(s.shape,a.shape,i,o,"NHWC",u);let c;const h=new fO(l);c=n.runWebGLProgram(h,[s,a],"float32");const p=Z_({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}},gO=W_({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),yO={kernelName:Pt,backendName:"webgl",kernelFunc:gO},bO={kernelName:Vt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=Ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new R_("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new A_("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},xO=U_({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),wO={kernelName:Ut,backendName:"webgl",kernelFunc:xO},vO=W_({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Jp};\n  float a1 = ${Zp};\n  float a2 = ${Qp};\n  float a3 = ${ed};\n  float a4 = ${td};\n  float a5 = ${nd};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),kO={kernelName:Wt,backendName:"webgl",kernelFunc:vO},IO="return exp(x);",NO=W_({opSnippet:IO,packedOpSnippet:IO,cpuKernelImpl:GR}),SO={kernelName:Gt,backendName:"webgl",kernelFunc:NO};function CO(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=s;return s<0&&(Q(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+s+1),o.splice(u,0,1),Z_({inputs:{x:a},backend:r,attrs:{shape:o}})}const EO={kernelName:jt,backendName:"webgl",kernelFunc:CO},TO="return exp(x) - 1.0;",$O=W_({opSnippet:TO,packedOpSnippet:TO,cpuKernelImpl:jR}),AO={kernelName:Ht,backendName:"webgl",kernelFunc:$O};class RO{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function _O(e,t,n){const r=n.texData.get(e.dataId),s=re(e.shape),a=e.shape[e.shape.length-1],i=Z_({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,u=new RO("real",o,t),l=new RO("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(u,c,"float32"),p=n.runWebGLProgram(l,c,"float32"),d=D_({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const f=Z_({inputs:{x:d},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(d),f}const FO={kernelName:qt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return _O(r,!1,n)}};class DO{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function OO(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Ce(s),"string"===a){const e=ge(a,re(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new DO(r,s),n=e.getCustomSetupFunc(s);return t.runWebGLProgram(e,[],a,n)}}const MO={kernelName:Kt,backendName:"webgl",kernelFunc:OO};class LO{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const zO={kernelName:Xt,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new LO(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},BO="return floor(x);",PO=W_({opSnippet:BO,packedOpSnippet:BO,cpuKernelImpl:HR}),VO={kernelName:Yt,backendName:"webgl",kernelFunc:PO},WO=U_({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),UO={kernelName:Jt,backendName:"webgl",kernelFunc:WO};class GO{constructor(e){this.variableNames=["A"];const t=rR(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class jO{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=rR(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const HO={kernelName:Lr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,u="undefined"!=typeof ImageBitmap&&s instanceof ImageBitmap,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],h=[c,l],p=[c,l,a];(o||i||u)&&(null==qO&&(qO=document.createElement("canvas").getContext("2d")),qO.canvas.width=l,qO.canvas.height=c,qO.drawImage(s,0,0,l,c),s=qO.canvas);const d=n.makeTensorInfo(h,"int32");n.texData.get(d.dataId).usage=SA.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const f=Ve().getBool("WEBGL_PACK")?new jO(p):new GO(p),m=n.runWebGLProgram(f,[d],"int32");return n.disposeData(d.dataId),m}};let qO;const KO={kernelName:Pr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,m=Nu(c),g=mu(s.shape,a.shape,u,h,l,p,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Ve().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=OD({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:o,leakyreluAlpha:f});else{const e=null!=i,t=null!=o,r="leakyrelu"===d,u=d?G_(d,!1):null,l=new RD(g,e,u,t,r),c=[s,a];if(i&&c.push(i),o&&c.push(o),r){const e=n.makeTensorInfo([],"float32",os(f,"float32"));c.push(e),b.push(e)}y=n.runWebGLProgram(l,c,"float32")}else y=DD({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:o,leakyreluAlpha:f});const x=Z_({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}};const XO={kernelName:Vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=r,f=[];let m=c;null==m&&(m=[1,1]),Q(Iu(u,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`));const g=mu(s.shape,a.shape,u,m,l,h,!0),y=Ve().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=p?G_(p,y):null,x=[s,a],w=null!=i,v=null!=o,k="leakyrelu"===p;if(w&&x.push(i),v&&x.push(o),k){const e=n.makeTensorInfo([],"float32",os(d,"float32"));x.push(e),f.push(e)}let I;I=y?new iO(g,w,b,v,k):new aO(g,w,b,v,k);const N=n.runWebGLProgram(I,x,"float32");return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class YO{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=OR(t.length),s=OR(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${a};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const JO={kernelName:en,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],[o,u,l,c]=wi(r,s),h=Z_({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=Z_({inputs:{x:r},backend:n,attrs:{shape:[re(r.shape)/l,l]}}),d=new YO(i,c,[u,l]),f=n.runWebGLProgram(d,[p,h],p.dtype),m=Z_({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};class ZO{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=OR(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const QO={kernelName:Qt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=gd(s,a,de(i,s.shape)[0],o),l=re(a.shape),c=[],h=Z_({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Z_({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(h),c.push(p);const d=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=qR(t,e,d);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const f=new ZO(h.shape,d),m=n.runWebGLProgram(f,[h,p],h.dtype);c.push(m);const g=Z_({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},eM=U_({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:KR,dtype:"bool"}),tM={kernelName:tn,backendName:"webgl",kernelFunc:eM},nM=U_({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),rM={kernelName:nn,backendName:"webgl",kernelFunc:nM};const sM={kernelName:sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return _O(r,!0,n)}},aM=W_({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),iM={kernelName:on,backendName:"webgl",kernelFunc:aM},oM=W_({opSnippet:"return float(isinf(x));",dtype:"bool"}),uM={kernelName:un,backendName:"webgl",kernelFunc:oM},lM=W_({opSnippet:"return float(isnan(x));",dtype:"bool"}),cM={kernelName:ln,backendName:"webgl",kernelFunc:lM},hM=U_({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:XR,dtype:"bool"}),pM={kernelName:hn,backendName:"webgl",kernelFunc:hM},dM=U_({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),fM={kernelName:pn,backendName:"webgl",kernelFunc:dM};const mM={kernelName:dn,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=YR(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},gM=W_({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:JR}),yM={kernelName:fn,backendName:"webgl",kernelFunc:gM},bM=W_({opSnippet:"return log(1.0 + x);"}),xM={kernelName:mn,backendName:"webgl",kernelFunc:bM},wM=U_({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),vM={kernelName:gn,backendName:"webgl",kernelFunc:wM},kM=W_({opSnippet:"return float(!(x >= 1.0));"}),IM={kernelName:yn,backendName:"webgl",kernelFunc:kM},NM=U_({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),SM={kernelName:bn,backendName:"webgl",kernelFunc:NM};class CM{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class EM{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const TM={kernelName:wn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r,l=Ve().getBool("WEBGL_PACK_NORMALIZATION")?new EM(s.shape,a,i,o,u):new CM(s.shape,a,i,o,u);return n.runWebGLProgram(l,[s],s.dtype)}};class $M{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const AM={kernelName:vn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,h=new $M(s.shape,o,u,l,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function RM(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,u=de(a,s.shape);let l=u;const c=Gl(l,o),h=null!=c,p=n.shouldExecuteOnCPU([s]);let d=s;if(h){if(p){const e=n.texData.get(d.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=s.shape[c[e]];const r=p_(e,s.shape,s.dtype,c,t);d=n.makeTensorInfo(t,s.dtype);n.texData.get(d.dataId).values=r}else d=aF(s,c,n);l=Hl(l.length,o)}Ul("max",l,o);const[f,m]=Vl(d.shape,l);let g,y=f;if(i&&(y=Wl(f,u)),p){const e=n.texData.get(d.dataId).values,t=ZR(e,re(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=re(t),a=Z_({inputs:{x:e},attrs:{shape:[re(e.shape)/s,s]},backend:r}),i=nF(a,e.dtype,"max",r),o=Z_({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(d,m,y,n);return h&&n.disposeIntermediateTensorInfo(d),g}const _M={kernelName:kn,backendName:"webgl",kernelFunc:RM},FM=U_({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:QR}),DM={kernelName:In,backendName:"webgl",kernelFunc:FM};const OM={kernelName:Nn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tR(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;Q(Iu(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=du(s.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&ae(l.inShape,l.outShape))return __({inputs:{x:s},backend:n});const c=new UF(l,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};const MM={kernelName:Cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=r,c=fu(s.shape,a,i,[1,1,1],o,l,u),h=new GF(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class LM{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,u=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zM{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=u-1-e.padInfo.top,p=l-1-e.padInfo.left,d=o*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const BM={kernelName:En,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=fu(i.shape,o,u,[1,1,1],l,c),p=new GF(h,"max",!0),d=n.runWebGLProgram(p,[i],i.dtype),f=new zM(h),m=n.runWebGLProgram(f,[s,d],i.dtype);return n.disposeIntermediateTensorInfo(d),m}};const PM={kernelName:Sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;tR([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,p=du(o.shape,u,l,1,c,h),d=new UF(p,"max",!0),f=n.runWebGLProgram(d,[o],o.dtype),m=new LM(p),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const VM={kernelName:Tn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;Q(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const l=[1,1];Q(Iu(a,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));const c=du(r.shape,s,a,l,i),[h,p]=function(e,t,n,r){let s=new UF(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new UF(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,u);return[h,p]}};const WM={kernelName:$n,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,u=de(a,r.shape);let l=u;const c=Gl(l,o),h=null!=c,p=i.shouldExecuteOnCPU([r]),d=[];let f=r;if(h){if(p){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=p_(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype);i.texData.get(f.dataId).values=n}else f=aF(r,c,i);d.push(f),l=Hl(l.length,o)}Ul("sum",l,o);const[m,g]=Vl(f.shape,l);let y=m;s&&(y=Wl(m,u));const b=function(e,t,n,r){const s=re(t),a=Z_({inputs:{x:e},attrs:{shape:[re(e.shape)/s,s]},backend:r}),i=nF(a,"float32","mean",r),o=Z_({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,g,y,i);for(const e of d)i.disposeIntermediateTensorInfo(e);return b}};const UM={kernelName:An,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=de(a,s.shape);let l=u;const c=Gl(l,o);let h=s;null!=c&&(h=uF({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Hl(l.length,s.shape.length)),Ul("min",l,o);const[p,d]=Vl(h.shape,l),f=Z_({inputs:{x:h},backend:n,attrs:{shape:[-1,re(d)]}}),m=nF(f,f.dtype,"min",n);let g;if(i){g=Z_({inputs:{x:m},backend:n,attrs:{shape:Wl(p,u)}})}else g=Z_({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},GM=U_({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:e_}),jM={kernelName:Rn,backendName:"webgl",kernelFunc:GM};class HM{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=OR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class qM{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=OR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=m_("rc",r),u=m_("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let p="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const KM={kernelName:_n,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qM(r.shape,s,a):new HM(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},XM=U_({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),YM={kernelName:Fn,backendName:"webgl",kernelFunc:XM};class JM{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const ZM=U_({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),QM={kernelName:Bt,backendName:"webgl",kernelFunc:ZM},eL="return a - b;",tL=U_({opSnippet:eL,packedOpSnippet:eL,supportsComplex:!0,cpuKernelImpl:l_}),nL={kernelName:Nr,backendName:"webgl",kernelFunc:tL};function rL(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=de([a],s.shape),o=RM({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=Wl(o.shape,i),l=Z_({inputs:{x:o},backend:n,attrs:{shape:u}}),c=tL({inputs:{a:s,b:l},backend:n}),h=NO({inputs:{x:c},backend:n}),p=iF({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),d=Z_({inputs:{x:p},backend:n,attrs:{shape:u}}),f=ZM({inputs:{a:h,b:d},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),f}const sL={kernelName:vr,backendName:"webgl",kernelFunc:rL};const aL={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:rL({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new JM(l,c,a),p=h.getCustomSetupFunc(i),d=n.runWebGLProgram(h,[u],"int32",p);return o||n.disposeIntermediateTensorInfo(u),d}},iL="return -x;";const oL={kernelName:Mn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=n_(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=Ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new S_(r.shape,iL):new k_(r.shape,iL),n.runWebGLProgram(s,[r],r.dtype)}},uL=np;const lL={kernelName:zn,backendName:"webgl",kernelFunc:function(e){rd("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=uL(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},cL=rp;const hL={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){rd("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:p,validOutputs:d}=cL(c,h,i,o,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([d]))]}},pL=sp;const dL={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){rd("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),p=i,d=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=pL(c,h,p,d,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class fL{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const mL={kernelName:Wn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:i,offValue:o}=r,u=re(s.shape),l=new fL(u,a,i,o),c=Z_({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(l,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const p=Z_({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,a]}});return n.disposeIntermediateTensorInfo(h),p}};function gL(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=cD({inputs:{input:r},backend:n}),t=gL({inputs:{x:e},backend:n}),s=SD({inputs:{input:r},backend:n}),a=gL({inputs:{x:s},backend:n}),i=D_({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return OO({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const yL={kernelName:Or,backendName:"webgl",kernelFunc:gL};const bL={kernelName:Vn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=cD({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=SD({inputs:{input:s},backend:r}),i=gL({inputs:{x:a},backend:r}),o=D_({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return OO({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const xL={kernelName:Un,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return CO({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{ee(a,e.shape,"All tensors passed to stack must have matching shapes"),Q(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],u=$D({inputs:t.map((e=>{const t=CO({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class wL{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=OR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class vL{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=OR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=m_("rc",r),u=m_("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${l}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let d="";for(let e=0,t=1===r?2:4;e<t;e++)d+=`\n        ${h[e]}\n        if (${p}) {\n          result[${e}] = float(${n});\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;d+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const kL=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r,o=Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vL(s.shape,a,i):new wL(s.shape,a,i);return n.runWebGLProgram(o,[s],s.dtype)},IL={kernelName:Gn,backendName:"webgl",kernelFunc:kL},NL=U_({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),SL={kernelName:Hn,backendName:"webgl",kernelFunc:NL};const CL={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=[],l=de(a,s.shape);let c=l;const h=Gl(c,o);let p,d=s;if(null!=h&&(d=uF({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Hl(c.length,o),u.push(d)),Ul("prod",c,o),n.shouldExecuteOnCPU([d])){const e=n.texData.get(d.dataId).values,{outVals:t,outShape:r,outDtype:s}=r_(d.shape,d.dtype,e,c);p=n.makeTensorInfo(r,s,t)}else{const[e,t]=Vl(d.shape,c),r=re(t),a=Z_({inputs:{x:d},backend:n,attrs:{shape:[-1,r]}}),i=nF(a,Es(s.dtype),"prod",n);p=Z_({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(a),u.push(i)}if(i){u.push(p);const e=Wl(p.shape,l);p=Z_({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},EL=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=s_(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},TL={kernelName:Xn,backendName:"webgl",kernelFunc:EL},$L=W_({opSnippet:"return 1.0 / x;"}),AL={kernelName:Jn,backendName:"webgl",kernelFunc:$L},RL=W_({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_L={kernelName:Zn,backendName:"webgl",kernelFunc:RL},FL=W_({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),DL={kernelName:sr,backendName:"webgl",kernelFunc:FL};class OL{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class ML{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const LL={kernelName:nr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=Ve().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ML(s.shape,u,l,a,i):new OL(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],"float32")}};class zL{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,p=1/c,d=2*Math.ceil(h)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const BL={kernelName:rr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new zL(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class PL{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let p;p=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const VL={kernelName:er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=new PL(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class WL{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,p=1/c,d=2*Math.ceil(h)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const UL={kernelName:tr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new WL(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class GL{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=OR(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class jL{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=m_("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=OR(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const HL={kernelName:ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=de(a,s.shape);if(0===i)return __({inputs:{x:s},backend:n});const u=Ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jL(s.shape,o):new GL(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}};class qL{constructor(e,t,n,r){this.variableNames=["Image"],this.outputShape=[];const s=e[1],a=e[2],i=Math.sin(t).toFixed(3),o=Math.cos(t).toFixed(3);this.outputShape=e;const[u,l]=Up(r,s,a),c=u.toFixed(3),h=l.toFixed(3);let p="";p="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${c}) * ${o} - (float(y) - ${h}) * ${i};\n          float coordYFloat = (float(x) - ${c}) * ${i} + (float(y) - ${h}) * ${o};\n          int coordX = int(round(coordXFloat + ${c}));\n          int coordY = int(round(coordYFloat + ${h}));\n          ${p}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const KL={kernelName:zr,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=new qL(r.shape,s,a,i);return o.runWebGLProgram(u,[r],r.dtype)}},XL=W_({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),YL={kernelName:ir,backendName:"webgl",kernelFunc:XL},JL=W_({opSnippet:"return inversesqrt(x);",cpuKernelImpl:a_}),ZL={kernelName:or,backendName:"webgl",kernelFunc:JL};class QL{constructor(e,t,n,r,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=OR(s.length),u=OR(a.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`,d=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${d};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const ez={kernelName:ur,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ii(0,s,i),p=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const d=Z_({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=Z_({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new QL(u,o,d.shape.length,f.shape.length,c,p),y=n.runWebGLProgram(g,[f,d,m],f.dtype),b=Z_({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class tz{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=OR(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const nz={kernelName:lr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new tz(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Cs(s.dtype,a.dtype))}},rz=W_({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Xp};\n  float scale = ${Yp};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),sz={kernelName:cr,backendName:"webgl",kernelFunc:rz},az=W_({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),iz={kernelName:mr,backendName:"webgl",kernelFunc:az},oz=W_({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),uz={kernelName:fr,backendName:"webgl",kernelFunc:oz},lz=W_({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),cz={kernelName:pr,backendName:"webgl",kernelFunc:lz},hz=W_({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),pz={kernelName:dr,backendName:"webgl",kernelFunc:hz},dz=W_({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),fz={kernelName:gr,backendName:"webgl",kernelFunc:dz},mz={kernelName:xr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Q(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...i);for(let e=1+a.length;e<s.shape.length;++e)u.push([0,0]);const l=[],c=kL({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=Gp(c.shape,a,o,!1),p=jp(h.length,a.length,!1),d=Hp(c.shape,a,o,!1),f=Z_({inputs:{x:c},backend:n,attrs:{shape:h}}),m=uF({inputs:{x:f},backend:n,attrs:{perm:p}}),g=Z_({inputs:{x:m},backend:n,attrs:{shape:d}});return l.push(c),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const gz={kernelName:Sr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:h}=Ii(0,s,o),p=new QL(l,u,s.shape.length,a.shape.length,c,[h,1],!1),d=n.runWebGLProgram(p,[a,s,i],a.dtype),f=Z_({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(d),f}};const yz={kernelName:wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=de(i,s.shape)[0],u=dd(s,a,o),l=s.shape.length,c=new Array(l).fill(0),h=s.shape.slice();return u.map((e=>{const t=[...h];t[o]=e;const r=sD({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},bz=W_({opSnippet:"return sqrt(x);"}),xz={kernelName:yr,backendName:"webgl",kernelFunc:bz},wz=W_({opSnippet:"return x * x;"}),vz={kernelName:Ir,backendName:"webgl",kernelFunc:wz},kz="return (a - b) * (a - b);",Iz=U_({opSnippet:kz,packedOpSnippet:kz}),Nz={kernelName:kr,backendName:"webgl",kernelFunc:Iz};const Sz={kernelName:Mr,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new k_(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class Cz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=OR(n.length),a=OR(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const Ez={kernelName:Cr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=r,{nonStrided:d,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Bi(s.shape,a,i,o,u,l,c,h,p),x=Z_({inputs:{x:s},backend:n,attrs:{shape:y}});let w;if(d){const e=sD({inputs:{x:x},backend:n,attrs:{begin:f,size:g}});w=Z_({inputs:{x:e},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(e)}else if(b.some((e=>0===e)))w=n.makeTensorInfo(b,s.dtype,[]);else{if(n.shouldExecuteOnCPU([x])){const e=n.texData.get(x.dataId).values,t=ja(x.shape,x.dtype,e),r=u_(b,t,m,f);w=n.makeTensorInfo(b,x.dtype,r.values)}else{const e=new Cz(f,m,b);w=n.runWebGLProgram(e,[x],x.dtype)}}const v=Z_({inputs:{x:w},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),v}},Tz=W_({opSnippet:"return tan(x);"}),$z={kernelName:Er,backendName:"webgl",kernelFunc:Tz},Az=W_({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Rz={kernelName:Tr,backendName:"webgl",kernelFunc:Az};class _z{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=OR(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function Fz(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype){const e=n.readSync(s.dataId).map((e=>ps(e))),t=ja(s.shape,s.dtype,e),r=c_(t,a);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const i=new _z(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const Dz={kernelName:$r,backendName:"webgl",kernelFunc:Fz};const Oz={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=n.readSync(s.dataId),[u,l]=h_(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const Mz={kernelName:_r,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;tR(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=d_(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}};const Lz={kernelName:Fr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],l=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(l[c++]=i.shape[e]);const h=[],p=new Array(o).fill(0),d=i.shape.slice();d[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[a]=e;const t=sD({inputs:{x:i},backend:n,attrs:{begin:p,size:d}}),r=Z_({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,h.push(t)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class zz{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Bz=[TM,AM,hF,dF,mF,yF,wF,IF,NF,SF,RF,_F,DF,MF,PF,zF,WF,HF,jF,XF,YF,JF,eD,iD,oD,pD,mD,bD,vD,O_,AD,VD,WD,MD,GD,jD,UD,qD,XD,JD,tO,nO,sO,cO,hO,oO,dO,mO,yO,bO,wO,kO,SO,EO,AO,FO,MO,zO,VO,UO,HO,KO,XO,JO,QO,tM,rM,F_,sM,CD,iM,uM,cM,z_,pM,fM,mM,xM,yM,vM,IM,SM,_M,MM,OM,BM,PM,VM,DM,WM,UM,jM,KM,YM,aL,J_,oL,lL,hL,dL,lD,mL,bL,xL,IL,SL,V_,CL,TL,hD,QM,AL,DL,_L,Q_,LL,BL,VL,UL,HL,KL,YL,ZL,ez,nz,sz,iz,uz,cz,pz,aD,sL,fz,mz,gz,yz,xz,vz,Nz,Sz,Ez,nL,oF,$z,Rz,Dz,Oz,lF,Mz,Lz,{kernelName:Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[];let l=0;const c=Gl([l],o);let h=s;null!=c&&(h=uF({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=Hl(1,o)[0]);const p=md(h.shape,l,i),d=re([h.shape[l]]),f=Z_({inputs:{x:h},backend:n,attrs:{shape:[-1,d]}});u.push(f);const m=Es(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],l=fd(o,a),c=new zz({windowSize:l,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(u.push(h),h.shape[1]===a)return h;const p=EL({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),d=Fz({inputs:{x:p},backend:n,attrs:{reps:[o/l]}});u.push(p),u.push(d);return g(h,t,d,s,a)},y=Z_({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:p}});let b=y;if(null!=c){u.push(y);const e=jl(c);b=uF({inputs:{x:b},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},yL];for(const e of Bz)qr(e);const Pz={"tfjs-core":eo,"tfjs-backend-cpu":"3.0.0","tfjs-backend-webgl":"3.0.0","tfjs-data":jN,"tfjs-layers":Yy,"tfjs-converter":OI,tfjs:"3.0.0"}},448:function(e,t,n){let r,s=n(45),a=window.AudioContext||window.webkitAudioContext,i=e=>{let t=new Event("error");return t.data=new Error("Wrong state for "+e),t};class o{constructor(e,t=null){this.stream=e,this.config=t,this.state="inactive",this.em=document.createDocumentFragment(),this.encoder=(e=>{let t=e.toString().replace(/^(\(\)\s*=>|function\s*\(\))\s*{/,"").replace(/}$/,""),n=new Blob([t]);return new Worker(URL.createObjectURL(n))})(o.encoder);let n=this;this.encoder.addEventListener("message",(e=>{let t=new Event("dataavailable");t.data=new Blob([e.data],{type:n.mimeType}),n.em.dispatchEvent(t),"inactive"===n.state&&n.em.dispatchEvent(new Event("stop"))}))}start(e){if("inactive"!==this.state)return this.em.dispatchEvent(i("start"));this.state="recording",r||(r=new a(this.config)),this.clone=this.stream.clone(),this.input=r.createMediaStreamSource(this.clone),this.processor=r.createScriptProcessor(2048,1,1),this.encoder.postMessage(["init",r.sampleRate]),this.processor.onaudioprocess=e=>{"recording"===this.state&&this.encoder.postMessage(["encode",e.inputBuffer.getChannelData(0)])},this.input.connect(this.processor),this.processor.connect(r.destination),this.em.dispatchEvent(new Event("start")),e&&(this.slicing=setInterval((()=>{"recording"===this.state&&this.requestData()}),e))}stop(){return"inactive"===this.state?this.em.dispatchEvent(i("stop")):(this.requestData(),this.state="inactive",this.clone.getTracks().forEach((e=>{e.stop()})),this.processor.disconnect(),this.input.disconnect(),clearInterval(this.slicing))}pause(){return"recording"!==this.state?this.em.dispatchEvent(i("pause")):(this.state="paused",this.em.dispatchEvent(new Event("pause")))}resume(){return"paused"!==this.state?this.em.dispatchEvent(i("resume")):(this.state="recording",this.em.dispatchEvent(new Event("resume")))}requestData(){return"inactive"===this.state?this.em.dispatchEvent(i("requestData")):this.encoder.postMessage(["dump",r.sampleRate])}addEventListener(...e){this.em.addEventListener(...e)}removeEventListener(...e){this.em.removeEventListener(...e)}dispatchEvent(...e){this.em.dispatchEvent(...e)}}o.prototype.mimeType="audio/wav",o.isTypeSupported=e=>o.prototype.mimeType===e,o.notSupported=!navigator.mediaDevices||!a,o.encoder=s,e.exports=o},45:function(e){e.exports=()=>{let e=[];onmessage=t=>{"encode"===t.data[0]?function(t){let n=t.length,r=new Uint8Array(2*n);for(let e=0;e<n;e++){let n=2*e,s=t[e];s>1?s=1:s<-1&&(s=-1),s*=32768,r[n]=s,r[n+1]=s>>8}e.push(r)}(t.data[1]):"dump"===t.data[0]&&function(t){let n=e.length?e[0].length:0,r=e.length*n,s=new Uint8Array(44+r),a=new DataView(s.buffer);a.setUint32(0,1380533830,!1),a.setUint32(4,36+r,!0),a.setUint32(8,1463899717,!1),a.setUint32(12,1718449184,!1),a.setUint32(16,16,!0),a.setUint16(20,1,!0),a.setUint16(22,1,!0),a.setUint32(24,t,!0),a.setUint32(28,2*t,!0),a.setUint16(32,2,!0),a.setUint16(34,16,!0),a.setUint32(36,1684108385,!1),a.setUint32(40,r,!0);for(let t=0;t<e.length;t++)s.set(e[t],t*n+44);e=[],postMessage(s.buffer,[s.buffer])}(t.data[1])}}},742:function(e,t){"use strict";t.byteLength=function(e){var t=u(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,n,a=u(e),i=a[0],o=a[1],l=new s(function(e,t,n){return 3*(t+n)/4-n}(0,i,o)),c=0,h=o>0?i-4:i;for(n=0;n<h;n+=4)t=r[e.charCodeAt(n)]<<18|r[e.charCodeAt(n+1)]<<12|r[e.charCodeAt(n+2)]<<6|r[e.charCodeAt(n+3)],l[c++]=t>>16&255,l[c++]=t>>8&255,l[c++]=255&t;2===o&&(t=r[e.charCodeAt(n)]<<2|r[e.charCodeAt(n+1)]>>4,l[c++]=255&t);1===o&&(t=r[e.charCodeAt(n)]<<10|r[e.charCodeAt(n+1)]<<4|r[e.charCodeAt(n+2)]>>2,l[c++]=t>>8&255,l[c++]=255&t);return l},t.fromByteArray=function(e){for(var t,r=e.length,s=r%3,a=[],i=16383,o=0,u=r-s;o<u;o+=i)a.push(l(e,o,o+i>u?u:o+i));1===s?(t=e[r-1],a.push(n[t>>2]+n[t<<4&63]+"==")):2===s&&(t=(e[r-2]<<8)+e[r-1],a.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return a.join("")};for(var n=[],r=[],s="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=a.length;i<o;++i)n[i]=a[i],r[a.charCodeAt(i)]=i;function u(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e,t,r){for(var s,a,i=[],o=t;o<r;o+=3)s=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(n[(a=s)>>18&63]+n[a>>12&63]+n[a>>6&63]+n[63&a]);return i.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},746:function(e,t){"use strict";function n(e){var t=32;return(e&=-e)&&t--,65535&e&&(t-=16),16711935&e&&(t-=8),252645135&e&&(t-=4),858993459&e&&(t-=2),1431655765&e&&(t-=1),t}t.INT_BITS=32,t.INT_MAX=2147483647,t.INT_MIN=-1<<31,t.sign=function(e){return(e>0)-(e<0)},t.abs=function(e){var t=e>>31;return(e^t)-t},t.min=function(e,t){return t^(e^t)&-(e<t)},t.max=function(e,t){return e^(e^t)&-(e<t)},t.isPow2=function(e){return!(e&e-1||!e)},t.log2=function(e){var t,n;return t=(e>65535)<<4,t|=n=((e>>>=t)>255)<<3,t|=n=((e>>>=n)>15)<<2,(t|=n=((e>>>=n)>3)<<1)|(e>>>=n)>>1},t.log10=function(e){return e>=1e9?9:e>=1e8?8:e>=1e7?7:e>=1e6?6:e>=1e5?5:e>=1e4?4:e>=1e3?3:e>=100?2:e>=10?1:0},t.popCount=function(e){return 16843009*((e=(858993459&(e-=e>>>1&1431655765))+(e>>>2&858993459))+(e>>>4)&252645135)>>>24},t.countTrailingZeros=n,t.nextPow2=function(e){return e+=0===e,--e,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,(e|=e>>>16)+1},t.prevPow2=function(e){return e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,(e|=e>>>16)-(e>>>1)},t.parity=function(e){return e^=e>>>16,e^=e>>>8,e^=e>>>4,27030>>>(e&=15)&1};var r=new Array(256);!function(e){for(var t=0;t<256;++t){var n=t,r=t,s=7;for(n>>>=1;n;n>>>=1)r<<=1,r|=1&n,--s;e[t]=r<<s&255}}(r),t.reverse=function(e){return r[255&e]<<24|r[e>>>8&255]<<16|r[e>>>16&255]<<8|r[e>>>24&255]},t.interleave2=function(e,t){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e&=65535)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t&=65535)|t<<8))|t<<4))|t<<2))|t<<1))<<1},t.deinterleave2=function(e,t){return(e=65535&((e=16711935&((e=252645135&((e=858993459&((e=e>>>t&1431655765)|e>>>1))|e>>>2))|e>>>4))|e>>>16))<<16>>16},t.interleave3=function(e,t,n){return e=1227133513&((e=3272356035&((e=251719695&((e=4278190335&((e&=1023)|e<<16))|e<<8))|e<<4))|e<<2),(e|=(t=1227133513&((t=3272356035&((t=251719695&((t=4278190335&((t&=1023)|t<<16))|t<<8))|t<<4))|t<<2))<<1)|(n=1227133513&((n=3272356035&((n=251719695&((n=4278190335&((n&=1023)|n<<16))|n<<8))|n<<4))|n<<2))<<2},t.deinterleave3=function(e,t){return(e=1023&((e=4278190335&((e=251719695&((e=3272356035&((e=e>>>t&1227133513)|e>>>2))|e>>>4))|e>>>8))|e>>>16))<<22>>22},t.nextCombination=function(e){var t=e|e-1;return t+1|(~t&-~t)-1>>>n(e)+1}},764:function(e,t,n){"use strict";const r=n(742),s=n(645),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.lW=u,t.h2=50;const i=2147483647;function o(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,u.prototype),t}function u(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return h(e)}return l(e,t,n)}function l(e,t,n){if("string"==typeof e)return function(e,t){"string"==typeof t&&""!==t||(t="utf8");if(!u.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|m(e,t);let r=o(n);const s=r.write(e,t);s!==n&&(r=r.slice(0,s));return r}(e,t);if(ArrayBuffer.isView(e))return function(e){if(X(e,Uint8Array)){const t=new Uint8Array(e);return d(t.buffer,t.byteOffset,t.byteLength)}return p(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(X(e,ArrayBuffer)||e&&X(e.buffer,ArrayBuffer))return d(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(X(e,SharedArrayBuffer)||e&&X(e.buffer,SharedArrayBuffer)))return d(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const r=e.valueOf&&e.valueOf();if(null!=r&&r!==e)return u.from(r,t,n);const s=function(e){if(u.isBuffer(e)){const t=0|f(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}if(void 0!==e.length)return"number"!=typeof e.length||Y(e.length)?o(0):p(e);if("Buffer"===e.type&&Array.isArray(e.data))return p(e.data)}(e);if(s)return s;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return u.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function h(e){return c(e),o(e<0?0:0|f(e))}function p(e){const t=e.length<0?0:0|f(e.length),n=o(t);for(let r=0;r<t;r+=1)n[r]=255&e[r];return n}function d(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let r;return r=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(r,u.prototype),r}function f(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function m(e,t){if(u.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||X(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,r=arguments.length>2&&!0===arguments[2];if(!r&&0===n)return 0;let s=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return H(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return q(e).length;default:if(s)return r?-1:H(e).length;t=(""+t).toLowerCase(),s=!0}}function g(e,t,n){let r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return A(this,t,n);case"utf8":case"utf-8":return C(this,t,n);case"ascii":return T(this,t,n);case"latin1":case"binary":return $(this,t,n);case"base64":return S(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return R(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function y(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function b(e,t,n,r,s){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),Y(n=+n)&&(n=s?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(s)return-1;n=e.length-1}else if(n<0){if(!s)return-1;n=0}if("string"==typeof t&&(t=u.from(t,r)),u.isBuffer(t))return 0===t.length?-1:x(e,t,n,r,s);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):x(e,[t],n,r,s);throw new TypeError("val must be string, number or Buffer")}function x(e,t,n,r,s){let a,i=1,o=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;i=2,o/=2,u/=2,n/=2}function l(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(s){let r=-1;for(a=n;a<o;a++)if(l(e,a)===l(t,-1===r?0:a-r)){if(-1===r&&(r=a),a-r+1===u)return r*i}else-1!==r&&(a-=a-r),r=-1}else for(n+u>o&&(n=o-u),a=n;a>=0;a--){let n=!0;for(let r=0;r<u;r++)if(l(e,a+r)!==l(t,r)){n=!1;break}if(n)return a}return-1}function w(e,t,n,r){n=Number(n)||0;const s=e.length-n;r?(r=Number(r))>s&&(r=s):r=s;const a=t.length;let i;for(r>a/2&&(r=a/2),i=0;i<r;++i){const r=parseInt(t.substr(2*i,2),16);if(Y(r))return i;e[n+i]=r}return i}function v(e,t,n,r){return K(H(t,e.length-n),e,n,r)}function k(e,t,n,r){return K(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function I(e,t,n,r){return K(q(t),e,n,r)}function N(e,t,n,r){return K(function(e,t){let n,r,s;const a=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),r=n>>8,s=n%256,a.push(s),a.push(r);return a}(t,e.length-n),e,n,r)}function S(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function C(e,t,n){n=Math.min(e.length,n);const r=[];let s=t;for(;s<n;){const t=e[s];let a=null,i=t>239?4:t>223?3:t>191?2:1;if(s+i<=n){let n,r,o,u;switch(i){case 1:t<128&&(a=t);break;case 2:n=e[s+1],128==(192&n)&&(u=(31&t)<<6|63&n,u>127&&(a=u));break;case 3:n=e[s+1],r=e[s+2],128==(192&n)&&128==(192&r)&&(u=(15&t)<<12|(63&n)<<6|63&r,u>2047&&(u<55296||u>57343)&&(a=u));break;case 4:n=e[s+1],r=e[s+2],o=e[s+3],128==(192&n)&&128==(192&r)&&128==(192&o)&&(u=(15&t)<<18|(63&n)<<12|(63&r)<<6|63&o,u>65535&&u<1114112&&(a=u))}}null===a?(a=65533,i=1):a>65535&&(a-=65536,r.push(a>>>10&1023|55296),a=56320|1023&a),r.push(a),s+=i}return function(e){const t=e.length;if(t<=E)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=E));return n}(r)}u.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),u.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}}),u.poolSize=8192,u.from=function(e,t,n){return l(e,t,n)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array),u.alloc=function(e,t,n){return function(e,t,n){return c(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},u.allocUnsafe=function(e){return h(e)},u.allocUnsafeSlow=function(e){return h(e)},u.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==u.prototype},u.compare=function(e,t){if(X(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),X(t,Uint8Array)&&(t=u.from(t,t.offset,t.byteLength)),!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,r=t.length;for(let s=0,a=Math.min(n,r);s<a;++s)if(e[s]!==t[s]){n=e[s],r=t[s];break}return n<r?-1:r<n?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const r=u.allocUnsafe(t);let s=0;for(n=0;n<e.length;++n){let t=e[n];if(X(t,Uint8Array))s+t.length>r.length?(u.isBuffer(t)||(t=u.from(t)),t.copy(r,s)):Uint8Array.prototype.set.call(r,t,s);else{if(!u.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(r,s)}s+=t.length}return r},u.byteLength=m,u.prototype._isBuffer=!0,u.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)y(this,t,t+1);return this},u.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)y(this,t,t+3),y(this,t+1,t+2);return this},u.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)y(this,t,t+7),y(this,t+1,t+6),y(this,t+2,t+5),y(this,t+3,t+4);return this},u.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?C(this,0,e):g.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){let e="";const n=t.h2;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},a&&(u.prototype[a]=u.prototype.inspect),u.prototype.compare=function(e,t,n,r,s){if(X(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),!u.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===s&&(s=this.length),t<0||n>e.length||r<0||s>this.length)throw new RangeError("out of range index");if(r>=s&&t>=n)return 0;if(r>=s)return-1;if(t>=n)return 1;if(this===e)return 0;let a=(s>>>=0)-(r>>>=0),i=(n>>>=0)-(t>>>=0);const o=Math.min(a,i),l=this.slice(r,s),c=e.slice(t,n);for(let e=0;e<o;++e)if(l[e]!==c[e]){a=l[e],i=c[e];break}return a<i?-1:i<a?1:0},u.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},u.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},u.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},u.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}const s=this.length-t;if((void 0===n||n>s)&&(n=s),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");let a=!1;for(;;)switch(r){case"hex":return w(this,e,t,n);case"utf8":case"utf-8":return v(this,e,t,n);case"ascii":case"latin1":case"binary":return k(this,e,t,n);case"base64":return I(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return N(this,e,t,n);default:if(a)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),a=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const E=4096;function T(e,t,n){let r="";n=Math.min(e.length,n);for(let s=t;s<n;++s)r+=String.fromCharCode(127&e[s]);return r}function $(e,t,n){let r="";n=Math.min(e.length,n);for(let s=t;s<n;++s)r+=String.fromCharCode(e[s]);return r}function A(e,t,n){const r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);let s="";for(let r=t;r<n;++r)s+=J[e[r]];return s}function R(e,t,n){const r=e.slice(t,n);let s="";for(let e=0;e<r.length-1;e+=2)s+=String.fromCharCode(r[e]+256*r[e+1]);return s}function _(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function F(e,t,n,r,s,a){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<a)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function D(e,t,n,r,s){W(t,r,s,e,n,7);let a=Number(t&BigInt(4294967295));e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,n}function O(e,t,n,r,s){W(t,r,s,e,n,7);let a=Number(t&BigInt(4294967295));e[n+7]=a,a>>=8,e[n+6]=a,a>>=8,e[n+5]=a,a>>=8,e[n+4]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=i,i>>=8,e[n+2]=i,i>>=8,e[n+1]=i,i>>=8,e[n]=i,n+8}function M(e,t,n,r,s,a){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function L(e,t,n,r,a){return t=+t,n>>>=0,a||M(e,0,n,4),s.write(e,t,n,r,23,4),n+4}function z(e,t,n,r,a){return t=+t,n>>>=0,a||M(e,0,n,8),s.write(e,t,n,r,52,8),n+8}u.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const r=this.subarray(e,t);return Object.setPrototypeOf(r,u.prototype),r},u.prototype.readUintLE=u.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||_(e,t,this.length);let r=this[e],s=1,a=0;for(;++a<t&&(s*=256);)r+=this[e+a]*s;return r},u.prototype.readUintBE=u.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||_(e,t,this.length);let r=this[e+--t],s=1;for(;t>0&&(s*=256);)r+=this[e+--t]*s;return r},u.prototype.readUint8=u.prototype.readUInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),this[e]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readBigUInt64LE=Z((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||G(e,this.length-8);const r=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,s=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(r)+(BigInt(s)<<BigInt(32))})),u.prototype.readBigUInt64BE=Z((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||G(e,this.length-8);const r=t*2**24+65536*this[++e]+256*this[++e]+this[++e],s=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(r)<<BigInt(32))+BigInt(s)})),u.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||_(e,t,this.length);let r=this[e],s=1,a=0;for(;++a<t&&(s*=256);)r+=this[e+a]*s;return s*=128,r>=s&&(r-=Math.pow(2,8*t)),r},u.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||_(e,t,this.length);let r=t,s=1,a=this[e+--r];for(;r>0&&(s*=256);)a+=this[e+--r]*s;return s*=128,a>=s&&(a-=Math.pow(2,8*t)),a},u.prototype.readInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){e>>>=0,t||_(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt16BE=function(e,t){e>>>=0,t||_(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readBigInt64LE=Z((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||G(e,this.length-8);const r=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(r)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),u.prototype.readBigInt64BE=Z((function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||G(e,this.length-8);const r=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(r)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)})),u.prototype.readFloatLE=function(e,t){return e>>>=0,t||_(e,4,this.length),s.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return e>>>=0,t||_(e,4,this.length),s.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return e>>>=0,t||_(e,8,this.length),s.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return e>>>=0,t||_(e,8,this.length),s.read(this,e,!1,52,8)},u.prototype.writeUintLE=u.prototype.writeUIntLE=function(e,t,n,r){if(e=+e,t>>>=0,n>>>=0,!r){F(this,e,t,n,Math.pow(2,8*n)-1,0)}let s=1,a=0;for(this[t]=255&e;++a<n&&(s*=256);)this[t+a]=e/s&255;return t+n},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(e,t,n,r){if(e=+e,t>>>=0,n>>>=0,!r){F(this,e,t,n,Math.pow(2,8*n)-1,0)}let s=n-1,a=1;for(this[t+s]=255&e;--s>=0&&(a*=256);)this[t+s]=e/a&255;return t+n},u.prototype.writeUint8=u.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,255,0),this[t]=255&e,t+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigUInt64LE=Z((function(e,t=0){return D(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeBigUInt64BE=Z((function(e,t=0){return O(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*n-1);F(this,e,t,n,r-1,-r)}let s=0,a=1,i=0;for(this[t]=255&e;++s<n&&(a*=256);)e<0&&0===i&&0!==this[t+s-1]&&(i=1),this[t+s]=(e/a>>0)-i&255;return t+n},u.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*n-1);F(this,e,t,n,r-1,-r)}let s=n-1,a=1,i=0;for(this[t+s]=255&e;--s>=0&&(a*=256);)e<0&&0===i&&0!==this[t+s+1]&&(i=1),this[t+s]=(e/a>>0)-i&255;return t+n},u.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},u.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigInt64LE=Z((function(e,t=0){return D(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeBigInt64BE=Z((function(e,t=0){return O(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeFloatLE=function(e,t,n){return L(this,e,t,!0,n)},u.prototype.writeFloatBE=function(e,t,n){return L(this,e,t,!1,n)},u.prototype.writeDoubleLE=function(e,t,n){return z(this,e,t,!0,n)},u.prototype.writeDoubleBE=function(e,t,n){return z(this,e,t,!1,n)},u.prototype.copy=function(e,t,n,r){if(!u.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);const s=r-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,r):Uint8Array.prototype.set.call(e,this.subarray(n,r),t),s},u.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!u.isEncoding(r))throw new TypeError("Unknown encoding: "+r);if(1===e.length){const t=e.charCodeAt(0);("utf8"===r&&t<128||"latin1"===r)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let s;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(s=t;s<n;++s)this[s]=e;else{const a=u.isBuffer(e)?e:u.from(e,r),i=a.length;if(0===i)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(s=0;s<n-t;++s)this[s+t]=a[s%i]}return this};const B={};function P(e,t,n){B[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function V(e){let t="",n=e.length;const r="-"===e[0]?1:0;for(;n>=r+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function W(e,t,n,r,s,a){if(e>n||e<t){const r="bigint"==typeof t?"n":"";let s;throw s=a>3?0===t||t===BigInt(0)?`>= 0${r} and < 2${r} ** ${8*(a+1)}${r}`:`>= -(2${r} ** ${8*(a+1)-1}${r}) and < 2 ** ${8*(a+1)-1}${r}`:`>= ${t}${r} and <= ${n}${r}`,new B.ERR_OUT_OF_RANGE("value",s,e)}!function(e,t,n){U(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||G(t,e.length-(n+1))}(r,s,a)}function U(e,t){if("number"!=typeof e)throw new B.ERR_INVALID_ARG_TYPE(t,"number",e)}function G(e,t,n){if(Math.floor(e)!==e)throw U(e,n),new B.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new B.ERR_BUFFER_OUT_OF_BOUNDS;throw new B.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}P("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),P("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),P("ERR_OUT_OF_RANGE",(function(e,t,n){let r=`The value of "${e}" is out of range.`,s=n;return Number.isInteger(n)&&Math.abs(n)>2**32?s=V(String(n)):"bigint"==typeof n&&(s=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(s=V(s)),s+="n"),r+=` It must be ${t}. Received ${s}`,r}),RangeError);const j=/[^+/0-9A-Za-z-_]/g;function H(e,t){let n;t=t||1/0;const r=e.length;let s=null;const a=[];for(let i=0;i<r;++i){if(n=e.charCodeAt(i),n>55295&&n<57344){if(!s){if(n>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&a.push(239,191,189);continue}s=n;continue}if(n<56320){(t-=3)>-1&&a.push(239,191,189),s=n;continue}n=65536+(s-55296<<10|n-56320)}else s&&(t-=3)>-1&&a.push(239,191,189);if(s=null,n<128){if((t-=1)<0)break;a.push(n)}else if(n<2048){if((t-=2)<0)break;a.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;a.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return a}function q(e){return r.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(j,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function K(e,t,n,r){let s;for(s=0;s<r&&!(s+n>=t.length||s>=e.length);++s)t[s+n]=e[s];return s}function X(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Y(e){return e!=e}const J=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const r=16*n;for(let s=0;s<16;++s)t[r+s]=e[n]+e[s]}return t}();function Z(e){return"undefined"==typeof BigInt?Q:e}function Q(){throw new Error("BigInt not supported")}},239:function(e,t,n){"use strict";var r=n(81);function s(){this.argTypes=[],this.shimArgs=[],this.arrayArgs=[],this.arrayBlockIndices=[],this.scalarArgs=[],this.offsetArgs=[],this.offsetArgIndex=[],this.indexArgs=[],this.shapeArgs=[],this.funcName="",this.pre=null,this.body=null,this.post=null,this.debug=!1}e.exports=function(e){var t=new s;t.pre=e.pre,t.body=e.body,t.post=e.post;var n=e.args.slice(0);t.argTypes=n;for(var a=0;a<n.length;++a){var i=n[a];if("array"===i||"object"==typeof i&&i.blockIndices){if(t.argTypes[a]="array",t.arrayArgs.push(a),t.arrayBlockIndices.push(i.blockIndices?i.blockIndices:0),t.shimArgs.push("array"+a),a<t.pre.args.length&&t.pre.args[a].count>0)throw new Error("cwise: pre() block may not reference array args");if(a<t.post.args.length&&t.post.args[a].count>0)throw new Error("cwise: post() block may not reference array args")}else if("scalar"===i)t.scalarArgs.push(a),t.shimArgs.push("scalar"+a);else if("index"===i){if(t.indexArgs.push(a),a<t.pre.args.length&&t.pre.args[a].count>0)throw new Error("cwise: pre() block may not reference array index");if(a<t.body.args.length&&t.body.args[a].lvalue)throw new Error("cwise: body() block may not write to array index");if(a<t.post.args.length&&t.post.args[a].count>0)throw new Error("cwise: post() block may not reference array index")}else if("shape"===i){if(t.shapeArgs.push(a),a<t.pre.args.length&&t.pre.args[a].lvalue)throw new Error("cwise: pre() block may not write to array shape");if(a<t.body.args.length&&t.body.args[a].lvalue)throw new Error("cwise: body() block may not write to array shape");if(a<t.post.args.length&&t.post.args[a].lvalue)throw new Error("cwise: post() block may not write to array shape")}else{if("object"!=typeof i||!i.offset)throw new Error("cwise: Unknown argument type "+n[a]);t.argTypes[a]="offset",t.offsetArgs.push({array:i.array,offset:i.offset}),t.offsetArgIndex.push(a)}}if(t.arrayArgs.length<=0)throw new Error("cwise: No array arguments specified");if(t.pre.args.length>n.length)throw new Error("cwise: Too many arguments in pre() block");if(t.body.args.length>n.length)throw new Error("cwise: Too many arguments in body() block");if(t.post.args.length>n.length)throw new Error("cwise: Too many arguments in post() block");return t.debug=!!e.printCode||!!e.debug,t.funcName=e.funcName||"cwise",t.blockSize=e.blockSize||64,r(t)}},984:function(e,t,n){"use strict";var r=n(706);function s(e,t,n){var r,s,a=e.length,i=t.arrayArgs.length,o=t.indexArgs.length>0,u=[],l=[],c=0,h=0;for(r=0;r<a;++r)l.push(["i",r,"=0"].join(""));for(s=0;s<i;++s)for(r=0;r<a;++r)h=c,c=e[r],0===r?l.push(["d",s,"s",r,"=t",s,"p",c].join("")):l.push(["d",s,"s",r,"=(t",s,"p",c,"-s",h,"*t",s,"p",h,")"].join(""));for(l.length>0&&u.push("var "+l.join(",")),r=a-1;r>=0;--r)c=e[r],u.push(["for(i",r,"=0;i",r,"<s",c,";++i",r,"){"].join(""));for(u.push(n),r=0;r<a;++r){for(h=c,c=e[r],s=0;s<i;++s)u.push(["p",s,"+=d",s,"s",r].join(""));o&&(r>0&&u.push(["index[",h,"]-=s",h].join("")),u.push(["++index[",c,"]"].join(""))),u.push("}")}return u.join("\n")}function a(e,t,n){for(var r=e.body,s=[],a=[],i=0;i<e.args.length;++i){var o=e.args[i];if(!(o.count<=0)){var u=new RegExp(o.name,"g"),l="",c=t.arrayArgs.indexOf(i);switch(t.argTypes[i]){case"offset":var h=t.offsetArgIndex.indexOf(i);c=t.offsetArgs[h].array,l="+q"+h;case"array":l="p"+c+l;var p="l"+i,d="a"+c;if(0===t.arrayBlockIndices[c])1===o.count?"generic"===n[c]?o.lvalue?(s.push(["var ",p,"=",d,".get(",l,")"].join("")),r=r.replace(u,p),a.push([d,".set(",l,",",p,")"].join(""))):r=r.replace(u,[d,".get(",l,")"].join("")):r=r.replace(u,[d,"[",l,"]"].join("")):"generic"===n[c]?(s.push(["var ",p,"=",d,".get(",l,")"].join("")),r=r.replace(u,p),o.lvalue&&a.push([d,".set(",l,",",p,")"].join(""))):(s.push(["var ",p,"=",d,"[",l,"]"].join("")),r=r.replace(u,p),o.lvalue&&a.push([d,"[",l,"]=",p].join("")));else{for(var f=[o.name],m=[l],g=0;g<Math.abs(t.arrayBlockIndices[c]);g++)f.push("\\s*\\[([^\\]]+)\\]"),m.push("$"+(g+1)+"*t"+c+"b"+g);if(u=new RegExp(f.join(""),"g"),l=m.join("+"),"generic"===n[c])throw new Error("cwise: Generic arrays not supported in combination with blocks!");r=r.replace(u,[d,"[",l,"]"].join(""))}break;case"scalar":r=r.replace(u,"Y"+t.scalarArgs.indexOf(i));break;case"index":r=r.replace(u,"index");break;case"shape":r=r.replace(u,"shape")}}}return[s.join("\n"),r,a.join("\n")].join("\n").trim()}function i(e){for(var t=new Array(e.length),n=!0,r=0;r<e.length;++r){var s=e[r],a=s.match(/\d+/);a=a?a[0]:"",0===s.charAt(0)?t[r]="u"+s.charAt(1)+a:t[r]=s.charAt(0)+a,r>0&&(n=n&&t[r]===t[r-1])}return n?t[0]:t.join("")}e.exports=function(e,t){for(var n=t[1].length-Math.abs(e.arrayBlockIndices[0])|0,o=new Array(e.arrayArgs.length),u=new Array(e.arrayArgs.length),l=0;l<e.arrayArgs.length;++l)u[l]=t[2*l],o[l]=t[2*l+1];var c=[],h=[],p=[],d=[],f=[];for(l=0;l<e.arrayArgs.length;++l){e.arrayBlockIndices[l]<0?(p.push(0),d.push(n),c.push(n),h.push(n+e.arrayBlockIndices[l])):(p.push(e.arrayBlockIndices[l]),d.push(e.arrayBlockIndices[l]+n),c.push(0),h.push(e.arrayBlockIndices[l]));for(var m=[],g=0;g<o[l].length;g++)p[l]<=o[l][g]&&o[l][g]<d[l]&&m.push(o[l][g]-p[l]);f.push(m)}var y=["SS"],b=["'use strict'"],x=[];for(g=0;g<n;++g)x.push(["s",g,"=SS[",g,"]"].join(""));for(l=0;l<e.arrayArgs.length;++l){y.push("a"+l),y.push("t"+l),y.push("p"+l);for(g=0;g<n;++g)x.push(["t",l,"p",g,"=t",l,"[",p[l]+g,"]"].join(""));for(g=0;g<Math.abs(e.arrayBlockIndices[l]);++g)x.push(["t",l,"b",g,"=t",l,"[",c[l]+g,"]"].join(""))}for(l=0;l<e.scalarArgs.length;++l)y.push("Y"+l);if(e.shapeArgs.length>0&&x.push("shape=SS.slice(0)"),e.indexArgs.length>0){var w=new Array(n);for(l=0;l<n;++l)w[l]="0";x.push(["index=[",w.join(","),"]"].join(""))}for(l=0;l<e.offsetArgs.length;++l){var v=e.offsetArgs[l],k=[];for(g=0;g<v.offset.length;++g)0!==v.offset[g]&&(1===v.offset[g]?k.push(["t",v.array,"p",g].join("")):k.push([v.offset[g],"*t",v.array,"p",g].join("")));0===k.length?x.push("q"+l+"=0"):x.push(["q",l,"=",k.join("+")].join(""))}var I=r([].concat(e.pre.thisVars).concat(e.body.thisVars).concat(e.post.thisVars));for((x=x.concat(I)).length>0&&b.push("var "+x.join(",")),l=0;l<e.arrayArgs.length;++l)b.push("p"+l+"|=0");e.pre.body.length>3&&b.push(a(e.pre,e,u));var N=a(e.body,e,u),S=function(e){for(var t=0,n=e[0].length;t<n;){for(var r=1;r<e.length;++r)if(e[r][t]!==e[0][t])return t;++t}return t}(f);S<n?b.push(function(e,t,n,r){for(var a=t.length,i=n.arrayArgs.length,o=n.blockSize,u=n.indexArgs.length>0,l=[],c=0;c<i;++c)l.push(["var offset",c,"=p",c].join(""));for(c=e;c<a;++c)l.push(["for(var j"+c+"=SS[",t[c],"]|0;j",c,">0;){"].join("")),l.push(["if(j",c,"<",o,"){"].join("")),l.push(["s",t[c],"=j",c].join("")),l.push(["j",c,"=0"].join("")),l.push(["}else{s",t[c],"=",o].join("")),l.push(["j",c,"-=",o,"}"].join("")),u&&l.push(["index[",t[c],"]=j",c].join(""));for(c=0;c<i;++c){for(var h=["offset"+c],p=e;p<a;++p)h.push(["j",p,"*t",c,"p",t[p]].join(""));l.push(["p",c,"=(",h.join("+"),")"].join(""))}for(l.push(s(t,n,r)),c=e;c<a;++c)l.push("}");return l.join("\n")}(S,f[0],e,N)):b.push(s(f[0],e,N)),e.post.body.length>3&&b.push(a(e.post,e,u)),e.debug&&console.log("-----Generated cwise routine for ",t,":\n"+b.join("\n")+"\n----------");var C=[e.funcName||"unnamed","_cwise_loop_",o[0].join("s"),"m",S,i(u)].join("");return new Function(["function ",C,"(",y.join(","),"){",b.join("\n"),"} return ",C].join(""))()}},81:function(e,t,n){"use strict";var r=n(984);e.exports=function(e){var t=["'use strict'","var CACHED={}"],n=[],s=e.funcName+"_cwise_thunk";t.push(["return function ",s,"(",e.shimArgs.join(","),"){"].join(""));for(var a=[],i=[],o=[["array",e.arrayArgs[0],".shape.slice(",Math.max(0,e.arrayBlockIndices[0]),e.arrayBlockIndices[0]<0?","+e.arrayBlockIndices[0]+")":")"].join("")],u=[],l=[],c=0;c<e.arrayArgs.length;++c){var h=e.arrayArgs[c];n.push(["t",h,"=array",h,".dtype,","r",h,"=array",h,".order"].join("")),a.push("t"+h),a.push("r"+h),i.push("t"+h),i.push("r"+h+".join()"),o.push("array"+h+".data"),o.push("array"+h+".stride"),o.push("array"+h+".offset|0"),c>0&&(u.push("array"+e.arrayArgs[0]+".shape.length===array"+h+".shape.length+"+(Math.abs(e.arrayBlockIndices[0])-Math.abs(e.arrayBlockIndices[c]))),l.push("array"+e.arrayArgs[0]+".shape[shapeIndex+"+Math.max(0,e.arrayBlockIndices[0])+"]===array"+h+".shape[shapeIndex+"+Math.max(0,e.arrayBlockIndices[c])+"]"))}for(e.arrayArgs.length>1&&(t.push("if (!("+u.join(" && ")+")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"),t.push("for(var shapeIndex=array"+e.arrayArgs[0]+".shape.length-"+Math.abs(e.arrayBlockIndices[0])+"; shapeIndex--\x3e0;) {"),t.push("if (!("+l.join(" && ")+")) throw new Error('cwise: Arrays do not all have the same shape!')"),t.push("}")),c=0;c<e.scalarArgs.length;++c)o.push("scalar"+e.scalarArgs[c]);return n.push(["type=[",i.join(","),"].join()"].join("")),n.push("proc=CACHED[type]"),t.push("var "+n.join(",")),t.push(["if(!proc){","CACHED[type]=proc=compile([",a.join(","),"])}","return proc(",o.join(","),")}"].join("")),e.debug&&console.log("-----Generated thunk:\n"+t.join("\n")+"\n----------"),new Function("compile",t.join("\n"))(r.bind(void 0,e))}},615:function(e,t,n){"use strict";var r=n(727),s=n(706),a=0;function i(e,t,n){this.name=e,this.lvalue=t,this.rvalue=n,this.count=0}function o(e,t,n,r){this.body=e,this.args=t,this.thisVars=n,this.localVars=r}e.exports=function(e){for(var t=["(",e,")()"].join(""),u=r.parse(t,{range:!0}),l="_inline_"+a+++"_",c=function(e){for(var t=e.body[0].expression.callee.params,n=new Array(t.length),r=0;r<t.length;++r)n[r]=t[r].name;return n}(u),h=new Array(c.length),p=0;p<c.length;++p)h[p]=new i([l,"arg",p,"_"].join(""),!1,!1);for(var d=new Array(t.length),f=(p=0,t.length);p<f;++p)d[p]=t.charAt(p);var m,g=[],y=[];function b(e,t){for(var n=e.range[0],r=e.range[1],s=n+1;s<r;++s)d[s]="";d[n]=t}return function e(t,r){if(t.parent=r,"MemberExpression"===t.type)t.computed?(e(t.object,t),e(t.property,t)):"ThisExpression"===t.object.type?b(t,(x=t.property.name,w="this_"+x.replace(/\_/g,"__"),y.push(w),w)):e(t.object,t);else{if("ThisExpression"===t.type)throw new Error("cwise-parser: Computed this is not allowed");if("Identifier"===t.type){var s=t.name,a=c.indexOf(s);if(a>=0){var i=h[a],o=function(e){return"AssignmentExpression"===e.parent.type&&e.parent.left===e?"="===e.parent.operator?1:3:"UpdateExpression"===e.parent.type?3:2}(t);1&o&&(i.lvalue=!0),2&o&&(i.rvalue=!0),++i.count,b(t,i.name)}else(function(e){if("eval"===e)throw new Error("cwise-parser: eval() not allowed");return"undefined"!=typeof window?e in window:void 0!==n.g?e in n.g:"undefined"!=typeof self&&e in self})(s)||b(t,function(e){var t=l+e.replace(/\_/g,"__");return g.push(t),t}(s))}else if("Literal"===t.type)"string"==typeof t.value&&b(t,"'"+t.value.replace(/\_/g,"\\_").replace(/\'/g,"'")+"'");else{if("WithStatement"===t.type)throw new Error("cwise-parser: with() statements not allowed");for(var u=Object.keys(t),p=0,d=u.length;p<d;++p)if("parent"!==u[p]){var f=t[u[p]];if(f)if(f instanceof Array)for(var m=0;m<f.length;++m)f[m]&&"string"==typeof f[m].type&&e(f[m],t);else"string"==typeof f.type&&e(f,t)}}}var x,w}(u.body[0].expression.callee.body,void 0),s(g),s(y),new o((m=u.body[0].expression.callee.body,d.slice(m.range[0],m.range[1]).join("")),h,y,g)}},727:function(e,t){var n,r,s;!function(a,i){"use strict";r=[t],void 0===(s="function"==typeof(n=function(e){var t,n,r,s,a,i,o,u,l,c,h,p,d,f,m,g,y,b;function x(e,t){if(!e)throw new Error("ASSERT: "+t)}function w(e){return e>=48&&e<=57}function v(e){return"0123456789abcdefABCDEF".indexOf(e)>=0}function k(e){return"01234567".indexOf(e)>=0}function I(e){return 32===e||9===e||11===e||12===e||160===e||e>=5760&&[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].indexOf(e)>=0}function N(e){return 10===e||13===e||8232===e||8233===e}function S(e){return 36===e||95===e||e>=65&&e<=90||e>=97&&e<=122||92===e||e>=128&&o.NonAsciiIdentifierStart.test(String.fromCharCode(e))}function C(e){return 36===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=48&&e<=57||92===e||e>=128&&o.NonAsciiIdentifierPart.test(String.fromCharCode(e))}function E(e){switch(e){case"class":case"enum":case"export":case"extends":case"import":case"super":return!0;default:return!1}}function T(e){switch(e){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"yield":case"let":return!0;default:return!1}}function $(e){return"eval"===e||"arguments"===e}function A(e){if(c&&T(e))return!0;switch(e.length){case 2:return"if"===e||"in"===e||"do"===e;case 3:return"var"===e||"for"===e||"new"===e||"try"===e||"let"===e;case 4:return"this"===e||"else"===e||"case"===e||"void"===e||"with"===e||"enum"===e;case 5:return"while"===e||"break"===e||"catch"===e||"throw"===e||"const"===e||"yield"===e||"class"===e||"super"===e;case 6:return"return"===e||"typeof"===e||"delete"===e||"switch"===e||"export"===e||"import"===e;case 7:return"default"===e||"finally"===e||"extends"===e;case 8:return"function"===e||"continue"===e||"debugger"===e;case 10:return"instanceof"===e;default:return!1}}function R(e,t,n,r,s){var a;x("number"==typeof n,"Comment must have valid position"),y.lastCommentStart>=n||(y.lastCommentStart=n,a={type:e,value:t},b.range&&(a.range=[n,r]),b.loc&&(a.loc=s),b.comments.push(a),b.attachComment&&(b.leadingComments.push(a),b.trailingComments.push(a)))}function _(e){var t,n,r,s;for(t=h-e,n={start:{line:p,column:h-d-e}};h<f;)if(r=l.charCodeAt(h),++h,N(r))return b.comments&&(s=l.slice(t+e,h-1),n.end={line:p,column:h-d-1},R("Line",s,t,h-1,n)),13===r&&10===l.charCodeAt(h)&&++h,++p,void(d=h);b.comments&&(s=l.slice(t+e,h),n.end={line:p,column:h-d},R("Line",s,t,h,n))}function F(){var e,t,n,r;for(b.comments&&(e=h-2,t={start:{line:p,column:h-d-2}});h<f;)if(N(n=l.charCodeAt(h)))13===n&&10===l.charCodeAt(h+1)&&++h,++p,++h,d=h,h>=f&&ae({},i.UnexpectedToken,"ILLEGAL");else if(42===n){if(47===l.charCodeAt(h+1))return++h,++h,void(b.comments&&(r=l.slice(e+2,h-2),t.end={line:p,column:h-d},R("Block",r,e,h,t)));++h}else++h;ae({},i.UnexpectedToken,"ILLEGAL")}function D(){var e,t;for(t=0===h;h<f;)if(I(e=l.charCodeAt(h)))++h;else if(N(e))++h,13===e&&10===l.charCodeAt(h)&&++h,++p,d=h,t=!0;else if(47===e)if(47===(e=l.charCodeAt(h+1)))++h,++h,_(2),t=!0;else{if(42!==e)break;++h,++h,F()}else if(t&&45===e){if(45!==l.charCodeAt(h+1)||62!==l.charCodeAt(h+2))break;h+=3,_(3)}else{if(60!==e)break;if("!--"!==l.slice(h+1,h+4))break;++h,++h,++h,++h,_(4)}}function O(e){var t,n,r,s=0;for(n="u"===e?4:2,t=0;t<n;++t){if(!(h<f&&v(l[h])))return"";r=l[h++],s=16*s+"0123456789abcdef".indexOf(r.toLowerCase())}return String.fromCharCode(s)}function M(){var e,t;for(e=l.charCodeAt(h++),t=String.fromCharCode(e),92===e&&(117!==l.charCodeAt(h)&&ae({},i.UnexpectedToken,"ILLEGAL"),++h,(e=O("u"))&&"\\"!==e&&S(e.charCodeAt(0))||ae({},i.UnexpectedToken,"ILLEGAL"),t=e);h<f&&C(e=l.charCodeAt(h));)++h,t+=String.fromCharCode(e),92===e&&(t=t.substr(0,t.length-1),117!==l.charCodeAt(h)&&ae({},i.UnexpectedToken,"ILLEGAL"),++h,(e=O("u"))&&"\\"!==e&&C(e.charCodeAt(0))||ae({},i.UnexpectedToken,"ILLEGAL"),t+=e);return t}function L(){var e,t;for(e=h++;h<f;){if(92===(t=l.charCodeAt(h)))return h=e,M();if(!C(t))break;++h}return l.slice(e,h)}function z(){var e,n;return e=h,{type:1===(n=92===l.charCodeAt(h)?M():L()).length?t.Identifier:A(n)?t.Keyword:"null"===n?t.NullLiteral:"true"===n||"false"===n?t.BooleanLiteral:t.Identifier,value:n,lineNumber:p,lineStart:d,start:e,end:h}}function B(){var e,n,r,s,a=h,o=l.charCodeAt(h),u=l[h];switch(o){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:case 126:return++h,b.tokenize&&(40===o?b.openParenToken=b.tokens.length:123===o&&(b.openCurlyToken=b.tokens.length)),{type:t.Punctuator,value:String.fromCharCode(o),lineNumber:p,lineStart:d,start:a,end:h};default:if(61===(e=l.charCodeAt(h+1)))switch(o){case 43:case 45:case 47:case 60:case 62:case 94:case 124:case 37:case 38:case 42:return h+=2,{type:t.Punctuator,value:String.fromCharCode(o)+String.fromCharCode(e),lineNumber:p,lineStart:d,start:a,end:h};case 33:case 61:return h+=2,61===l.charCodeAt(h)&&++h,{type:t.Punctuator,value:l.slice(a,h),lineNumber:p,lineStart:d,start:a,end:h}}}return">>>="===(s=l.substr(h,4))?(h+=4,{type:t.Punctuator,value:s,lineNumber:p,lineStart:d,start:a,end:h}):">>>"===(r=s.substr(0,3))||"<<="===r||">>="===r?(h+=3,{type:t.Punctuator,value:r,lineNumber:p,lineStart:d,start:a,end:h}):u===(n=r.substr(0,2))[1]&&"+-<>&|".indexOf(u)>=0||"=>"===n?(h+=2,{type:t.Punctuator,value:n,lineNumber:p,lineStart:d,start:a,end:h}):"<>=!+-*%&|^/".indexOf(u)>=0?(++h,{type:t.Punctuator,value:u,lineNumber:p,lineStart:d,start:a,end:h}):void ae({},i.UnexpectedToken,"ILLEGAL")}function P(e){for(var n="";h<f&&v(l[h]);)n+=l[h++];return 0===n.length&&ae({},i.UnexpectedToken,"ILLEGAL"),S(l.charCodeAt(h))&&ae({},i.UnexpectedToken,"ILLEGAL"),{type:t.NumericLiteral,value:parseInt("0x"+n,16),lineNumber:p,lineStart:d,start:e,end:h}}function V(e){for(var n="0"+l[h++];h<f&&k(l[h]);)n+=l[h++];return(S(l.charCodeAt(h))||w(l.charCodeAt(h)))&&ae({},i.UnexpectedToken,"ILLEGAL"),{type:t.NumericLiteral,value:parseInt(n,8),octal:!0,lineNumber:p,lineStart:d,start:e,end:h}}function W(){var e,t;for(e=h+1;e<f;++e){if("8"===(t=l[e])||"9"===t)return!1;if(!k(t))return!0}return!0}function U(){var e,n,r;if(x(w((r=l[h]).charCodeAt(0))||"."===r,"Numeric literal must start with a decimal digit or a decimal point"),n=h,e="","."!==r){if(e=l[h++],r=l[h],"0"===e){if("x"===r||"X"===r)return++h,P(n);if(k(r)&&W())return V(n)}for(;w(l.charCodeAt(h));)e+=l[h++];r=l[h]}if("."===r){for(e+=l[h++];w(l.charCodeAt(h));)e+=l[h++];r=l[h]}if("e"===r||"E"===r)if(e+=l[h++],"+"!==(r=l[h])&&"-"!==r||(e+=l[h++]),w(l.charCodeAt(h)))for(;w(l.charCodeAt(h));)e+=l[h++];else ae({},i.UnexpectedToken,"ILLEGAL");return S(l.charCodeAt(h))&&ae({},i.UnexpectedToken,"ILLEGAL"),{type:t.NumericLiteral,value:parseFloat(e),lineNumber:p,lineStart:d,start:n,end:h}}function G(){var e,n,r,s,a,o,u,c,m="",g=!1;for(u=p,c=d,x("'"===(e=l[h])||'"'===e,"String literal must starts with a quote"),n=h,++h;h<f;){if((r=l[h++])===e){e="";break}if("\\"===r)if((r=l[h++])&&N(r.charCodeAt(0)))++p,"\r"===r&&"\n"===l[h]&&++h,d=h;else switch(r){case"u":case"x":o=h,(a=O(r))?m+=a:(h=o,m+=r);break;case"n":m+="\n";break;case"r":m+="\r";break;case"t":m+="\t";break;case"b":m+="\b";break;case"f":m+="\f";break;case"v":m+="\v";break;default:k(r)?(0!==(s="01234567".indexOf(r))&&(g=!0),h<f&&k(l[h])&&(g=!0,s=8*s+"01234567".indexOf(l[h++]),"0123".indexOf(r)>=0&&h<f&&k(l[h])&&(s=8*s+"01234567".indexOf(l[h++]))),m+=String.fromCharCode(s)):m+=r}else{if(N(r.charCodeAt(0)))break;m+=r}}return""!==e&&ae({},i.UnexpectedToken,"ILLEGAL"),{type:t.StringLiteral,value:m,octal:g,startLineNumber:u,startLineStart:c,lineNumber:p,lineStart:d,start:n,end:h}}function j(e,t){var n;try{n=new RegExp(e,t)}catch(e){ae({},i.InvalidRegExp)}return n}function H(){var e,t,n,r;for(x("/"===(e=l[h]),"Regular expression literal must start with a slash"),t=l[h++],n=!1,r=!1;h<f;)if(t+=e=l[h++],"\\"===e)N((e=l[h++]).charCodeAt(0))&&ae({},i.UnterminatedRegExp),t+=e;else if(N(e.charCodeAt(0)))ae({},i.UnterminatedRegExp);else if(n)"]"===e&&(n=!1);else{if("/"===e){r=!0;break}"["===e&&(n=!0)}return r||ae({},i.UnterminatedRegExp),{value:t.substr(1,t.length-2),literal:t}}function q(){var e,t,n,r;for(t="",n="";h<f&&C((e=l[h]).charCodeAt(0));)if(++h,"\\"===e&&h<f)if("u"===(e=l[h])){if(r=++h,e=O("u"))for(n+=e,t+="\\u";r<h;++r)t+=l[r];else h=r,n+="u",t+="\\u";ie({},i.UnexpectedToken,"ILLEGAL")}else t+="\\",ie({},i.UnexpectedToken,"ILLEGAL");else n+=e,t+=e;return{value:n,literal:t}}function K(){var e,n,r,s;return g=null,D(),e=h,n=H(),r=q(),s=j(n.value,r.value),b.tokenize?{type:t.RegularExpression,value:s,lineNumber:p,lineStart:d,start:e,end:h}:{literal:n.literal+r.literal,value:s,start:e,end:h}}function X(){var e,t,n,r;return D(),e=h,t={start:{line:p,column:h-d}},n=K(),t.end={line:p,column:h-d},b.tokenize||(b.tokens.length>0&&(r=b.tokens[b.tokens.length-1]).range[0]===e&&"Punctuator"===r.type&&("/"!==r.value&&"/="!==r.value||b.tokens.pop()),b.tokens.push({type:"RegularExpression",value:n.literal,range:[e,h],loc:t})),n}function Y(e){return e.type===t.Identifier||e.type===t.Keyword||e.type===t.BooleanLiteral||e.type===t.NullLiteral}function J(){var e,t;if(!(e=b.tokens[b.tokens.length-1]))return X();if("Punctuator"===e.type){if("]"===e.value)return B();if(")"===e.value)return!(t=b.tokens[b.openParenToken-1])||"Keyword"!==t.type||"if"!==t.value&&"while"!==t.value&&"for"!==t.value&&"with"!==t.value?B():X();if("}"===e.value){if(b.tokens[b.openCurlyToken-3]&&"Keyword"===b.tokens[b.openCurlyToken-3].type){if(!(t=b.tokens[b.openCurlyToken-4]))return B()}else{if(!b.tokens[b.openCurlyToken-4]||"Keyword"!==b.tokens[b.openCurlyToken-4].type)return B();if(!(t=b.tokens[b.openCurlyToken-5]))return X()}return r.indexOf(t.value)>=0?B():X()}return X()}return"Keyword"===e.type&&"this"!==e.value?X():B()}function Z(){var e;return D(),h>=f?{type:t.EOF,lineNumber:p,lineStart:d,start:h,end:h}:S(e=l.charCodeAt(h))?z():40===e||41===e||59===e?B():39===e||34===e?G():46===e?w(l.charCodeAt(h+1))?U():B():w(e)?U():b.tokenize&&47===e?J():B()}function Q(){var e,r,s;return D(),e={start:{line:p,column:h-d}},r=Z(),e.end={line:p,column:h-d},r.type!==t.EOF&&(s=l.slice(r.start,r.end),b.tokens.push({type:n[r.type],value:s,range:[r.start,r.end],loc:e})),r}function ee(){var e;return h=(e=g).end,p=e.lineNumber,d=e.lineStart,g=void 0!==b.tokens?Q():Z(),h=e.end,p=e.lineNumber,d=e.lineStart,e}function te(){var e,t,n;e=h,t=p,n=d,g=void 0!==b.tokens?Q():Z(),h=e,p=t,d=n}function ne(e,t){this.line=e,this.column=t}function re(e,t,n,r){this.start=new ne(e,t),this.end=new ne(n,r)}function se(){var e,t,n,r;return e=h,t=p,n=d,D(),r=p!==t,h=e,p=t,d=n,r}function ae(e,t){var n,r=Array.prototype.slice.call(arguments,2),s=t.replace(/%(\d)/g,(function(e,t){return x(t<r.length,"Message reference must be in range"),r[t]}));throw"number"==typeof e.lineNumber?((n=new Error("Line "+e.lineNumber+": "+s)).index=e.start,n.lineNumber=e.lineNumber,n.column=e.start-d+1):((n=new Error("Line "+p+": "+s)).index=h,n.lineNumber=p,n.column=h-d+1),n.description=s,n}function ie(){try{ae.apply(null,arguments)}catch(e){if(!b.errors)throw e;b.errors.push(e)}}function oe(e){if(e.type===t.EOF&&ae(e,i.UnexpectedEOS),e.type===t.NumericLiteral&&ae(e,i.UnexpectedNumber),e.type===t.StringLiteral&&ae(e,i.UnexpectedString),e.type===t.Identifier&&ae(e,i.UnexpectedIdentifier),e.type===t.Keyword){if(E(e.value))ae(e,i.UnexpectedReserved);else if(c&&T(e.value))return void ie(e,i.StrictReservedWord);ae(e,i.UnexpectedToken,e.value)}ae(e,i.UnexpectedToken,e.value)}function ue(e){var n=ee();n.type===t.Punctuator&&n.value===e||oe(n)}function le(e){var n=ee();n.type===t.Keyword&&n.value===e||oe(n)}function ce(e){return g.type===t.Punctuator&&g.value===e}function he(e){return g.type===t.Keyword&&g.value===e}function pe(){var e;return g.type===t.Punctuator&&("="===(e=g.value)||"*="===e||"/="===e||"%="===e||"+="===e||"-="===e||"<<="===e||">>="===e||">>>="===e||"&="===e||"^="===e||"|="===e)}function de(){var e,n=h,r=p,s=d,a=g;if(59===l.charCodeAt(h)||ce(";"))ee();else{if(e=p,D(),p!==e)return h=n,p=r,d=s,void(g=a);g.type===t.EOF||ce("}")||oe(g)}}function fe(e){return e.type===s.Identifier||e.type===s.MemberExpression}function me(){var e,t=[];for(e=g,ue("[");!ce("]");)ce(",")?(ee(),t.push(null)):(t.push(De()),ce("]")||ue(","));return ee(),m.markEnd(m.createArrayExpression(t),e)}function ge(e,t){var n,r,s;return n=c,s=g,r=ot(),t&&c&&$(e[0].name)&&ie(t,i.StrictParamName),c=n,m.markEnd(m.createFunctionExpression(null,e,[],r),s)}function ye(){var e,n;return n=g,(e=ee()).type===t.StringLiteral||e.type===t.NumericLiteral?(c&&e.octal&&ie(e,i.StrictOctalLiteral),m.markEnd(m.createLiteral(e),n)):m.markEnd(m.createIdentifier(e.value),n)}function be(){var e,n,r,s,a,o;return o=g,(e=g).type===t.Identifier?(r=ye(),"get"!==e.value||ce(":")?"set"!==e.value||ce(":")?(ue(":"),s=De(),m.markEnd(m.createProperty("init",r,s),o)):(n=ye(),ue("("),(e=g).type!==t.Identifier?(ue(")"),ie(e,i.UnexpectedToken,e.value),s=ge([])):(a=[ze()],ue(")"),s=ge(a,e)),m.markEnd(m.createProperty("set",n,s),o)):(n=ye(),ue("("),ue(")"),s=ge([]),m.markEnd(m.createProperty("get",n,s),o))):e.type!==t.EOF&&e.type!==t.Punctuator?(n=ye(),ue(":"),s=De(),m.markEnd(m.createProperty("init",n,s),o)):void oe(e)}function xe(){var e,t,n,r,o,u=[],l={},h=String;for(o=g,ue("{");!ce("}");)t=(e=be()).key.type===s.Identifier?e.key.name:h(e.key.value),r="init"===e.kind?a.Data:"get"===e.kind?a.Get:a.Set,n="$"+t,Object.prototype.hasOwnProperty.call(l,n)?(l[n]===a.Data?c&&r===a.Data?ie({},i.StrictDuplicateProperty):r!==a.Data&&ie({},i.AccessorDataProperty):r===a.Data?ie({},i.AccessorDataProperty):l[n]&r&&ie({},i.AccessorGetSet),l[n]|=r):l[n]=r,u.push(e),ce("}")||ue(",");return ue("}"),m.markEnd(m.createObjectExpression(u),o)}function we(){var e;return ue("("),e=Oe(),ue(")"),e}function ve(){var e,n,r,s;if(ce("("))return we();if(ce("["))return me();if(ce("{"))return xe();if(e=g.type,s=g,e===t.Identifier)r=m.createIdentifier(ee().value);else if(e===t.StringLiteral||e===t.NumericLiteral)c&&g.octal&&ie(g,i.StrictOctalLiteral),r=m.createLiteral(ee());else if(e===t.Keyword){if(he("function"))return ct();he("this")?(ee(),r=m.createThisExpression()):oe(ee())}else e===t.BooleanLiteral?((n=ee()).value="true"===n.value,r=m.createLiteral(n)):e===t.NullLiteral?((n=ee()).value=null,r=m.createLiteral(n)):ce("/")||ce("/=")?(r=void 0!==b.tokens?m.createLiteral(X()):m.createLiteral(K()),te()):oe(ee());return m.markEnd(r,s)}function ke(){var e=[];if(ue("("),!ce(")"))for(;h<f&&(e.push(De()),!ce(")"));)ue(",");return ue(")"),e}function Ie(){var e,t;return t=g,Y(e=ee())||oe(e),m.markEnd(m.createIdentifier(e.value),t)}function Ne(){return ue("."),Ie()}function Se(){var e;return ue("["),e=Oe(),ue("]"),e}function Ce(){var e,t,n;return n=g,le("new"),e=Te(),t=ce("(")?ke():[],m.markEnd(m.createNewExpression(e,t),n)}function Ee(){var e,t,n,r,s=y.allowIn;for(r=g,y.allowIn=!0,e=he("new")?Ce():ve();;){if(ce("."))n=Ne(),e=m.createMemberExpression(".",e,n);else if(ce("("))t=ke(),e=m.createCallExpression(e,t);else{if(!ce("["))break;n=Se(),e=m.createMemberExpression("[",e,n)}m.markEnd(e,r)}return y.allowIn=s,e}function Te(){var e,t,n;for(x(y.allowIn,"callee of new expression always allow in keyword."),n=g,e=he("new")?Ce():ve();ce(".")||ce("[");)ce("[")?(t=Se(),e=m.createMemberExpression("[",e,t)):(t=Ne(),e=m.createMemberExpression(".",e,t)),m.markEnd(e,n);return e}function $e(){var e,n,r=g;return e=Ee(),g.type===t.Punctuator&&(!ce("++")&&!ce("--")||se()||(c&&e.type===s.Identifier&&$(e.name)&&ie({},i.StrictLHSPostfix),fe(e)||ie({},i.InvalidLHSInAssignment),n=ee(),e=m.markEnd(m.createPostfixExpression(n.value,e),r))),e}function Ae(){var e,n,r;return g.type!==t.Punctuator&&g.type!==t.Keyword?n=$e():ce("++")||ce("--")?(r=g,e=ee(),n=Ae(),c&&n.type===s.Identifier&&$(n.name)&&ie({},i.StrictLHSPrefix),fe(n)||ie({},i.InvalidLHSInAssignment),n=m.createUnaryExpression(e.value,n),n=m.markEnd(n,r)):ce("+")||ce("-")||ce("~")||ce("!")?(r=g,e=ee(),n=Ae(),n=m.createUnaryExpression(e.value,n),n=m.markEnd(n,r)):he("delete")||he("void")||he("typeof")?(r=g,e=ee(),n=Ae(),n=m.createUnaryExpression(e.value,n),n=m.markEnd(n,r),c&&"delete"===n.operator&&n.argument.type===s.Identifier&&ie({},i.StrictDelete)):n=$e(),n}function Re(e,n){var r=0;if(e.type!==t.Punctuator&&e.type!==t.Keyword)return 0;switch(e.value){case"||":r=1;break;case"&&":r=2;break;case"|":r=3;break;case"^":r=4;break;case"&":r=5;break;case"==":case"!=":case"===":case"!==":r=6;break;case"<":case">":case"<=":case">=":case"instanceof":r=7;break;case"in":r=n?7:0;break;case"<<":case">>":case">>>":r=8;break;case"+":case"-":r=9;break;case"*":case"/":case"%":r=11}return r}function _e(){var e,t,n,r,s,a,i,o,u,l;if(e=g,u=Ae(),0===(s=Re(r=g,y.allowIn)))return u;for(r.prec=s,ee(),t=[e,g],a=[u,r,i=Ae()];(s=Re(g,y.allowIn))>0;){for(;a.length>2&&s<=a[a.length-2].prec;)i=a.pop(),o=a.pop().value,u=a.pop(),n=m.createBinaryExpression(o,u,i),t.pop(),e=t[t.length-1],m.markEnd(n,e),a.push(n);(r=ee()).prec=s,a.push(r),t.push(g),n=Ae(),a.push(n)}for(n=a[l=a.length-1],t.pop();l>1;)n=m.createBinaryExpression(a[l-1].value,a[l-2],n),l-=2,e=t.pop(),m.markEnd(n,e);return n}function Fe(){var e,t,n,r,s;return s=g,e=_e(),ce("?")&&(ee(),t=y.allowIn,y.allowIn=!0,n=De(),y.allowIn=t,ue(":"),r=De(),e=m.createConditionalExpression(e,n,r),m.markEnd(e,s)),e}function De(){var e,t,n,r,a;return e=g,a=g,r=t=Fe(),pe()&&(fe(t)||ie({},i.InvalidLHSInAssignment),c&&t.type===s.Identifier&&$(t.name)&&ie(e,i.StrictLHSAssignment),e=ee(),n=De(),r=m.markEnd(m.createAssignmentExpression(e.value,t,n),a)),r}function Oe(){var e,t=g;if(e=De(),ce(",")){for(e=m.createSequenceExpression([e]);h<f&&ce(",");)ee(),e.expressions.push(De());m.markEnd(e,t)}return e}function Me(){for(var e,t=[];h<f&&!ce("}")&&void 0!==(e=ht());)t.push(e);return t}function Le(){var e,t;return t=g,ue("{"),e=Me(),ue("}"),m.markEnd(m.createBlockStatement(e),t)}function ze(){var e,n;return n=g,(e=ee()).type!==t.Identifier&&oe(e),m.markEnd(m.createIdentifier(e.value),n)}function Be(e){var t,n,r=null;return n=g,t=ze(),c&&$(t.name)&&ie({},i.StrictVarName),"const"===e?(ue("="),r=De()):ce("=")&&(ee(),r=De()),m.markEnd(m.createVariableDeclarator(t,r),n)}function Pe(e){var t=[];do{if(t.push(Be(e)),!ce(","))break;ee()}while(h<f);return t}function Ve(){var e;return le("var"),e=Pe(),de(),m.createVariableDeclaration(e,"var")}function We(e){var t,n;return n=g,le(e),t=Pe(e),de(),m.markEnd(m.createVariableDeclaration(t,e),n)}function Ue(){return ue(";"),m.createEmptyStatement()}function Ge(){var e=Oe();return de(),m.createExpressionStatement(e)}function je(){var e,t,n;return le("if"),ue("("),e=Oe(),ue(")"),t=it(),he("else")?(ee(),n=it()):n=null,m.createIfStatement(e,t,n)}function He(){var e,t,n;return le("do"),n=y.inIteration,y.inIteration=!0,e=it(),y.inIteration=n,le("while"),ue("("),t=Oe(),ue(")"),ce(";")&&ee(),m.createDoWhileStatement(e,t)}function qe(){var e,t,n;return le("while"),ue("("),e=Oe(),ue(")"),n=y.inIteration,y.inIteration=!0,t=it(),y.inIteration=n,m.createWhileStatement(e,t)}function Ke(){var e,t,n;return n=g,e=ee(),t=Pe(),m.markEnd(m.createVariableDeclaration(t,e.value),n)}function Xe(){var e,t,n,r,s,a,o,u=y.allowIn;return e=t=n=null,le("for"),ue("("),ce(";")?ee():(he("var")||he("let")?(y.allowIn=!1,e=Ke(),y.allowIn=u,1===e.declarations.length&&he("in")&&(ee(),r=e,s=Oe(),e=null)):(y.allowIn=!1,e=Oe(),y.allowIn=u,he("in")&&(fe(e)||ie({},i.InvalidLHSInForIn),ee(),r=e,s=Oe(),e=null)),void 0===r&&ue(";")),void 0===r&&(ce(";")||(t=Oe()),ue(";"),ce(")")||(n=Oe())),ue(")"),o=y.inIteration,y.inIteration=!0,a=it(),y.inIteration=o,void 0===r?m.createForStatement(e,t,n,a):m.createForInStatement(r,s,a)}function Ye(){var e,n=null;return le("continue"),59===l.charCodeAt(h)?(ee(),y.inIteration||ae({},i.IllegalContinue),m.createContinueStatement(null)):se()?(y.inIteration||ae({},i.IllegalContinue),m.createContinueStatement(null)):(g.type===t.Identifier&&(e="$"+(n=ze()).name,Object.prototype.hasOwnProperty.call(y.labelSet,e)||ae({},i.UnknownLabel,n.name)),de(),null!==n||y.inIteration||ae({},i.IllegalContinue),m.createContinueStatement(n))}function Je(){var e,n=null;return le("break"),59===l.charCodeAt(h)?(ee(),y.inIteration||y.inSwitch||ae({},i.IllegalBreak),m.createBreakStatement(null)):se()?(y.inIteration||y.inSwitch||ae({},i.IllegalBreak),m.createBreakStatement(null)):(g.type===t.Identifier&&(e="$"+(n=ze()).name,Object.prototype.hasOwnProperty.call(y.labelSet,e)||ae({},i.UnknownLabel,n.name)),de(),null!==n||y.inIteration||y.inSwitch||ae({},i.IllegalBreak),m.createBreakStatement(n))}function Ze(){var e=null;return le("return"),y.inFunctionBody||ie({},i.IllegalReturn),32===l.charCodeAt(h)&&S(l.charCodeAt(h+1))?(e=Oe(),de(),m.createReturnStatement(e)):se()?m.createReturnStatement(null):(ce(";")||ce("}")||g.type===t.EOF||(e=Oe()),de(),m.createReturnStatement(e))}function Qe(){var e,t;return c&&(D(),ie({},i.StrictModeWith)),le("with"),ue("("),e=Oe(),ue(")"),t=it(),m.createWithStatement(e,t)}function et(){var e,t,n,r=[];for(n=g,he("default")?(ee(),e=null):(le("case"),e=Oe()),ue(":");h<f&&!(ce("}")||he("default")||he("case"));)t=it(),r.push(t);return m.markEnd(m.createSwitchCase(e,r),n)}function tt(){var e,t,n,r,s;if(le("switch"),ue("("),e=Oe(),ue(")"),ue("{"),t=[],ce("}"))return ee(),m.createSwitchStatement(e,t);for(r=y.inSwitch,y.inSwitch=!0,s=!1;h<f&&!ce("}");)null===(n=et()).test&&(s&&ae({},i.MultipleDefaultsInSwitch),s=!0),t.push(n);return y.inSwitch=r,ue("}"),m.createSwitchStatement(e,t)}function nt(){var e;return le("throw"),se()&&ae({},i.NewlineAfterThrow),e=Oe(),de(),m.createThrowStatement(e)}function rt(){var e,t,n;return n=g,le("catch"),ue("("),ce(")")&&oe(g),e=ze(),c&&$(e.name)&&ie({},i.StrictCatchVariable),ue(")"),t=Le(),m.markEnd(m.createCatchClause(e,t),n)}function st(){var e,t=[],n=null;return le("try"),e=Le(),he("catch")&&t.push(rt()),he("finally")&&(ee(),n=Le()),0!==t.length||n||ae({},i.NoCatchOrFinally),m.createTryStatement(e,[],t,n)}function at(){return le("debugger"),de(),m.createDebuggerStatement()}function it(){var e,n,r,a,o=g.type;if(o===t.EOF&&oe(g),o===t.Punctuator&&"{"===g.value)return Le();if(a=g,o===t.Punctuator)switch(g.value){case";":return m.markEnd(Ue(),a);case"(":return m.markEnd(Ge(),a)}if(o===t.Keyword)switch(g.value){case"break":return m.markEnd(Je(),a);case"continue":return m.markEnd(Ye(),a);case"debugger":return m.markEnd(at(),a);case"do":return m.markEnd(He(),a);case"for":return m.markEnd(Xe(),a);case"function":return m.markEnd(lt(),a);case"if":return m.markEnd(je(),a);case"return":return m.markEnd(Ze(),a);case"switch":return m.markEnd(tt(),a);case"throw":return m.markEnd(nt(),a);case"try":return m.markEnd(st(),a);case"var":return m.markEnd(Ve(),a);case"while":return m.markEnd(qe(),a);case"with":return m.markEnd(Qe(),a)}return(e=Oe()).type===s.Identifier&&ce(":")?(ee(),r="$"+e.name,Object.prototype.hasOwnProperty.call(y.labelSet,r)&&ae({},i.Redeclaration,"Label",e.name),y.labelSet[r]=!0,n=it(),delete y.labelSet[r],m.markEnd(m.createLabeledStatement(e,n),a)):(de(),m.markEnd(m.createExpressionStatement(e),a))}function ot(){var e,n,r,a,o,u,p,d,b=[];for(d=g,ue("{");h<f&&g.type===t.StringLiteral&&(n=g,e=ht(),b.push(e),e.expression.type===s.Literal);)"use strict"===l.slice(n.start+1,n.end-1)?(c=!0,r&&ie(r,i.StrictOctalLiteral)):!r&&n.octal&&(r=n);for(a=y.labelSet,o=y.inIteration,u=y.inSwitch,p=y.inFunctionBody,y.labelSet={},y.inIteration=!1,y.inSwitch=!1,y.inFunctionBody=!0;h<f&&!ce("}")&&void 0!==(e=ht());)b.push(e);return ue("}"),y.labelSet=a,y.inIteration=o,y.inSwitch=u,y.inFunctionBody=p,m.markEnd(m.createBlockStatement(b),d)}function ut(e){var t,n,r,s,a,o,u=[];if(ue("("),!ce(")"))for(s={};h<f&&(n=g,t=ze(),a="$"+n.value,c?($(n.value)&&(r=n,o=i.StrictParamName),Object.prototype.hasOwnProperty.call(s,a)&&(r=n,o=i.StrictParamDupe)):e||($(n.value)?(e=n,o=i.StrictParamName):T(n.value)?(e=n,o=i.StrictReservedWord):Object.prototype.hasOwnProperty.call(s,a)&&(e=n,o=i.StrictParamDupe)),u.push(t),s[a]=!0,!ce(")"));)ue(",");return ue(")"),{params:u,stricted:r,firstRestricted:e,message:o}}function lt(){var e,t,n,r,s,a,o,u,l,h=[];return l=g,le("function"),n=g,e=ze(),c?$(n.value)&&ie(n,i.StrictFunctionName):$(n.value)?(a=n,o=i.StrictFunctionName):T(n.value)&&(a=n,o=i.StrictReservedWord),h=(s=ut(a)).params,r=s.stricted,a=s.firstRestricted,s.message&&(o=s.message),u=c,t=ot(),c&&a&&ae(a,o),c&&r&&ie(r,o),c=u,m.markEnd(m.createFunctionDeclaration(e,h,[],t),l)}function ct(){var e,t,n,r,s,a,o,u,l=null,h=[];return u=g,le("function"),ce("(")||(e=g,l=ze(),c?$(e.value)&&ie(e,i.StrictFunctionName):$(e.value)?(n=e,r=i.StrictFunctionName):T(e.value)&&(n=e,r=i.StrictReservedWord)),h=(s=ut(n)).params,t=s.stricted,n=s.firstRestricted,s.message&&(r=s.message),o=c,a=ot(),c&&n&&ae(n,r),c&&t&&ie(t,r),c=o,m.markEnd(m.createFunctionExpression(l,h,[],a),u)}function ht(){if(g.type===t.Keyword)switch(g.value){case"const":case"let":return We(g.value);case"function":return lt();default:return it()}if(g.type!==t.EOF)return it()}function pt(){for(var e,n,r,a=[];h<f&&(n=g).type===t.StringLiteral&&(e=ht(),a.push(e),e.expression.type===s.Literal);)"use strict"===l.slice(n.start+1,n.end-1)?(c=!0,r&&ie(r,i.StrictOctalLiteral)):!r&&n.octal&&(r=n);for(;h<f&&void 0!==(e=ht());)a.push(e);return a}function dt(){var e,t;return D(),te(),t=g,c=!1,e=pt(),m.markEnd(m.createProgram(e),t)}function ft(){var e,t,n,r=[];for(e=0;e<b.tokens.length;++e)n={type:(t=b.tokens[e]).type,value:t.value},b.range&&(n.range=t.range),b.loc&&(n.loc=t.loc),r.push(n);b.tokens=r}function mt(e,n){var r;"string"==typeof e||e instanceof String||(e=String(e)),m=u,h=0,p=(l=e).length>0?1:0,d=0,f=l.length,g=null,y={allowIn:!0,labelSet:{},inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},b={},(n=n||{}).tokens=!0,b.tokens=[],b.tokenize=!0,b.openParenToken=-1,b.openCurlyToken=-1,b.range="boolean"==typeof n.range&&n.range,b.loc="boolean"==typeof n.loc&&n.loc,"boolean"==typeof n.comment&&n.comment&&(b.comments=[]),"boolean"==typeof n.tolerant&&n.tolerant&&(b.errors=[]);try{if(te(),g.type===t.EOF)return b.tokens;for(ee();g.type!==t.EOF;)try{ee()}catch(e){if(g,b.errors){b.errors.push(e);break}throw e}ft(),r=b.tokens,void 0!==b.comments&&(r.comments=b.comments),void 0!==b.errors&&(r.errors=b.errors)}catch(e){throw e}finally{b={}}return r}function gt(e,t){var n,r;r=String,"string"==typeof e||e instanceof String||(e=r(e)),m=u,h=0,p=(l=e).length>0?1:0,d=0,f=l.length,g=null,y={allowIn:!0,labelSet:{},inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},b={},void 0!==t&&(b.range="boolean"==typeof t.range&&t.range,b.loc="boolean"==typeof t.loc&&t.loc,b.attachComment="boolean"==typeof t.attachComment&&t.attachComment,b.loc&&null!==t.source&&void 0!==t.source&&(b.source=r(t.source)),"boolean"==typeof t.tokens&&t.tokens&&(b.tokens=[]),"boolean"==typeof t.comment&&t.comment&&(b.comments=[]),"boolean"==typeof t.tolerant&&t.tolerant&&(b.errors=[]),b.attachComment&&(b.range=!0,b.comments=[],b.bottomRightStack=[],b.trailingComments=[],b.leadingComments=[]));try{n=dt(),void 0!==b.comments&&(n.comments=b.comments),void 0!==b.tokens&&(ft(),n.tokens=b.tokens),void 0!==b.errors&&(n.errors=b.errors)}catch(e){throw e}finally{b={}}return n}(n={})[(t={BooleanLiteral:1,EOF:2,Identifier:3,Keyword:4,NullLiteral:5,NumericLiteral:6,Punctuator:7,StringLiteral:8,RegularExpression:9}).BooleanLiteral]="Boolean",n[t.EOF]="<end>",n[t.Identifier]="Identifier",n[t.Keyword]="Keyword",n[t.NullLiteral]="Null",n[t.NumericLiteral]="Numeric",n[t.Punctuator]="Punctuator",n[t.StringLiteral]="String",n[t.RegularExpression]="RegularExpression",r=["(","{","[","in","typeof","instanceof","new","return","case","delete","throw","void","=","+=","-=","*=","/=","%=","<<=",">>=",">>>=","&=","|=","^=",",","+","-","*","/","%","++","--","<<",">>",">>>","&","|","^","!","~","&&","||","?",":","===","==",">=","<=","<",">","!=","!=="],s={AssignmentExpression:"AssignmentExpression",ArrayExpression:"ArrayExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DoWhileStatement:"DoWhileStatement",DebuggerStatement:"DebuggerStatement",EmptyStatement:"EmptyStatement",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",Identifier:"Identifier",IfStatement:"IfStatement",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",Program:"Program",Property:"Property",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement"},a={Data:1,Get:2,Set:4},i={UnexpectedToken:"Unexpected token %0",UnexpectedNumber:"Unexpected number",UnexpectedString:"Unexpected string",UnexpectedIdentifier:"Unexpected identifier",UnexpectedReserved:"Unexpected reserved word",UnexpectedEOS:"Unexpected end of input",NewlineAfterThrow:"Illegal newline after throw",InvalidRegExp:"Invalid regular expression",UnterminatedRegExp:"Invalid regular expression: missing /",InvalidLHSInAssignment:"Invalid left-hand side in assignment",InvalidLHSInForIn:"Invalid left-hand side in for-in",MultipleDefaultsInSwitch:"More than one default clause in switch statement",NoCatchOrFinally:"Missing catch or finally after try",UnknownLabel:"Undefined label '%0'",Redeclaration:"%0 '%1' has already been declared",IllegalContinue:"Illegal continue statement",IllegalBreak:"Illegal break statement",IllegalReturn:"Illegal return statement",StrictModeWith:"Strict mode code may not include a with statement",StrictCatchVariable:"Catch variable may not be eval or arguments in strict mode",StrictVarName:"Variable name may not be eval or arguments in strict mode",StrictParamName:"Parameter name eval or arguments is not allowed in strict mode",StrictParamDupe:"Strict mode function may not have duplicate parameter names",StrictFunctionName:"Function name may not be eval or arguments in strict mode",StrictOctalLiteral:"Octal literals are not allowed in strict mode.",StrictDelete:"Delete of an unqualified identifier in strict mode.",StrictDuplicateProperty:"Duplicate data property in object literal not allowed in strict mode",AccessorDataProperty:"Object literal may not have data and accessor property with the same name",AccessorGetSet:"Object literal may not have multiple get/set accessors with the same name",StrictLHSAssignment:"Assignment to eval or arguments is not allowed in strict mode",StrictLHSPostfix:"Postfix increment/decrement may not have eval or arguments operand in strict mode",StrictLHSPrefix:"Prefix increment/decrement may not have eval or arguments operand in strict mode",StrictReservedWord:"Use of future reserved word in strict mode"},o={NonAsciiIdentifierStart:new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),NonAsciiIdentifierPart:new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")},u={name:"SyntaxTree",processComment:function(e){var t,n;if(!(e.type===s.Program&&e.body.length>0)){for(b.trailingComments.length>0?b.trailingComments[0].range[0]>=e.range[1]?(n=b.trailingComments,b.trailingComments=[]):b.trailingComments.length=0:b.bottomRightStack.length>0&&b.bottomRightStack[b.bottomRightStack.length-1].trailingComments&&b.bottomRightStack[b.bottomRightStack.length-1].trailingComments[0].range[0]>=e.range[1]&&(n=b.bottomRightStack[b.bottomRightStack.length-1].trailingComments,delete b.bottomRightStack[b.bottomRightStack.length-1].trailingComments);b.bottomRightStack.length>0&&b.bottomRightStack[b.bottomRightStack.length-1].range[0]>=e.range[0];)t=b.bottomRightStack.pop();t?t.leadingComments&&t.leadingComments[t.leadingComments.length-1].range[1]<=e.range[0]&&(e.leadingComments=t.leadingComments,delete t.leadingComments):b.leadingComments.length>0&&b.leadingComments[b.leadingComments.length-1].range[1]<=e.range[0]&&(e.leadingComments=b.leadingComments,b.leadingComments=[]),n&&(e.trailingComments=n),b.bottomRightStack.push(e)}},markEnd:function(e,t){return b.range&&(e.range=[t.start,h]),b.loc&&(e.loc=new re(void 0===t.startLineNumber?t.lineNumber:t.startLineNumber,t.start-(void 0===t.startLineStart?t.lineStart:t.startLineStart),p,h-d),this.postProcess(e)),b.attachComment&&this.processComment(e),e},postProcess:function(e){return b.source&&(e.loc.source=b.source),e},createArrayExpression:function(e){return{type:s.ArrayExpression,elements:e}},createAssignmentExpression:function(e,t,n){return{type:s.AssignmentExpression,operator:e,left:t,right:n}},createBinaryExpression:function(e,t,n){return{type:"||"===e||"&&"===e?s.LogicalExpression:s.BinaryExpression,operator:e,left:t,right:n}},createBlockStatement:function(e){return{type:s.BlockStatement,body:e}},createBreakStatement:function(e){return{type:s.BreakStatement,label:e}},createCallExpression:function(e,t){return{type:s.CallExpression,callee:e,arguments:t}},createCatchClause:function(e,t){return{type:s.CatchClause,param:e,body:t}},createConditionalExpression:function(e,t,n){return{type:s.ConditionalExpression,test:e,consequent:t,alternate:n}},createContinueStatement:function(e){return{type:s.ContinueStatement,label:e}},createDebuggerStatement:function(){return{type:s.DebuggerStatement}},createDoWhileStatement:function(e,t){return{type:s.DoWhileStatement,body:e,test:t}},createEmptyStatement:function(){return{type:s.EmptyStatement}},createExpressionStatement:function(e){return{type:s.ExpressionStatement,expression:e}},createForStatement:function(e,t,n,r){return{type:s.ForStatement,init:e,test:t,update:n,body:r}},createForInStatement:function(e,t,n){return{type:s.ForInStatement,left:e,right:t,body:n,each:!1}},createFunctionDeclaration:function(e,t,n,r){return{type:s.FunctionDeclaration,id:e,params:t,defaults:n,body:r,rest:null,generator:!1,expression:!1}},createFunctionExpression:function(e,t,n,r){return{type:s.FunctionExpression,id:e,params:t,defaults:n,body:r,rest:null,generator:!1,expression:!1}},createIdentifier:function(e){return{type:s.Identifier,name:e}},createIfStatement:function(e,t,n){return{type:s.IfStatement,test:e,consequent:t,alternate:n}},createLabeledStatement:function(e,t){return{type:s.LabeledStatement,label:e,body:t}},createLiteral:function(e){return{type:s.Literal,value:e.value,raw:l.slice(e.start,e.end)}},createMemberExpression:function(e,t,n){return{type:s.MemberExpression,computed:"["===e,object:t,property:n}},createNewExpression:function(e,t){return{type:s.NewExpression,callee:e,arguments:t}},createObjectExpression:function(e){return{type:s.ObjectExpression,properties:e}},createPostfixExpression:function(e,t){return{type:s.UpdateExpression,operator:e,argument:t,prefix:!1}},createProgram:function(e){return{type:s.Program,body:e}},createProperty:function(e,t,n){return{type:s.Property,key:t,value:n,kind:e}},createReturnStatement:function(e){return{type:s.ReturnStatement,argument:e}},createSequenceExpression:function(e){return{type:s.SequenceExpression,expressions:e}},createSwitchCase:function(e,t){return{type:s.SwitchCase,test:e,consequent:t}},createSwitchStatement:function(e,t){return{type:s.SwitchStatement,discriminant:e,cases:t}},createThisExpression:function(){return{type:s.ThisExpression}},createThrowStatement:function(e){return{type:s.ThrowStatement,argument:e}},createTryStatement:function(e,t,n,r){return{type:s.TryStatement,block:e,guardedHandlers:t,handlers:n,finalizer:r}},createUnaryExpression:function(e,t){return"++"===e||"--"===e?{type:s.UpdateExpression,operator:e,argument:t,prefix:!0}:{type:s.UnaryExpression,operator:e,argument:t,prefix:!0}},createVariableDeclaration:function(e,t){return{type:s.VariableDeclaration,declarations:e,kind:t}},createVariableDeclarator:function(e,t){return{type:s.VariableDeclarator,id:e,init:t}},createWhileStatement:function(e,t){return{type:s.WhileStatement,test:e,body:t}},createWithStatement:function(e,t){return{type:s.WithStatement,object:e,body:t}}},e.version="1.2.5",e.tokenize=mt,e.parse=gt,e.Syntax=function(){var e,t={};for(e in"function"==typeof Object.create&&(t=Object.create(null)),s)s.hasOwnProperty(e)&&(t[e]=s[e]);return"function"==typeof Object.freeze&&Object.freeze(t),t}()})?n.apply(t,r):n)||(e.exports=s)}()},780:function(e,t,n){"use strict";var r=n(615),s=n(239),a=["args","body"],i=["pre","post","printCode","funcName","blockSize"];e.exports=function(e){for(var t in e)a.indexOf(t)<0&&i.indexOf(t)<0&&console.warn("cwise: Unknown argument '"+t+"' passed to expression compiler");for(var n=0;n<a.length;++n)if(!e[a[n]])throw new Error("cwise: Missing argument: "+a[n]);return s({args:e.args,pre:r(e.pre||function(){}),body:r(e.body),post:r(e.post||function(){}),debug:!!e.printCode,funcName:e.funcName||e.body.name||"cwise",blockSize:e.blockSize||64})}},841:function(e){"use strict";function t(e,n,r){var s=0|e[r];if(s<=0)return[];var a,i=new Array(s);if(r===e.length-1)for(a=0;a<s;++a)i[a]=n;else for(a=0;a<s;++a)i[a]=t(e,n,r+1);return i}e.exports=function(e,n){switch(void 0===n&&(n=0),typeof e){case"number":if(e>0)return function(e,t){var n,r;for(n=new Array(e),r=0;r<e;++r)n[r]=t;return n}(0|e,n);break;case"object":if("number"==typeof e.length)return t(e,n,0)}return[]}},65:function(e){"use strict";function t(e){if(this.size=0|e,this.size<=1||0!=(this.size&this.size-1))throw new Error("FFT size must be a power of two and bigger than 1");this._csize=e<<1;for(var t=new Array(2*this.size),n=0;n<t.length;n+=2){const e=Math.PI*n/this.size;t[n]=Math.cos(e),t[n+1]=-Math.sin(e)}this.table=t;for(var r=0,s=1;this.size>s;s<<=1)r++;this._width=r%2==0?r-1:r,this._bitrev=new Array(1<<this._width);for(var a=0;a<this._bitrev.length;a++){this._bitrev[a]=0;for(var i=0;i<this._width;i+=2){var o=this._width-i-2;this._bitrev[a]|=(a>>>i&3)<<o}}this._out=null,this._data=null,this._inv=0}e.exports=t,t.prototype.fromComplexArray=function(e,t){for(var n=t||new Array(e.length>>>1),r=0;r<e.length;r+=2)n[r>>>1]=e[r];return n},t.prototype.createComplexArray=function(){const e=new Array(this._csize);for(var t=0;t<e.length;t++)e[t]=0;return e},t.prototype.toComplexArray=function(e,t){for(var n=t||this.createComplexArray(),r=0;r<n.length;r+=2)n[r]=e[r>>>1],n[r+1]=0;return n},t.prototype.completeSpectrum=function(e){for(var t=this._csize,n=t>>>1,r=2;r<n;r+=2)e[t-r]=e[r],e[t-r+1]=-e[r+1]},t.prototype.transform=function(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._out=e,this._data=t,this._inv=0,this._transform4(),this._out=null,this._data=null},t.prototype.realTransform=function(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._out=e,this._data=t,this._inv=0,this._realTransform4(),this._out=null,this._data=null},t.prototype.inverseTransform=function(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._out=e,this._data=t,this._inv=1,this._transform4();for(var n=0;n<e.length;n++)e[n]/=this.size;this._out=null,this._data=null},t.prototype._transform4=function(){var e,t,n=this._out,r=this._csize,s=1<<this._width,a=r/s<<1,i=this._bitrev;if(4===a)for(e=0,t=0;e<r;e+=a,t++){const n=i[t];this._singleTransform2(e,n,s)}else for(e=0,t=0;e<r;e+=a,t++){const n=i[t];this._singleTransform4(e,n,s)}var o=this._inv?-1:1,u=this.table;for(s>>=2;s>=2;s>>=2){var l=(a=r/s<<1)>>>2;for(e=0;e<r;e+=a)for(var c=e+l,h=e,p=0;h<c;h+=2,p+=s){const e=h,t=e+l,r=t+l,s=r+l,a=n[e],i=n[e+1],c=n[t],d=n[t+1],f=n[r],m=n[r+1],g=n[s],y=n[s+1],b=a,x=i,w=u[p],v=o*u[p+1],k=c*w-d*v,I=c*v+d*w,N=u[2*p],S=o*u[2*p+1],C=f*N-m*S,E=f*S+m*N,T=u[3*p],$=o*u[3*p+1],A=g*T-y*$,R=g*$+y*T,_=b+C,F=x+E,D=b-C,O=x-E,M=k+A,L=I+R,z=o*(k-A),B=o*(I-R),P=_+M,V=F+L,W=_-M,U=F-L,G=D+B,j=O-z,H=D-B,q=O+z;n[e]=P,n[e+1]=V,n[t]=G,n[t+1]=j,n[r]=W,n[r+1]=U,n[s]=H,n[s+1]=q}}},t.prototype._singleTransform2=function(e,t,n){const r=this._out,s=this._data,a=s[t],i=s[t+1],o=s[t+n],u=s[t+n+1],l=a+o,c=i+u,h=a-o,p=i-u;r[e]=l,r[e+1]=c,r[e+2]=h,r[e+3]=p},t.prototype._singleTransform4=function(e,t,n){const r=this._out,s=this._data,a=this._inv?-1:1,i=2*n,o=3*n,u=s[t],l=s[t+1],c=s[t+n],h=s[t+n+1],p=s[t+i],d=s[t+i+1],f=s[t+o],m=s[t+o+1],g=u+p,y=l+d,b=u-p,x=l-d,w=c+f,v=h+m,k=a*(c-f),I=a*(h-m),N=g+w,S=y+v,C=b+I,E=x-k,T=g-w,$=y-v,A=b-I,R=x+k;r[e]=N,r[e+1]=S,r[e+2]=C,r[e+3]=E,r[e+4]=T,r[e+5]=$,r[e+6]=A,r[e+7]=R},t.prototype._realTransform4=function(){var e,t,n=this._out,r=this._csize,s=1<<this._width,a=r/s<<1,i=this._bitrev;if(4===a)for(e=0,t=0;e<r;e+=a,t++){const n=i[t];this._singleRealTransform2(e,n>>>1,s>>>1)}else for(e=0,t=0;e<r;e+=a,t++){const n=i[t];this._singleRealTransform4(e,n>>>1,s>>>1)}var o=this._inv?-1:1,u=this.table;for(s>>=2;s>=2;s>>=2){var l=(a=r/s<<1)>>>1,c=l>>>1,h=c>>>1;for(e=0;e<r;e+=a)for(var p=0,d=0;p<=h;p+=2,d+=s){var f=e+p,m=f+c,g=m+c,y=g+c,b=n[f],x=n[f+1],w=n[m],v=n[m+1],k=n[g],I=n[g+1],N=n[y],S=n[y+1],C=b,E=x,T=u[d],$=o*u[d+1],A=w*T-v*$,R=w*$+v*T,_=u[2*d],F=o*u[2*d+1],D=k*_-I*F,O=k*F+I*_,M=u[3*d],L=o*u[3*d+1],z=N*M-S*L,B=N*L+S*M,P=C+D,V=E+O,W=C-D,U=E-O,G=A+z,j=R+B,H=o*(A-z),q=o*(R-B),K=P+G,X=V+j,Y=W+q,J=U-H;if(n[f]=K,n[f+1]=X,n[m]=Y,n[m+1]=J,0!==p){if(p!==h){var Z=W+-o*q,Q=-U+-o*H,ee=P+-o*G,te=-V- -o*j,ne=e+c-p,re=e+l-p;n[ne]=Z,n[ne+1]=Q,n[re]=ee,n[re+1]=te}}else{var se=P-G,ae=V-j;n[g]=se,n[g+1]=ae}}}},t.prototype._singleRealTransform2=function(e,t,n){const r=this._out,s=this._data,a=s[t],i=s[t+n],o=a+i,u=a-i;r[e]=o,r[e+1]=0,r[e+2]=u,r[e+3]=0},t.prototype._singleRealTransform4=function(e,t,n){const r=this._out,s=this._data,a=this._inv?-1:1,i=2*n,o=3*n,u=s[t],l=s[t+n],c=s[t+i],h=s[t+o],p=u+c,d=u-c,f=l+h,m=a*(l-h),g=p+f,y=d,b=-m,x=p-f,w=d,v=m;r[e]=g,r[e+1]=0,r[e+2]=y,r[e+3]=b,r[e+4]=x,r[e+5]=0,r[e+6]=w,r[e+7]=v}},645:function(e,t){t.read=function(e,t,n,r,s){var a,i,o=8*s-r-1,u=(1<<o)-1,l=u>>1,c=-7,h=n?s-1:0,p=n?-1:1,d=e[t+h];for(h+=p,a=d&(1<<-c)-1,d>>=-c,c+=o;c>0;a=256*a+e[t+h],h+=p,c-=8);for(i=a&(1<<-c)-1,a>>=-c,c+=r;c>0;i=256*i+e[t+h],h+=p,c-=8);if(0===a)a=1-l;else{if(a===u)return i?NaN:1/0*(d?-1:1);i+=Math.pow(2,r),a-=l}return(d?-1:1)*i*Math.pow(2,a-r)},t.write=function(e,t,n,r,s,a){var i,o,u,l=8*a-s-1,c=(1<<l)-1,h=c>>1,p=23===s?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:a-1,f=r?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=c):(i=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-i))<1&&(i--,u*=2),(t+=i+h>=1?p/u:p*Math.pow(2,1-h))*u>=2&&(i++,u/=2),i+h>=c?(o=0,i=c):i+h>=1?(o=(t*u-1)*Math.pow(2,s),i+=h):(o=t*Math.pow(2,h-1)*Math.pow(2,s),i=0));s>=8;e[n+d]=255&o,d+=f,o/=256,s-=8);for(i=i<<s|o,l+=s;l>0;e[n+d]=255&i,d+=f,i/=256,l-=8);e[n+d-f]|=128*m}},907:function(e){"use strict";e.exports=function(e){for(var t=new Array(e),n=0;n<e;++n)t[n]=n;return t}},738:function(e){function t(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}e.exports=function(e){return null!=e&&(t(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&t(e.slice(0,0))}(e)||!!e._isBuffer)}},587:function(e,t,n){"use strict";var r=n(897),s=n(861),a=n(316),i=n(82);e.exports=function(e,t,n){var o,u,l=t.shape,c=l.length,h=1,p=new Array(c),d=0;for(o=c-1;o>=0;--o)if(p[o]=h,h*=l[o],d=Math.max(d,i.scratchMemory(l[o])),t.shape[o]!==n.shape[o])throw new Error("Shape mismatch, real and imaginary arrays must have same size");var f,m=4*h+d;f="array"===t.dtype||"float64"===t.dtype||"custom"===t.dtype?a.mallocDouble(m):a.mallocFloat(m);var g,y,b,x,w=s(f,l.slice(0),p,0),v=s(f,l.slice(0),p.slice(0),h),k=s(f,l.slice(0),p.slice(0),2*h),I=s(f,l.slice(0),p.slice(0),3*h),N=4*h;for(r.assign(w,t),r.assign(v,n),o=c-1;o>=0&&(i(e,h/l[o],l[o],f,w.offset,v.offset,N),0!==o);--o){for(y=1,b=k.stride,x=I.stride,u=o-1;u<c;++u)x[u]=b[u]=y,y*=l[u];for(u=o-2;u>=0;--u)x[u]=b[u]=y,y*=l[u];r.assign(k,w),r.assign(I,v),g=w,w=k,k=g,g=v,v=I,I=g}r.assign(t,w),r.assign(n,v),a.free(f)}},82:function(e,t,n){var r=n(746);function s(e,t,n,s,a,i){var o,u,l,c,h,p,d,f,m,g,y,b,x,w,v,k,I,N,S,C,E,T,$,A;for(e|=0,t|=0,a|=0,i|=0,o=n|=0,u=r.log2(o),N=0;N<t;++N){for(d=o>>1,h=0,l=0;l<o-1;l++){for(l<h&&(x=s[a+l],s[a+l]=s[a+h],s[a+h]=x,x=s[i+l],s[i+l]=s[i+h],s[i+h]=x),p=d;p<=h;)h-=p,p>>=1;h+=p}for(y=-1,b=0,g=1,f=0;f<u;f++){for(m=g,g<<=1,k=1,I=0,h=0;h<m;h++){for(l=h;l<o;l+=g)S=s[a+(c=l+m)],C=s[i+c],E=s[a+l],T=s[i+l],w=($=k*(S+C))-C*(k+I),v=$+(A=S*(I-k)),s[a+c]=E-w,s[i+c]=T-v,s[a+l]+=w,s[i+l]+=v;A=k*(b-y),k=($=y*(k+I))-I*(y+b),I=$+A}b=Math.sqrt((1-y)/2),e<0&&(b=-b),y=Math.sqrt((1+y)/2)}if(e<0){var R=1/o;for(l=0;l<o;l++)s[a+l]*=R,s[i+l]*=R}a+=n,i+=n}}e.exports=function(e,t,n,a,i,o,u){e|=0,t|=0,n|=0,i|=0,o|=0,r.isPow2(n)?s(e,t,n,a,i,o):function(e,t,n,a,i,o,u){e|=0,t|=0,n|=0,i|=0,o|=0,u|=0;var l,c,h,p,d,f,m,g,y,b=r.nextPow2(2*n+1),x=u,w=x+n,v=w+n,k=v+b,I=k+b,N=I+b,S=-e*Math.PI/n;for(y=0;y<n;++y)c=S*(y*y%(2*n)),p=Math.cos(c),d=Math.sin(c),a[I+(b-y)]=a[I+y]=a[x+y]=p,a[N+(b-y)]=a[N+y]=a[w+y]=d;for(y=n;y<=b-n;++y)a[I+y]=0;for(y=n;y<=b-n;++y)a[N+y]=0;s(1,1,b,a,I,N),S=e<0?1/n:1;for(l=0;l<t;++l){for(y=0;y<n;++y)c=a[i+y],h=a[o+y],f=(p=a[x+y])*(c+h),m=c*((d=-a[w+y])-p),g=h*(p+d),a[v+y]=f-g,a[k+y]=f+m;for(y=n;y<b;++y)a[v+y]=0;for(y=n;y<b;++y)a[k+y]=0;for(s(1,1,b,a,v,k),y=0;y<b;++y)c=a[v+y],h=a[k+y],f=(p=a[I+y])*(c+h),m=c*((d=a[N+y])-p),g=h*(p+d),a[v+y]=f-g,a[k+y]=f+m;for(s(-1,1,b,a,v,k),y=0;y<n;++y)c=a[v+y],h=a[k+y],f=(p=a[x+y])*(c+h),m=c*((d=-a[w+y])-p),g=h*(p+d),a[i+y]=S*(f-g),a[o+y]=S*(f+m);i+=n,o+=n}}(e,t,n,a,i,o,u)},e.exports.scratchMemory=function(e){return r.isPow2(e)?0:2*e+4*r.nextPow2(2*e+1)}},897:function(e,t,n){"use strict";var r=n(239),s={body:"",args:[],thisVars:[],localVars:[]};function a(e){if(!e)return s;for(var t=0;t<e.args.length;++t){var n=e.args[t];e.args[t]=0===t?{name:n,lvalue:!0,rvalue:!!e.rvalue,count:e.count||1}:{name:n,lvalue:!1,rvalue:!0,count:1}}return e.thisVars||(e.thisVars=[]),e.localVars||(e.localVars=[]),e}function i(e){for(var t=[],n=0;n<e.args.length;++n)t.push("a"+n);return new Function("P",["return function ",e.funcName,"_ndarrayops(",t.join(","),") {P(",t.join(","),");return a0}"].join(""))(function(e){return r({args:e.args,pre:a(e.pre),body:a(e.body),post:a(e.proc),funcName:e.funcName})}(e))}var o={add:"+",sub:"-",mul:"*",div:"/",mod:"%",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"};!function(){for(var e in o){var n=o[e];t[e]=i({args:["array","array","array"],body:{args:["a","b","c"],body:"a=b"+n+"c"},funcName:e}),t[e+"eq"]=i({args:["array","array"],body:{args:["a","b"],body:"a"+n+"=b"},rvalue:!0,funcName:e+"eq"}),t[e+"s"]=i({args:["array","array","scalar"],body:{args:["a","b","s"],body:"a=b"+n+"s"},funcName:e+"s"}),t[e+"seq"]=i({args:["array","scalar"],body:{args:["a","s"],body:"a"+n+"=s"},rvalue:!0,funcName:e+"seq"})}}();var u={not:"!",bnot:"~",neg:"-",recip:"1.0/"};!function(){for(var e in u){var n=u[e];t[e]=i({args:["array","array"],body:{args:["a","b"],body:"a="+n+"b"},funcName:e}),t[e+"eq"]=i({args:["array"],body:{args:["a"],body:"a="+n+"a"},rvalue:!0,count:2,funcName:e+"eq"})}}();var l={and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">="};!function(){for(var e in l){var n=l[e];t[e]=i({args:["array","array","array"],body:{args:["a","b","c"],body:"a=b"+n+"c"},funcName:e}),t[e+"s"]=i({args:["array","array","scalar"],body:{args:["a","b","s"],body:"a=b"+n+"s"},funcName:e+"s"}),t[e+"eq"]=i({args:["array","array"],body:{args:["a","b"],body:"a=a"+n+"b"},rvalue:!0,count:2,funcName:e+"eq"}),t[e+"seq"]=i({args:["array","scalar"],body:{args:["a","s"],body:"a=a"+n+"s"},rvalue:!0,count:2,funcName:e+"seq"})}}();var c=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan"];!function(){for(var e=0;e<c.length;++e){var n=c[e];t[n]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b)",thisVars:["this_f"]},funcName:n}),t[n+"eq"]=i({args:["array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a"],body:"a=this_f(a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"eq"})}}();var h=["max","min","atan2","pow"];!function(){for(var e=0;e<h.length;++e){var n=h[e];t[n]=i({args:["array","array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(b,c)",thisVars:["this_f"]},funcName:n}),t[n+"s"]=i({args:["array","array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(b,c)",thisVars:["this_f"]},funcName:n+"s"}),t[n+"eq"]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(a,b)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"eq"}),t[n+"seq"]=i({args:["array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(a,b)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"seq"})}}();var p=["atan2","pow"];!function(){for(var e=0;e<p.length;++e){var n=p[e];t[n+"op"]=i({args:["array","array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(c,b)",thisVars:["this_f"]},funcName:n+"op"}),t[n+"ops"]=i({args:["array","array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(c,b)",thisVars:["this_f"]},funcName:n+"ops"}),t[n+"opeq"]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b,a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"opeq"}),t[n+"opseq"]=i({args:["array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b,a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"opseq"})}}(),t.any=r({args:["array"],pre:s,body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"if(a){return true}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return false"},funcName:"any"}),t.all=r({args:["array"],pre:s,body:{args:[{name:"x",lvalue:!1,rvalue:!0,count:1}],body:"if(!x){return false}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return true"},funcName:"all"}),t.sum=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"this_s+=a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"sum"}),t.prod=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=1"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"this_s*=a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"prod"}),t.norm2squared=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:2}],body:"this_s+=a*a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norm2squared"}),t.norm2=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:2}],body:"this_s+=a*a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return Math.sqrt(this_s)"},funcName:"norm2"}),t.norminf=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:4}],body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norminf"}),t.norm1=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:3}],body:"this_s+=a<0?-a:a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norm1"}),t.sup=r({args:["array"],pre:{body:"this_h=-Infinity",args:[],thisVars:["this_h"],localVars:[]},body:{body:"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_h"],localVars:[]},post:{body:"return this_h",args:[],thisVars:["this_h"],localVars:[]}}),t.inf=r({args:["array"],pre:{body:"this_h=Infinity",args:[],thisVars:["this_h"],localVars:[]},body:{body:"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_h"],localVars:[]},post:{body:"return this_h",args:[],thisVars:["this_h"],localVars:[]}}),t.argmin=r({args:["index","array","shape"],pre:{body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",args:[{name:"_inline_0_arg0_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg1_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg2_",lvalue:!1,rvalue:!0,count:1}],thisVars:["this_i","this_v"],localVars:[]},body:{body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2},{name:"_inline_1_arg1_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_i","this_v"],localVars:["_inline_1_k"]},post:{body:"{return this_i}",args:[],thisVars:["this_i"],localVars:[]}}),t.argmax=r({args:["index","array","shape"],pre:{body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",args:[{name:"_inline_0_arg0_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg1_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg2_",lvalue:!1,rvalue:!0,count:1}],thisVars:["this_i","this_v"],localVars:[]},body:{body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2},{name:"_inline_1_arg1_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_i","this_v"],localVars:["_inline_1_k"]},post:{body:"{return this_i}",args:[],thisVars:["this_i"],localVars:[]}}),t.random=i({args:["array"],pre:{args:[],body:"this_f=Math.random",thisVars:["this_f"]},body:{args:["a"],body:"a=this_f()",thisVars:["this_f"]},funcName:"random"}),t.assign=i({args:["array","array"],body:{args:["a","b"],body:"a=b"},funcName:"assign"}),t.assigns=i({args:["array","scalar"],body:{args:["a","b"],body:"a=b"},funcName:"assigns"}),t.equals=r({args:["array","array"],pre:s,body:{args:[{name:"x",lvalue:!1,rvalue:!0,count:1},{name:"y",lvalue:!1,rvalue:!0,count:1}],body:"if(x!==y){return false}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return true"},funcName:"equals"})},906:function(e,t,n){"use strict";var r=n(587),s=n(219),a=n(897),i=n(780)({args:["array","array","scalar","scalar","scalar"],body:function(e,t,n,r,s){var a=t*n;a<r&&(a=r),a>s&&(a=s)}});e.exports=function(e,t,n,o){void 0===n&&(n=-1/0),void 0===o&&(o=1/0);var u=t.shape,l=e.shape;if(t.shape.length!==e.shape.length)throw new Error("ndarray-resample: input and output arrays should have the same dimensions");var c,h=u.map((function(){return 0}));if(1===e.size)return(c=a.sum(t)/t.size)<n&&(c=n),c>o&&(c=o),void e.set.apply(e,h.concat(c));if(1===t.size)return(c=t.get.apply(t,h))<n&&(c=n),c>o&&(c=o),void a.assigns(e,c);for(var p=u.length,d=new Array(p),f=!1,m=0;m<p;m++)d[m]=Math.min(l[m],u[m]),l[m]>u[m]&&(f=!0);var g=s.malloc(u),y=s.malloc(u);a.assign(g,t),a.assigns(y,0),r(1,g,y);var b=g.lo,x=g.hi,w=s.malloc(l),v=s.malloc(l);f&&(a.assigns(w,0),a.assigns(v,0));var k=new Array(p),I=new Array(p),N=new Array(p),S=new Array(p);for(m=0;m<1<<p;++m){for(var C=0;C<p;++C)if(m&1<<C){if(k[C]=d[C]-(d[C]+1>>>1),0===k[C])continue;I[C]=l[C]-k[C],N[C]=u[C]-k[C],S[C]=1&d[C]?0:1}else k[C]=d[C]+1>>>1,I[C]=0,N[C]=0,S[C]=0;a.assign(x.apply(b.apply(w,I),k),x.apply(b.apply(g,N),k)),a.assign(b.apply(x.apply(b.apply(v,I),k),S),b.apply(x.apply(b.apply(y,N),k),S)),a.assigns(x.apply(x.apply(b.apply(v,I),k),S),0)}r(-1,w,v),i(e,w,e.size/t.size,n,o),s.free(g),s.free(y),s.free(w),s.free(v)}},219:function(e,t,n){"use strict";var r=n(861),s=n(897),a=n(316);t.clone=function(e){var t=e.dtype;"generic"!==t&&"array"!==t||(t="double");var n=a.malloc(e.size,t),i=r(n,e.shape);return s.assign(i,e),i},t.malloc=function(e,t){t||(t="double");for(var n=1,s=new Array(e.length),i=e.length-1;i>=0;--i)s[i]=n,n*=e[i];return r(a.malloc(n,t),e,s,0)},t.free=function(e){"generic"!==e.dtype&&"array"!==e.dtype&&a.free(e.data)},t.zeros=function(e,t){t||(t="double");for(var n=1,s=new Array(e.length),i=e.length-1;i>=0;--i)s[i]=n,n*=e[i];var o=a.malloc(n,t);for(i=0;i<n;++i)o[i]=0;return r(o,e,s,0)},t.ones=function(e,t){t||(t="double");for(var n=1,s=new Array(e.length),i=e.length-1;i>=0;--i)s[i]=n,n*=e[i];var o=a.malloc(n,t);for(i=0;i<n;++i)o[i]=1;return r(o,e,s,0)},t.eye=function(e,t){var n,s;t||(t="double");var i=1,o=new Array(e.length);for(n=e.length-1;n>=0;--n)o[n]=i,i*=e[n];var u=a.malloc(i,t);for(n=0;n<i;++n)u[n]=0;var l=1/0,c=0;for(n=e.length-1;n>=0;n--)c+=o[n],l=Math.min(l,e[n]);for(n=0,s=0;n<l;n++,s+=c)u[s]=1;return r(u,e,o,0)}},861:function(e,t,n){var r=n(907),s=n(738),a="undefined"!=typeof Float64Array;function i(e,t){return e[0]-t[0]}function o(){var e,t=this.stride,n=new Array(t.length);for(e=0;e<n.length;++e)n[e]=[Math.abs(t[e]),e];n.sort(i);var r=new Array(n.length);for(e=0;e<r.length;++e)r[e]=n[e][1];return r}function u(e,t){var n=["View",t,"d",e].join("");t<0&&(n="View_Nil"+e);var s="generic"===e;if(-1===t){var a="function "+n+"(a){this.data=a;};var proto="+n+".prototype;proto.dtype='"+e+"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new "+n+"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_"+n+"(a){return new "+n+"(a);}";return new Function(a)()}if(0===t){a="function "+n+"(a,d) {this.data = a;this.offset = d};var proto="+n+".prototype;proto.dtype='"+e+"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function "+n+"_copy() {return new "+n+"(this.data,this.offset)};proto.pick=function "+n+"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function "+n+"_get(){return "+(s?"this.data.get(this.offset)":"this.data[this.offset]")+"};proto.set=function "+n+"_set(v){return "+(s?"this.data.set(this.offset,v)":"this.data[this.offset]=v")+"};return function construct_"+n+"(a,b,c,d){return new "+n+"(a,d)}";return new Function("TrivialArray",a)(l[e][0])}a=["'use strict'"];var i=r(t),u=i.map((function(e){return"i"+e})),c="this.offset+"+i.map((function(e){return"this.stride["+e+"]*i"+e})).join("+"),h=i.map((function(e){return"b"+e})).join(","),p=i.map((function(e){return"c"+e})).join(",");a.push("function "+n+"(a,"+h+","+p+",d){this.data=a","this.shape=["+h+"]","this.stride=["+p+"]","this.offset=d|0}","var proto="+n+".prototype","proto.dtype='"+e+"'","proto.dimension="+t),a.push("Object.defineProperty(proto,'size',{get:function "+n+"_size(){return "+i.map((function(e){return"this.shape["+e+"]"})).join("*"),"}})"),1===t?a.push("proto.order=[0]"):(a.push("Object.defineProperty(proto,'order',{get:"),t<4?(a.push("function "+n+"_order(){"),2===t?a.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"):3===t&&a.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")):a.push("ORDER})")),a.push("proto.set=function "+n+"_set("+u.join(",")+",v){"),s?a.push("return this.data.set("+c+",v)}"):a.push("return this.data["+c+"]=v}"),a.push("proto.get=function "+n+"_get("+u.join(",")+"){"),s?a.push("return this.data.get("+c+")}"):a.push("return this.data["+c+"]}"),a.push("proto.index=function "+n+"_index(",u.join(),"){return "+c+"}"),a.push("proto.hi=function "+n+"_hi("+u.join(",")+"){return new "+n+"(this.data,"+i.map((function(e){return["(typeof i",e,"!=='number'||i",e,"<0)?this.shape[",e,"]:i",e,"|0"].join("")})).join(",")+","+i.map((function(e){return"this.stride["+e+"]"})).join(",")+",this.offset)}");var d=i.map((function(e){return"a"+e+"=this.shape["+e+"]"})),f=i.map((function(e){return"c"+e+"=this.stride["+e+"]"}));a.push("proto.lo=function "+n+"_lo("+u.join(",")+"){var b=this.offset,d=0,"+d.join(",")+","+f.join(","));for(var m=0;m<t;++m)a.push("if(typeof i"+m+"==='number'&&i"+m+">=0){d=i"+m+"|0;b+=c"+m+"*d;a"+m+"-=d}");a.push("return new "+n+"(this.data,"+i.map((function(e){return"a"+e})).join(",")+","+i.map((function(e){return"c"+e})).join(",")+",b)}"),a.push("proto.step=function "+n+"_step("+u.join(",")+"){var "+i.map((function(e){return"a"+e+"=this.shape["+e+"]"})).join(",")+","+i.map((function(e){return"b"+e+"=this.stride["+e+"]"})).join(",")+",c=this.offset,d=0,ceil=Math.ceil");for(m=0;m<t;++m)a.push("if(typeof i"+m+"==='number'){d=i"+m+"|0;if(d<0){c+=b"+m+"*(a"+m+"-1);a"+m+"=ceil(-a"+m+"/d)}else{a"+m+"=ceil(a"+m+"/d)}b"+m+"*=d}");a.push("return new "+n+"(this.data,"+i.map((function(e){return"a"+e})).join(",")+","+i.map((function(e){return"b"+e})).join(",")+",c)}");var g=new Array(t),y=new Array(t);for(m=0;m<t;++m)g[m]="a[i"+m+"]",y[m]="b[i"+m+"]";a.push("proto.transpose=function "+n+"_transpose("+u+"){"+u.map((function(e,t){return e+"=("+e+"===undefined?"+t+":"+e+"|0)"})).join(";"),"var a=this.shape,b=this.stride;return new "+n+"(this.data,"+g.join(",")+","+y.join(",")+",this.offset)}"),a.push("proto.pick=function "+n+"_pick("+u+"){var a=[],b=[],c=this.offset");for(m=0;m<t;++m)a.push("if(typeof i"+m+"==='number'&&i"+m+">=0){c=(c+this.stride["+m+"]*i"+m+")|0}else{a.push(this.shape["+m+"]);b.push(this.stride["+m+"])}");return a.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),a.push("return function construct_"+n+"(data,shape,stride,offset){return new "+n+"(data,"+i.map((function(e){return"shape["+e+"]"})).join(",")+","+i.map((function(e){return"stride["+e+"]"})).join(",")+",offset)}"),new Function("CTOR_LIST","ORDER",a.join("\n"))(l[e],o)}var l={float32:[],float64:[],int8:[],int16:[],int32:[],uint8:[],uint16:[],uint32:[],array:[],uint8_clamped:[],bigint64:[],biguint64:[],buffer:[],generic:[]};e.exports=function(e,t,n,r){if(void 0===e)return(0,l.array[0])([]);"number"==typeof e&&(e=[e]),void 0===t&&(t=[e.length]);var i=t.length;if(void 0===n){n=new Array(i);for(var o=i-1,c=1;o>=0;--o)n[o]=c,c*=t[o]}if(void 0===r){r=0;for(o=0;o<i;++o)n[o]<0&&(r-=(t[o]-1)*n[o])}for(var h=function(e){if(s(e))return"buffer";if(a)switch(Object.prototype.toString.call(e)){case"[object Float64Array]":return"float64";case"[object Float32Array]":return"float32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Uint8ClampedArray]":return"uint8_clamped";case"[object BigInt64Array]":return"bigint64";case"[object BigUint64Array]":return"biguint64"}return Array.isArray(e)?"array":"generic"}(e),p=l[h];p.length<=i+1;)p.push(u(h,p.length-1));return(0,p[i+1])(e,t,n,r)}},377:function(e,t,n){var r=n(832),s=n(652),a=n(801),i=n(30),o=n(618),u=n(49),l=n(971);l.alea=r,l.xor128=s,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=u,e.exports=l},832:function(e,t,n){var r;!function(e,s,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new i(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.alea=u}(0,e=n.nmd(e),n.amdD)},49:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.tychei=u}(0,e=n.nmd(e),n.amdD)},652:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xor128=u}(0,e=n.nmd(e),n.amdD)},618:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xor4096=u}(0,e=n.nmd(e),n.amdD)},30:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xorshift7=u}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(t,n,t,s))||(s.exports=r):this.xorwow=u}(0,e=n.nmd(e),n.amdD)},971:function(e,t,n){var r;!function(s,a){var i,o=this,u=256,l=a.pow(u,6),c=a.pow(2,52),h=2*c,p=255;function d(e,t,n){var r=[],p=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(u):(e=new Uint8Array(u),(o.crypto||o.msCrypto).getRandomValues(e)),b(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,b(s)]}}():e,3),r),d=new f(r),x=function(){for(var e=d.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=d.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|d.g(4)},x.quick=function(){return d.g(4)/4294967296},x.double=x,y(b(d.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,d),e.state=function(){return m(d,{})}),n?(a.random=e,t):e})(x,p,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<u;)i[s]=s++;for(s=0;s<u;s++)i[s]=i[a=p&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=p&s+1],n=n*u+i[p&(i[s]=i[a=p&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[p&s]=p&(n^=19*t[p&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(a.seedrandom=d,y(a.random(),s),e.exports){e.exports=d;try{i=n(234)}catch(e){}}else void 0===(r=function(){return d}.call(t,n,t,e))||(e.exports=r)}([],Math)},462:function(e,t,n){"use strict";const r=n(432),s=(n(432),n(701));window.MediaRecorder=n(448);const a=document.getElementById("recordButton"),i=document.getElementById("stopButton"),o=document.querySelector(".visualizer"),u=document.createElement("img");let l,c=document.createElement("img");let h,p,d,f,m=!1;const g=o.getContext("2d");let y,b,x,w=[],v="";const k=44100;let I=null;v="Classifications processed on server:";const N=()=>{x=I.noUiSlider.get();let e=Math.round(parseFloat(x[0])),t=Math.round(parseFloat(x[1]));const n=document.getElementById("specImageHolder").scrollLeft;e+=n,t+=n;const s=Math.round(220.5),a=e*s/1,i=t*s/1;b=y.slice(a,i);const o=S(b),l=r.spectrogram_utils.dBSpectrogramToImage(o,80),c=Math.round(o.length);return u.src=l,u.height=300,u.width=c,b},S=e=>{const t=Math.round(661.5),n=Math.round(220.5),s=Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))),a={sampleRate:k,hopLength:n,winLength:t,nFft:s,topDB:80};return r.audio_utils.dBSpectrogram(e,a)},C=(e,t)=>{const n=Math.round(1*t);c=document.createElement("img"),c.src=e,c.height=300,c.width=n;const a=document.getElementById("specImageHolder");for(;a.firstChild;)a.removeChild(a.firstChild);a.appendChild(c);const i=document.getElementById("specSliderHolder");for(;i.firstChild;)i.removeChild(i.firstChild);I=document.createElement("div"),I.style.width=a.offsetWidth+"px",i.appendChild(I);const o=Math.round(220.5),u=k/o,l=Math.round(1.2*u),p=Math.min(t,l);s.create(I,{start:[0,p],behaviour:"drag-tap",connect:!0,margin:p,range:{min:0,max:a.offsetWidth}});r.ui_utils.MuiButton("Download Audio","downloadButtonHolder").onclick=()=>{N();const e=window.URL.createObjectURL(h),t=document.createElement("a");t.style.display="none",t.href=e,t.download="FullSongRecording.wav",document.body.appendChild(t),t.click(),setTimeout((()=>{document.body.removeChild(t),window.URL.revokeObjectURL(e)}),100)};r.ui_utils.MuiButton("Download Spectrogram","downloadSpecButtonHolder").onclick=()=>{N();const t=document.createElement("a");t.style.display="none",t.href=e,t.download="FullSpectrogram.png",document.body.appendChild(t),t.click(),setTimeout((()=>{document.body.removeChild(t),window.URL.revokeObjectURL(e)}),100)};r.ui_utils.MuiButton("Classify","specAnalyzeButtonHolder").onclick=async()=>{b=N(),await(async()=>{N();const e=document.getElementById("specSampleHolder");for(;e.firstChild;)e.removeChild(e.firstChild);const t=document.createElement("ul"),n=document.createElement("li");n.textContent=v,t.appendChild(n);{if(!d){const e=window.AudioContext||window.webkitAudioContext;d=new e}const n=N();let s=d.createBuffer(1,n.length,k);s.copyToChannel(n,0);let a=new Blob([r.audio_utils.bufferToWave(s,s.length)],{type:"audio/ogg; codecs=opus"});const i=new FormData;i.append("file",a,"snippet.wav"),fetch("/classify/api/select",{method:"POST",body:i}).then((n=>{n.json().then((n=>{let s;r.log("received scores!");let a=[];for(s in n)a.push([s,n[s]]);a=a.sort(((e,t)=>t[1]-e[1]));let i=v+"\nScores:\n";for(s in a){const n=document.createElement("li");n.textContent=" "+a[s].join(" "),i+="\n"+a[s].join(" "),t.appendChild(n),e.prepend(t),r.log(a[s].join(" "))}alert(i)}))})).catch((e=>{console.error(e)}))}})()}},E=()=>{g.fillStyle="rgb(255,255,255)",g.fillRect(0,0,o.width,o.height)};a.onclick=()=>{h=new Blob,y=new Float32Array,b=new Float32Array;const e=document.getElementById("specSliderHolder");for(;e.firstChild;)e.removeChild(e.firstChild);const t=document.getElementById("specImageHolder");for(;t.firstChild;)t.removeChild(t.firstChild);const n=document.getElementById("specSampleHolder");for(;n.firstChild;)n.removeChild(n.firstChild);navigator.mediaDevices.getUserMedia({audio:!0,video:!1}).then((e=>{p=new MediaRecorder(e,{mimeType:"audio/wav"}),p.start(),r.log("recorder started"),(e=>{d=null;const t=window.AudioContext||window.webkitAudioContext;d=new t;const n=d.createMediaStreamSource(e);f=d.createAnalyser(),f.fftSize=2048;const r=f.frequencyBinCount,s=new Uint8Array(r);n.connect(f),m=!0;const a=()=>{const e=o.width,t=o.height;m&&requestAnimationFrame(a),f.getByteTimeDomainData(s),g.fillStyle="rgb(255,255,255)",g.fillRect(0,0,e,t),g.lineWidth=2,g.strokeStyle="rgb(0, 0, 0)",g.beginPath();const n=e/r;let i=0;for(let e=0;e<r;e++){const r=s[e]/128*t/2;0===e?g.moveTo(i,r):g.lineTo(i,r),i+=n}g.lineTo(o.width,o.height/2),g.stroke()};a()})(e),i.removeAttribute("disabled"),a.setAttribute("disabled","disabled"),p.addEventListener("stop",(e=>{h=new Blob(w,{type:"audio/ogg; codecs=opus"}),w=[],l=window.URL.createObjectURL(h),r.log("recorder stopped"),r.audio_loader.loadAudioFromURL(l).then((e=>r.audio_loader.resampleAndMakeMono(e,k))).then((e=>{y=e;const t=S(e),n=r.spectrogram_utils.dBSpectrogramToImage(t,80);C(n,t.length)}))})),p.addEventListener("dataavailable",(e=>{w.push(e.data)}))}),(e=>{i.setAttribute("disabled","disabled"),a.removeAttribute("disabled")}))},i.onclick=()=>{p.stop(),m=!1,f.disconnect(),requestAnimationFrame(E),i.setAttribute("disabled","disabled"),a.removeAttribute("disabled"),p.stream.getTracks().forEach((e=>{"live"===e.readyState&&"audio"===e.kind&&e.stop()}))}},366:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.resampleAndMakeMono=t.getMonoAudio=t.loadAudioFromFile=t.loadAudioFromURL=void 0;const i=a(n(861)),o=a(n(906)),u=44100,l=window,c=l.webkitOfflineAudioContext,h=c?new l.webkitOfflineAudioContext(1,44100,44100):new l.OfflineAudioContext(1,u,u),p=e=>c?new Promise((t=>{h.decodeAudioData(e,(e=>{t(e)}))})):h.decodeAudioData(e);t.loadAudioFromURL=async e=>fetch(e).then((e=>e.arrayBuffer())).then((e=>p(e)));t.loadAudioFromFile=async e=>{const t=new FileReader;return new Promise(((n,r)=>{t.onerror=()=>{t.abort(),r(new DOMException("Something went wrong reading that file."))},t.onload=()=>{n(t.result)},t.readAsArrayBuffer(e)})).then((e=>p(e)))};t.getMonoAudio=e=>{if(1===e.numberOfChannels)return e.getChannelData(0);if(2!==e.numberOfChannels)throw Error(`${e.numberOfChannels} channel audio is not supported.`);const t=e.getChannelData(0),n=e.getChannelData(1),r=new Float32Array(e.length);for(let s=0;s<e.length;++s)r[s]=(t[s]+n[s])/2;return r};t.resampleAndMakeMono=async(e,n=44100)=>{if(e.sampleRate===n)return t.getMonoAudio(e);const r=e.sampleRate,s=e.length*n/r;if(c){const n=t.getMonoAudio(e),r=new Float32Array(s);return o(i(r,[s]),i(n,[n.length])),r}{const t=e.sampleRate,r=e.length*n/t,s=new OfflineAudioContext(1,r,n),a=s.createBufferSource();return a.buffer=e,a.connect(s.destination),a.start(),s.startRendering().then((e=>e.getChannelData(0)))}}},877:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.MerlinAudioModel=void 0;const i=a(n(654));t.MerlinAudioModel=class{constructor(e,t){this.sampleRate=22050,this.patchWindowSeconds=.96,this.patchHopSeconds=.48,this.modelURL=t,this.labelsURL=e}async ensureModelLoaded(){null==this.model&&(await this.ensureLabelsLoaded(),this.model=await i.loadGraphModel(this.modelURL))}async ensureLabelsLoaded(){null==this.labels&&(this.labels=await fetch(this.labelsURL).then((e=>e.json())))}async predict(e){await this.ensureModelLoaded();const t=this.patchWindowSeconds*this.sampleRate,n=this.patchHopSeconds*this.sampleRate;let r=i.tensor1d(e);r.shape[0]<t&&(r=r.pad([[0,t-e.length]]));const s=i.signal.frame(r,t,n),a=[];let o=this.patchWindowSeconds/2;const u=i.data.array(s.arraySync());return await u.forEachAsync((e=>{const t=i.tensor(e).expandDims(0),n=this.model.execute(t),r=n.dataSync(),s=n.argMax(-1).dataSync()[0],u=Math.max(...r);a.push([this.labels[s],u,o]),o+=this.patchHopSeconds})),i.dispose([r,s]),a}async averagePredictV3(e,t){await this.ensureModelLoaded();const n=1*t,r=.5*t,s=e.length;let a=null;a=Math.floor(s/n),a=Math.max(1,a);let o=0;const u=[];let l,c;for(let s=0;s<a;s++){const s=o+n;l=i.tensor1d(e.slice(o,s)),l.shape[0]<n&&(l=l.pad([[0,n-l.shape[0]]]));const a=l,h=i.tensor1d([t],"int32");c=await(this.model?.executeAsync({waveform:a,samplerate:h})),u.push(c.dataSync()),o+=r}const h=i.mean(i.tensor(u),0);h.print();const p=i.topk(h,this.labels.length,!0),d=p.values.dataSync(),f=p.indices.dataSync(),m=[];for(let e=0;e<this.labels.length;e++)m.push(this.labels[f[e]]);return i.dispose([l,undefined,undefined,c,h,p]),[m,d]}}},252:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.bufferToWave=t.hannWindow=t.createMelFilterbank=t.frame=t.padConstant=t.padCenterToLength=t.applyWindow=t.applyWholeFilterbank=t.stft=t.magSpectrogram=t.resampleAndMakeMono=t.getMonoAudio=t.powerToDb=t.melSpectrogram=t.loadAudioFromFile=t.loadAudioFromUrl=t.dBSpectrogram=t.fetch_audio=void 0;const i=a(n(906)),o=a(n(861)),u=n(65),l=22050,c=window,h=c.webkitOfflineAudioContext,p=h?new c.webkitOfflineAudioContext(1,44100,44100):new c.OfflineAudioContext(1,l,l);!window.AudioContext&&window.webkitAudioContext&&(window.AudioContext=window.webkitAudioContext,window.OfflineAudioContext=window.webkitOfflineAudioContext);t.fetch_audio=async(e,n)=>{const r=new window.AudioContext;return fetch(e).then((e=>e.arrayBuffer())).then((e=>2===r.decodeAudioData.length?new Promise((t=>{r.decodeAudioData(e,(e=>{t(e)}))})):r.decodeAudioData(e))).then((e=>{const r=e.sampleRate;return e.sampleRate===n?{waveform:t.getMonoAudio(e),sourceSampleRate:r}:((e,t)=>{const n=e.sampleRate,r=e.length*t/n,s=new OfflineAudioContext(1,r,t);return new Promise((t=>{const n=s.createBufferSource();n.buffer=e,s.oncomplete=e=>{t(e.renderedBuffer)},n.connect(s.destination),n.start(),s.startRendering()}))})(e,n).then((e=>({waveform:e.getChannelData(0),sourceSampleRate:r})))}))};t.dBSpectrogram=(e,n)=>{n.power||(n.power=2);const r=t.stft(e,n),[s,a]=t.magSpectrogram(r,n.power);n.nFft=a,n.topDB||(n.topDB=80);return((e,t=1e-10,n=80)=>{const r=e.length,s=e[0].length,a=[];for(let e=0;e<r;e++)a[e]=new Float32Array(s);const i=Math.max.apply(null,e.map((e=>Math.max.apply(null,e))));for(let n=0;n<r;n++)for(let r=0;r<s;r++){const s=e[n][r];a[n][r]=10*Math.log10(Math.max(t,s)),a[n][r]-=10*Math.log10(Math.max(t,i))}if(n){if(n<0)throw new Error("topDb must be non-negative.");const e=Math.max.apply(null,a.map((e=>Math.max.apply(null,e))));for(let t=0;t<r;t++)for(let r=0;r<s;r++)a[t][r]=Math.max(a[t][r],e-n)}return a})(s,1e-10,n.topDB)};t.loadAudioFromUrl=async e=>fetch(e).then((e=>e.arrayBuffer())).then((e=>p.decodeAudioData(e)));t.loadAudioFromFile=async e=>{const t=new FileReader;return new Promise(((n,r)=>{t.onerror=()=>{t.abort(),r(new DOMException("Something went wrong reading that file."))},t.onload=()=>{n(t.result)},t.readAsArrayBuffer(e)})).then((e=>p.decodeAudioData(e)))};t.melSpectrogram=(e,n)=>{n.power||(n.power=2);const r=t.stft(e,n),[s,a]=t.magSpectrogram(r,n.power);n.nFft=a;const i=t.createMelFilterbank(n);return t.applyWholeFilterbank(s,i)};t.powerToDb=(e,t=1e-10,n=80)=>{const r=e.length,s=e[0].length,a=[];for(let e=0;e<r;e++)a[e]=new Float32Array(s);for(let n=0;n<r;n++)for(let r=0;r<s;r++){const s=e[n][r];a[n][r]=10*Math.log10(Math.max(t,s))}if(n){if(n<0)throw new Error("topDb must be non-negative.");for(let e=0;e<r;e++){const t=N(a[e]);for(let r=0;r<s;r++)a[e][r]=Math.max(a[e][r],t-n)}}return a};t.getMonoAudio=e=>{if(1===e.numberOfChannels)return e.getChannelData(0);if(2!==e.numberOfChannels)throw Error(`${e.numberOfChannels} channel audio is not supported.`);const t=e.getChannelData(0),n=e.getChannelData(1),r=new Float32Array(e.length);for(let s=0;s<e.length;++s)r[s]=(t[s]+n[s])/2;return r};t.resampleAndMakeMono=async(e,n=22050)=>{if(e.sampleRate===n)return t.getMonoAudio(e);const r=e.sampleRate,s=e.length*n/r;if(h){const n=t.getMonoAudio(e),r=new Float32Array(s);return i(o(r,[s]),o(n,[n.length])),r}{const t=p.createBufferSource();return t.buffer=e,t.connect(p.destination),t.start(),p.startRendering().then((e=>e.getChannelData(0)))}};t.magSpectrogram=(e,t)=>[e.map((e=>I(y(e),t))),e[0].length-1];t.stft=(e,n)=>{const r=n.nFft||2048,s=n.winLength||r,a=n.hopLength||Math.floor(s/4);let i=t.hannWindow(s);i=t.padCenterToLength(i,r),e=f(e,Math.floor(r/2));const o=t.frame(e,r,a),u=[],l=o.length,c=r+2;for(let e=0;e<l;e++)u[e]=new Float32Array(c);for(let e=0;e<l;e++){const n=t.applyWindow(o[e],i),r=m(n);u[e].set(r.slice(0,c))}return u};t.applyWholeFilterbank=(e,t)=>{const n=[];for(let r=0;r<e.length;r++)n[r]=d(e[r],t);return n};const d=(e,n)=>{if(e.length!==n[0].length)throw new Error(`Each entry in filterbank should have dimensions matching FFT. |mags| = ${e.length}, |filterbank[0]| = ${n[0].length}.`);const r=new Float32Array(n.length);for(let s=0;s<n.length;s++){const a=t.applyWindow(e,n[s]);r[s]=a.reduce(((e,t)=>e+t))}return r};t.applyWindow=(e,t)=>{if(e.length!==t.length)return null;const n=new Float32Array(e.length);for(let r=0;r<e.length;r++)n[r]=t[r]*e[r];return n};t.padCenterToLength=(e,n)=>{if(e.length>n)throw new Error("Data is longer than length.");const r=Math.floor((n-e.length)/2),s=n-e.length-r;return t.padConstant(e,[r,s])};t.padConstant=(e,t)=>{let n,r;"object"==typeof t?[n,r]=t:n=r=t;const s=new Float32Array(e.length+n+r);return s.set(e,n),s};const f=(e,n)=>{const r=t.padConstant(e,n);for(let e=0;e<n;e++)r[e]=r[2*n-e],r[r.length-e-1]=r[r.length-2*n+e-1];return r};t.frame=(e,t,n)=>{const r=Math.floor((e.length-t)/n)+1,s=Array.from({length:r},((e,n)=>new Float32Array(t)));for(let a=0;a<r;a++){const r=a*n,i=e.slice(r,r+t);s[a].set(i)}return s};t.createMelFilterbank=e=>{const t=e.fMin||0,n=e.fMax||e.sampleRate/2,r=e.nMels||128,s=e.nFft||2048,a=x(e.sampleRate,s),i=w(r+2,t,n),o=v(i),u=k(i,a),l=u[0].length,c=[];for(let e=0;e<r;e++){c[e]=new Float32Array(l);for(let t=0;t<u[e].length;t++){const n=-u[e][t]/o[e],r=u[e+2][t]/o[e+1];c[e][t]=Math.max(0,Math.min(n,r))}}for(let e=0;e<c.length;e++){const t=2/(i[2+e]-i[e]);c[e]=c[e].map((e=>e*t))}return c};const m=e=>{const t=new u(e.length),n=t.createComplexArray(),r=t.toComplexArray(e,null);return t.transform(n,r),n};t.hannWindow=e=>{const t=new Float32Array(e);for(let n=0;n<e;n++)t[n]=.5*(1-Math.cos(2*Math.PI*n/(e-1)));return t};const g=(e,t,n)=>{const r=(t-e)/(n-1),s=new Float32Array(n);for(let t=0;t<n;t++)s[t]=e+r*t;return s},y=e=>{const t=new Float32Array(e.length/2);for(let n=0;n<e.length/2;n++)t[n]=Math.sqrt(e[2*n]*e[2*n]+e[2*n+1]*e[2*n+1]);return t},b=e=>1125*Math.log(1+e/700),x=(e,t)=>g(0,e/2,Math.floor(1+t/2)),w=(e,t,n)=>{const r=b(t),s=b(n);return g(r,s,e).map((e=>(e=>700*(Math.exp(e/1125)-1))(e)))},v=e=>{const t=new Float32Array(e.length-1);for(let n=0;n<e.length;n++)t[n]=e[n+1]-e[n];return t},k=(e,t)=>{const n=[];for(let r=0;r<e.length;r++)n[r]=new Float32Array(t.length);for(let r=0;r<e.length;r++)for(let s=0;s<t.length;s++)n[r][s]=e[r]-t[s];return n},I=(e,t)=>e.map((e=>Math.pow(e,t))),N=e=>e.reduce(((e,t)=>Math.max(e,t)));t.bufferToWave=(e,t)=>{let n,r,s=e.numberOfChannels,a=t*s*2+44,i=new ArrayBuffer(a),o=new DataView(i),u=[],l=0,c=0;for(p(1179011410),p(a-8),p(1163280727),p(544501094),p(16),h(1),h(s),p(e.sampleRate),p(2*e.sampleRate*s),h(2*s),h(16),p(1635017060),p(a-c-4),n=0;n<e.numberOfChannels;n++)u.push(e.getChannelData(n));for(;c<a;){for(n=0;n<s;n++)r=Math.max(-1,Math.min(1,u[n][l])),r=0|(.5+r<0?32768*r:32767*r),o.setInt16(c,r,!0),c+=2;l++}return new Blob([i],{type:"audio/wav"});function h(e){o.setUint16(c,e,!0),c+=2}function p(e){o.setUint32(c,e,!0),c+=4}}},127:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Greys=void 0,t.Greys=[[0,[1,1,1]],[.002,[1,1,1]],[.004,[.998,.998,.998]],[.006,[.998,.998,.998]],[.008,[.996,.996,.996]],[.01,[.996,.996,.996]],[.012,[.994,.994,.994]],[.014,[.994,.994,.994]],[.016,[.993,.993,.993]],[.018,[.993,.993,.993]],[.02,[.991,.991,.991]],[.022,[.991,.991,.991]],[.023,[.989,.989,.989]],[.025,[.989,.989,.989]],[.027,[.987,.987,.987]],[.029,[.987,.987,.987]],[.031,[.985,.985,.985]],[.033,[.985,.985,.985]],[.035,[.983,.983,.983]],[.037,[.983,.983,.983]],[.039,[.982,.982,.982]],[.041,[.982,.982,.982]],[.043,[.98,.98,.98]],[.045,[.98,.98,.98]],[.047,[.978,.978,.978]],[.049,[.978,.978,.978]],[.051,[.976,.976,.976]],[.053,[.976,.976,.976]],[.055,[.974,.974,.974]],[.057,[.974,.974,.974]],[.059,[.972,.972,.972]],[.061,[.972,.972,.972]],[.063,[.97,.97,.97]],[.065,[.97,.97,.97]],[.067,[.969,.969,.969]],[.068,[.969,.969,.969]],[.07,[.967,.967,.967]],[.072,[.967,.967,.967]],[.074,[.965,.965,.965]],[.076,[.965,.965,.965]],[.078,[.963,.963,.963]],[.08,[.963,.963,.963]],[.082,[.961,.961,.961]],[.084,[.961,.961,.961]],[.086,[.959,.959,.959]],[.088,[.959,.959,.959]],[.09,[.958,.958,.958]],[.092,[.958,.958,.958]],[.094,[.956,.956,.956]],[.096,[.956,.956,.956]],[.098,[.954,.954,.954]],[.1,[.954,.954,.954]],[.102,[.952,.952,.952]],[.104,[.952,.952,.952]],[.106,[.95,.95,.95]],[.108,[.95,.95,.95]],[.11,[.948,.948,.948]],[.112,[.948,.948,.948]],[.114,[.946,.946,.946]],[.115,[.946,.946,.946]],[.117,[.945,.945,.945]],[.119,[.945,.945,.945]],[.121,[.943,.943,.943]],[.123,[.943,.943,.943]],[.125,[.941,.941,.941]],[.127,[.941,.941,.941]],[.129,[.938,.938,.938]],[.131,[.938,.938,.938]],[.133,[.935,.935,.935]],[.135,[.935,.935,.935]],[.137,[.932,.932,.932]],[.139,[.932,.932,.932]],[.141,[.93,.93,.93]],[.143,[.93,.93,.93]],[.145,[.927,.927,.927]],[.147,[.927,.927,.927]],[.149,[.924,.924,.924]],[.151,[.924,.924,.924]],[.153,[.921,.921,.921]],[.155,[.921,.921,.921]],[.157,[.918,.918,.918]],[.159,[.918,.918,.918]],[.16,[.915,.915,.915]],[.162,[.915,.915,.915]],[.164,[.913,.913,.913]],[.166,[.913,.913,.913]],[.168,[.91,.91,.91]],[.17,[.91,.91,.91]],[.172,[.907,.907,.907]],[.174,[.907,.907,.907]],[.176,[.904,.904,.904]],[.178,[.904,.904,.904]],[.18,[.901,.901,.901]],[.182,[.901,.901,.901]],[.184,[.898,.898,.898]],[.186,[.898,.898,.898]],[.188,[.896,.896,.896]],[.19,[.896,.896,.896]],[.192,[.893,.893,.893]],[.194,[.893,.893,.893]],[.196,[.89,.89,.89]],[.198,[.89,.89,.89]],[.2,[.887,.887,.887]],[.202,[.887,.887,.887]],[.204,[.884,.884,.884]],[.205,[.884,.884,.884]],[.207,[.881,.881,.881]],[.209,[.881,.881,.881]],[.211,[.879,.879,.879]],[.213,[.879,.879,.879]],[.215,[.876,.876,.876]],[.217,[.876,.876,.876]],[.219,[.873,.873,.873]],[.221,[.873,.873,.873]],[.223,[.87,.87,.87]],[.225,[.87,.87,.87]],[.227,[.867,.867,.867]],[.229,[.867,.867,.867]],[.231,[.864,.864,.864]],[.233,[.864,.864,.864]],[.235,[.862,.862,.862]],[.237,[.862,.862,.862]],[.239,[.859,.859,.859]],[.241,[.859,.859,.859]],[.243,[.856,.856,.856]],[.245,[.856,.856,.856]],[.247,[.853,.853,.853]],[.249,[.853,.853,.853]],[.25,[.85,.85,.85]],[.252,[.85,.85,.85]],[.254,[.847,.847,.847]],[.256,[.847,.847,.847]],[.258,[.843,.843,.843]],[.26,[.843,.843,.843]],[.262,[.84,.84,.84]],[.264,[.84,.84,.84]],[.266,[.836,.836,.836]],[.268,[.836,.836,.836]],[.27,[.833,.833,.833]],[.272,[.833,.833,.833]],[.274,[.829,.829,.829]],[.276,[.829,.829,.829]],[.278,[.826,.826,.826]],[.28,[.826,.826,.826]],[.282,[.823,.823,.823]],[.284,[.823,.823,.823]],[.286,[.819,.819,.819]],[.288,[.819,.819,.819]],[.29,[.816,.816,.816]],[.292,[.816,.816,.816]],[.294,[.812,.812,.812]],[.295,[.812,.812,.812]],[.297,[.809,.809,.809]],[.299,[.809,.809,.809]],[.301,[.805,.805,.805]],[.303,[.805,.805,.805]],[.305,[.802,.802,.802]],[.307,[.802,.802,.802]],[.309,[.798,.798,.798]],[.311,[.798,.798,.798]],[.313,[.795,.795,.795]],[.315,[.795,.795,.795]],[.317,[.792,.792,.792]],[.319,[.792,.792,.792]],[.321,[.788,.788,.788]],[.323,[.788,.788,.788]],[.325,[.785,.785,.785]],[.327,[.785,.785,.785]],[.329,[.781,.781,.781]],[.331,[.781,.781,.781]],[.333,[.778,.778,.778]],[.335,[.778,.778,.778]],[.337,[.774,.774,.774]],[.339,[.774,.774,.774]],[.341,[.771,.771,.771]],[.342,[.771,.771,.771]],[.344,[.767,.767,.767]],[.346,[.767,.767,.767]],[.348,[.764,.764,.764]],[.35,[.764,.764,.764]],[.352,[.761,.761,.761]],[.354,[.761,.761,.761]],[.356,[.757,.757,.757]],[.358,[.757,.757,.757]],[.36,[.754,.754,.754]],[.362,[.754,.754,.754]],[.364,[.75,.75,.75]],[.366,[.75,.75,.75]],[.368,[.747,.747,.747]],[.37,[.747,.747,.747]],[.372,[.743,.743,.743]],[.374,[.743,.743,.743]],[.376,[.739,.739,.739]],[.378,[.739,.739,.739]],[.38,[.735,.735,.735]],[.382,[.735,.735,.735]],[.384,[.73,.73,.73]],[.386,[.73,.73,.73]],[.387,[.725,.725,.725]],[.389,[.725,.725,.725]],[.391,[.72,.72,.72]],[.393,[.72,.72,.72]],[.395,[.715,.715,.715]],[.397,[.715,.715,.715]],[.399,[.711,.711,.711]],[.401,[.711,.711,.711]],[.403,[.706,.706,.706]],[.405,[.706,.706,.706]],[.407,[.701,.701,.701]],[.409,[.701,.701,.701]],[.411,[.696,.696,.696]],[.413,[.696,.696,.696]],[.415,[.691,.691,.691]],[.417,[.691,.691,.691]],[.419,[.687,.687,.687]],[.421,[.687,.687,.687]],[.423,[.682,.682,.682]],[.425,[.682,.682,.682]],[.427,[.677,.677,.677]],[.429,[.677,.677,.677]],[.431,[.672,.672,.672]],[.432,[.672,.672,.672]],[.434,[.667,.667,.667]],[.436,[.667,.667,.667]],[.438,[.663,.663,.663]],[.44,[.663,.663,.663]],[.442,[.658,.658,.658]],[.444,[.658,.658,.658]],[.446,[.653,.653,.653]],[.448,[.653,.653,.653]],[.45,[.648,.648,.648]],[.452,[.648,.648,.648]],[.454,[.643,.643,.643]],[.456,[.643,.643,.643]],[.458,[.639,.639,.639]],[.46,[.639,.639,.639]],[.462,[.634,.634,.634]],[.464,[.634,.634,.634]],[.466,[.629,.629,.629]],[.468,[.629,.629,.629]],[.47,[.624,.624,.624]],[.472,[.624,.624,.624]],[.474,[.619,.619,.619]],[.476,[.619,.619,.619]],[.477,[.615,.615,.615]],[.479,[.615,.615,.615]],[.481,[.61,.61,.61]],[.483,[.61,.61,.61]],[.485,[.605,.605,.605]],[.487,[.605,.605,.605]],[.489,[.6,.6,.6]],[.491,[.6,.6,.6]],[.493,[.595,.595,.595]],[.495,[.595,.595,.595]],[.497,[.591,.591,.591]],[.499,[.591,.591,.591]],[.501,[.586,.586,.586]],[.503,[.586,.586,.586]],[.505,[.582,.582,.582]],[.507,[.582,.582,.582]],[.509,[.577,.577,.577]],[.511,[.577,.577,.577]],[.513,[.573,.573,.573]],[.515,[.573,.573,.573]],[.517,[.569,.569,.569]],[.519,[.569,.569,.569]],[.521,[.565,.565,.565]],[.523,[.565,.565,.565]],[.524,[.56,.56,.56]],[.526,[.56,.56,.56]],[.528,[.556,.556,.556]],[.53,[.556,.556,.556]],[.532,[.552,.552,.552]],[.534,[.552,.552,.552]],[.536,[.547,.547,.547]],[.538,[.547,.547,.547]],[.54,[.543,.543,.543]],[.542,[.543,.543,.543]],[.544,[.539,.539,.539]],[.546,[.539,.539,.539]],[.548,[.534,.534,.534]],[.55,[.534,.534,.534]],[.552,[.53,.53,.53]],[.554,[.53,.53,.53]],[.556,[.526,.526,.526]],[.558,[.526,.526,.526]],[.56,[.521,.521,.521]],[.562,[.521,.521,.521]],[.564,[.517,.517,.517]],[.566,[.517,.517,.517]],[.568,[.513,.513,.513]],[.569,[.513,.513,.513]],[.571,[.509,.509,.509]],[.573,[.509,.509,.509]],[.575,[.504,.504,.504]],[.577,[.504,.504,.504]],[.579,[.5,.5,.5]],[.581,[.5,.5,.5]],[.583,[.496,.496,.496]],[.585,[.496,.496,.496]],[.587,[.491,.491,.491]],[.589,[.491,.491,.491]],[.591,[.487,.487,.487]],[.593,[.487,.487,.487]],[.595,[.483,.483,.483]],[.597,[.483,.483,.483]],[.599,[.478,.478,.478]],[.601,[.478,.478,.478]],[.603,[.474,.474,.474]],[.605,[.474,.474,.474]],[.607,[.47,.47,.47]],[.609,[.47,.47,.47]],[.611,[.466,.466,.466]],[.613,[.466,.466,.466]],[.614,[.461,.461,.461]],[.616,[.461,.461,.461]],[.618,[.457,.457,.457]],[.62,[.457,.457,.457]],[.622,[.453,.453,.453]],[.624,[.453,.453,.453]],[.626,[.448,.448,.448]],[.628,[.448,.448,.448]],[.63,[.444,.444,.444]],[.632,[.444,.444,.444]],[.634,[.44,.44,.44]],[.636,[.44,.44,.44]],[.638,[.436,.436,.436]],[.64,[.436,.436,.436]],[.642,[.432,.432,.432]],[.644,[.432,.432,.432]],[.646,[.428,.428,.428]],[.648,[.428,.428,.428]],[.65,[.424,.424,.424]],[.652,[.424,.424,.424]],[.654,[.42,.42,.42]],[.656,[.42,.42,.42]],[.658,[.416,.416,.416]],[.659,[.416,.416,.416]],[.661,[.412,.412,.412]],[.663,[.412,.412,.412]],[.665,[.408,.408,.408]],[.667,[.408,.408,.408]],[.669,[.404,.404,.404]],[.671,[.404,.404,.404]],[.673,[.4,.4,.4]],[.675,[.4,.4,.4]],[.677,[.396,.396,.396]],[.679,[.396,.396,.396]],[.681,[.392,.392,.392]],[.683,[.392,.392,.392]],[.685,[.388,.388,.388]],[.687,[.388,.388,.388]],[.689,[.383,.383,.383]],[.691,[.383,.383,.383]],[.693,[.379,.379,.379]],[.695,[.379,.379,.379]],[.697,[.375,.375,.375]],[.699,[.375,.375,.375]],[.701,[.371,.371,.371]],[.703,[.371,.371,.371]],[.705,[.367,.367,.367]],[.706,[.367,.367,.367]],[.708,[.363,.363,.363]],[.71,[.363,.363,.363]],[.712,[.359,.359,.359]],[.714,[.359,.359,.359]],[.716,[.355,.355,.355]],[.718,[.355,.355,.355]],[.72,[.351,.351,.351]],[.722,[.351,.351,.351]],[.724,[.347,.347,.347]],[.726,[.347,.347,.347]],[.728,[.343,.343,.343]],[.73,[.343,.343,.343]],[.732,[.339,.339,.339]],[.734,[.339,.339,.339]],[.736,[.335,.335,.335]],[.738,[.335,.335,.335]],[.74,[.331,.331,.331]],[.742,[.331,.331,.331]],[.744,[.327,.327,.327]],[.746,[.327,.327,.327]],[.748,[.323,.323,.323]],[.75,[.323,.323,.323]],[.751,[.317,.317,.317]],[.753,[.317,.317,.317]],[.755,[.312,.312,.312]],[.757,[.312,.312,.312]],[.759,[.306,.306,.306]],[.761,[.306,.306,.306]],[.763,[.301,.301,.301]],[.765,[.301,.301,.301]],[.767,[.295,.295,.295]],[.769,[.295,.295,.295]],[.771,[.29,.29,.29]],[.773,[.29,.29,.29]],[.775,[.284,.284,.284]],[.777,[.284,.284,.284]],[.779,[.279,.279,.279]],[.781,[.279,.279,.279]],[.783,[.273,.273,.273]],[.785,[.273,.273,.273]],[.787,[.268,.268,.268]],[.789,[.268,.268,.268]],[.791,[.262,.262,.262]],[.793,[.262,.262,.262]],[.795,[.257,.257,.257]],[.796,[.257,.257,.257]],[.798,[.251,.251,.251]],[.8,[.251,.251,.251]],[.802,[.245,.245,.245]],[.804,[.245,.245,.245]],[.806,[.24,.24,.24]],[.808,[.24,.24,.24]],[.81,[.234,.234,.234]],[.812,[.234,.234,.234]],[.814,[.229,.229,.229]],[.816,[.229,.229,.229]],[.818,[.223,.223,.223]],[.82,[.223,.223,.223]],[.822,[.218,.218,.218]],[.824,[.218,.218,.218]],[.826,[.212,.212,.212]],[.828,[.212,.212,.212]],[.83,[.207,.207,.207]],[.832,[.207,.207,.207]],[.834,[.201,.201,.201]],[.836,[.201,.201,.201]],[.838,[.196,.196,.196]],[.84,[.196,.196,.196]],[.841,[.19,.19,.19]],[.843,[.19,.19,.19]],[.845,[.185,.185,.185]],[.847,[.185,.185,.185]],[.849,[.179,.179,.179]],[.851,[.179,.179,.179]],[.853,[.173,.173,.173]],[.855,[.173,.173,.173]],[.857,[.168,.168,.168]],[.859,[.168,.168,.168]],[.861,[.162,.162,.162]],[.863,[.162,.162,.162]],[.865,[.157,.157,.157]],[.867,[.157,.157,.157]],[.869,[.151,.151,.151]],[.871,[.151,.151,.151]],[.873,[.146,.146,.146]],[.875,[.146,.146,.146]],[.877,[.141,.141,.141]],[.879,[.141,.141,.141]],[.881,[.137,.137,.137]],[.883,[.137,.137,.137]],[.885,[.132,.132,.132]],[.886,[.132,.132,.132]],[.888,[.127,.127,.127]],[.89,[.127,.127,.127]],[.892,[.123,.123,.123]],[.894,[.123,.123,.123]],[.896,[.118,.118,.118]],[.898,[.118,.118,.118]],[.9,[.114,.114,.114]],[.902,[.114,.114,.114]],[.904,[.109,.109,.109]],[.906,[.109,.109,.109]],[.908,[.105,.105,.105]],[.91,[.105,.105,.105]],[.912,[.1,.1,.1]],[.914,[.1,.1,.1]],[.916,[.096,.096,.096]],[.918,[.096,.096,.096]],[.92,[.091,.091,.091]],[.922,[.091,.091,.091]],[.924,[.086,.086,.086]],[.926,[.086,.086,.086]],[.928,[.082,.082,.082]],[.93,[.082,.082,.082]],[.932,[.077,.077,.077]],[.933,[.077,.077,.077]],[.935,[.073,.073,.073]],[.937,[.073,.073,.073]],[.939,[.068,.068,.068]],[.941,[.068,.068,.068]],[.943,[.064,.064,.064]],[.945,[.064,.064,.064]],[.947,[.059,.059,.059]],[.949,[.059,.059,.059]],[.951,[.055,.055,.055]],[.953,[.055,.055,.055]],[.955,[.05,.05,.05]],[.957,[.05,.05,.05]],[.959,[.046,.046,.046]],[.961,[.046,.046,.046]],[.963,[.041,.041,.041]],[.965,[.041,.041,.041]],[.967,[.036,.036,.036]],[.969,[.036,.036,.036]],[.971,[.032,.032,.032]],[.973,[.032,.032,.032]],[.975,[.027,.027,.027]],[.977,[.027,.027,.027]],[.978,[.023,.023,.023]],[.98,[.023,.023,.023]],[.982,[.018,.018,.018]],[.984,[.018,.018,.018]],[.986,[.014,.014,.014]],[.988,[.014,.014,.014]],[.99,[.009,.009,.009]],[.992,[.009,.009,.009]],[.994,[.005,.005,.005]],[.996,[.005,.005,.005]],[.998,[0,0,0]],[1,[0,0,0]]]},432:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.log=t.ui_utils=t.spectrogram_utils=t.audio_utils=t.audio_loader=t.audio_model=t.AudioRecorder=t.tf=void 0;const o=a(n(366));t.audio_loader=o;const u=a(n(252));t.audio_utils=u;const l=a(n(442));t.spectrogram_utils=l;const c=a(n(877));t.audio_model=c;const h=a(n(545));t.ui_utils=h;const p=n(654);t.tf=p;const d=i(n(448));t.AudioRecorder=d.default;t.log=(e,t="Merlin:")=>{(0,console.log)(`%c ${t} `,"background:green; color:white",e)}},442:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateSpectrogramToURI=t.dBSpectrogramToImage=t.stft=t.padCenterToLength=t.applyWindow=t.frame=t.hannWindow=t.magSpectrogram=t.padConstant=void 0;const r=n(127),s=n(65);t.padConstant=(e,t)=>{let n,r;"object"==typeof t?[n,r]=t:n=r=t;const s=new Float32Array(e.length+n+r);return s.set(e,n),s};t.magSpectrogram=(e,t)=>[e.map((e=>((e,t)=>e.map((e=>Math.pow(e,t))))((e=>{const t=new Float32Array(e.length/2);for(let n=0;n<e.length/2;n++)t[n]=Math.sqrt(e[2*n]*e[2*n]+e[2*n+1]*e[2*n+1]);return t})(e),t))),e[0].length-1];const a=e=>{const t=new s(e.length),n=t.createComplexArray(),r=t.toComplexArray(e,null);return t.transform(n,r),n};t.hannWindow=e=>{const t=new Float32Array(e);for(let n=0;n<e;n++)t[n]=.5*(1-Math.cos(2*Math.PI*n/(e-1)));return t};t.frame=(e,t,n)=>{const r=Math.floor((e.length-t)/n)+1,s=Array.from({length:r},(()=>new Float32Array(t)));for(let a=0;a<r;a++){const r=a*n,i=e.slice(r,r+t);s[a].set(i)}return s};t.applyWindow=(e,t)=>{if(e.length!==t.length)return null;const n=new Float32Array(e.length);for(let r=0;r<e.length;r++)n[r]=t[r]*e[r];return n};t.padCenterToLength=(e,n)=>{if(e.length>n)throw new Error("Data is longer than length.");const r=Math.floor((n-e.length)/2),s=n-e.length-r;return t.padConstant(e,[r,s])};t.stft=(e,n)=>{const r=n.nFft||2048,s=n.winLength||r,i=n.hopLength||Math.floor(s/4);let o=t.hannWindow(s);o=t.padCenterToLength(o,r),e=((e,n)=>{const r=t.padConstant(e,n);for(let e=0;e<n;e++)r[e]=r[2*n-e],r[r.length-e-1]=r[r.length-2*n+e-1];return r})(e,Math.floor(r/2));const u=t.frame(e,r,i),l=[],c=u.length,h=r+2;for(let e=0;e<c;e++)l[e]=new Float32Array(h);for(let e=0;e<c;e++){const n=t.applyWindow(u[e],o),r=a(n);l[e].set(r.slice(0,h))}return l};const i=e=>{let t=1;for(;r.Greys[t][0]<e;)t+=1;t-=1;const n=r.Greys[t][0],s=r.Greys[t+1][0],a=(e-n)/Math.abs(n-s),i=r.Greys[t+1][1][0];return i+a*(i-r.Greys[t][1][0])};t.dBSpectrogramToImage=(e,t)=>{const n=e.length,r=(e[0].length,e[1].length),s=new Uint8ClampedArray(n*r*4);for(let a=0;a<r;a++)for(let o=0;o<n;o++){let u=e[o][r-1-a];u=1-Math.abs(u/t);const l=i(u),c=4*(a*n+o);s[c]=255*l,s[c+1]=255*l,s[c+2]=255*l,s[c+3]=255}const a=document.createElement("canvas"),o=a.getContext("2d");a.width=n,a.height=r;const u=o.createImageData(n,r);return u.data.set(s),o.putImageData(u,0,0),a.toDataURL()};t.generateSpectrogramToURI=e=>{const n=44100,r=Math.round(661.5),s=Math.round(220.5),a=Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))),i=((e,n)=>{n.power||(n.power=2);const r=t.stft(e,n),[s,a]=t.magSpectrogram(r,n.power);n.nFft=a,n.topDB||(n.topDB=80);return((e,t=1e-10,n=80)=>{const r=e.length,s=e[0].length,a=[];for(let e=0;e<r;e++)a[e]=new Float32Array(s);const i=Math.max.apply(null,e.map((e=>Math.max.apply(null,e))));for(let n=0;n<r;n++)for(let r=0;r<s;r++){const s=e[n][r];a[n][r]=10*Math.log10(Math.max(t,s)),a[n][r]-=10*Math.log10(Math.max(t,i))}if(n){if(n<0)throw new Error("topDb must be non-negative.");const e=Math.max.apply(null,a.map((e=>Math.max.apply(null,e))));for(let t=0;t<r;t++)for(let r=0;r<s;r++)a[t][r]=Math.max(a[t][r],e-n)}return a})(s,1e-10,n.topDB)})(e,{sampleRate:n,hopLength:s,winLength:r,nFft:a,topDB:80});return t.dBSpectrogramToImage(i,80)}},545:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateSpectrogramToURI=t.MuiButton=void 0;const r=n(432);t.MuiButton=(e,t)=>{const n=document.getElementById(t),r=document.createElement("button");for(r.classList.add("mui-btn"),r.classList.add("mui-btn--raised"),r.textContent=e;n?.firstChild;)n?.removeChild(n?.firstChild);return n?.appendChild(r),r};t.generateSpectrogramToURI=e=>{const t=44100,n=Math.round(661.5),s={sampleRate:t,hopLength:Math.round(220.5),winLength:n,nFft:Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))),topDB:80},a=r.audio_utils.dBSpectrogram(e,s);return r.spectrogram_utils.dBSpectrogramToImage(a,80)}},316:function(e,t,n){"use strict";var r=n(746),s=n(841),a=n(764).lW;n.g.__TYPEDARRAY_POOL||(n.g.__TYPEDARRAY_POOL={UINT8:s([32,0]),UINT16:s([32,0]),UINT32:s([32,0]),BIGUINT64:s([32,0]),INT8:s([32,0]),INT16:s([32,0]),INT32:s([32,0]),BIGINT64:s([32,0]),FLOAT:s([32,0]),DOUBLE:s([32,0]),DATA:s([32,0]),UINT8C:s([32,0]),BUFFER:s([32,0])});var i="undefined"!=typeof Uint8ClampedArray,o="undefined"!=typeof BigUint64Array,u="undefined"!=typeof BigInt64Array,l=n.g.__TYPEDARRAY_POOL;l.UINT8C||(l.UINT8C=s([32,0])),l.BIGUINT64||(l.BIGUINT64=s([32,0])),l.BIGINT64||(l.BIGINT64=s([32,0])),l.BUFFER||(l.BUFFER=s([32,0]));var c=l.DATA,h=l.BUFFER;function p(e){if(e){var t=e.length||e.byteLength,n=r.log2(t);c[n].push(e)}}function d(e){e=r.nextPow2(e);var t=r.log2(e),n=c[t];return n.length>0?n.pop():new ArrayBuffer(e)}function f(e){return new Uint8Array(d(e),0,e)}function m(e){return new Uint16Array(d(2*e),0,e)}function g(e){return new Uint32Array(d(4*e),0,e)}function y(e){return new Int8Array(d(e),0,e)}function b(e){return new Int16Array(d(2*e),0,e)}function x(e){return new Int32Array(d(4*e),0,e)}function w(e){return new Float32Array(d(4*e),0,e)}function v(e){return new Float64Array(d(8*e),0,e)}function k(e){return i?new Uint8ClampedArray(d(e),0,e):f(e)}function I(e){return o?new BigUint64Array(d(8*e),0,e):null}function N(e){return u?new BigInt64Array(d(8*e),0,e):null}function S(e){return new DataView(d(e),0,e)}function C(e){e=r.nextPow2(e);var t=r.log2(e),n=h[t];return n.length>0?n.pop():new a(e)}t.free=function(e){if(a.isBuffer(e))h[r.log2(e.length)].push(e);else{if("[object ArrayBuffer]"!==Object.prototype.toString.call(e)&&(e=e.buffer),!e)return;var t=e.length||e.byteLength,n=0|r.log2(t);c[n].push(e)}},t.freeUint8=t.freeUint16=t.freeUint32=t.freeBigUint64=t.freeInt8=t.freeInt16=t.freeInt32=t.freeBigInt64=t.freeFloat32=t.freeFloat=t.freeFloat64=t.freeDouble=t.freeUint8Clamped=t.freeDataView=function(e){p(e.buffer)},t.freeArrayBuffer=p,t.freeBuffer=function(e){h[r.log2(e.length)].push(e)},t.malloc=function(e,t){if(void 0===t||"arraybuffer"===t)return d(e);switch(t){case"uint8":return f(e);case"uint16":return m(e);case"uint32":return g(e);case"int8":return y(e);case"int16":return b(e);case"int32":return x(e);case"float":case"float32":return w(e);case"double":case"float64":return v(e);case"uint8_clamped":return k(e);case"bigint64":return N(e);case"biguint64":return I(e);case"buffer":return C(e);case"data":case"dataview":return S(e);default:return null}return null},t.mallocArrayBuffer=d,t.mallocUint8=f,t.mallocUint16=m,t.mallocUint32=g,t.mallocInt8=y,t.mallocInt16=b,t.mallocInt32=x,t.mallocFloat32=t.mallocFloat=w,t.mallocFloat64=t.mallocDouble=v,t.mallocUint8Clamped=k,t.mallocBigUint64=I,t.mallocBigInt64=N,t.mallocDataView=S,t.mallocBuffer=C,t.clearCache=function(){for(var e=0;e<32;++e)l.UINT8[e].length=0,l.UINT16[e].length=0,l.UINT32[e].length=0,l.INT8[e].length=0,l.INT16[e].length=0,l.INT32[e].length=0,l.FLOAT[e].length=0,l.DOUBLE[e].length=0,l.BIGUINT64[e].length=0,l.BIGINT64[e].length=0,l.UINT8C[e].length=0,c[e].length=0,h[e].length=0}},706:function(e){"use strict";e.exports=function(e,t,n){return 0===e.length?e:t?(n||e.sort(t),function(e,t){for(var n=1,r=e.length,s=e[0],a=e[0],i=1;i<r;++i)if(a=s,t(s=e[i],a)){if(i===n){n++;continue}e[n++]=s}return e.length=n,e}(e,t)):(n||e.sort(),function(e){for(var t=1,n=e.length,r=e[0],s=e[0],a=1;a<n;++a,s=r)if(s=r,(r=e[a])!==s){if(a===t){t++;continue}e[t++]=r}return e.length=t,e}(e))}},234:function(){},993:function(){},352:function(){},589:function(){},758:function(){}},t={};function n(r){if(t[r])return t[r].exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n(462)}();